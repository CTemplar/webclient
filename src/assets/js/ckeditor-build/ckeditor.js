/*!
 * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */
!(function (t) {
  const e = (t.en = t.en || {});
  e.dictionary = Object.assign(e.dictionary || {}, {
    '%0 of %1': '%0 of %1',
    'Align center': 'Align center',
    'Align left': 'Align left',
    'Align right': 'Align right',
    Aquamarine: 'Aquamarine',
    Big: 'Big',
    Black: 'Black',
    'Block quote': 'Block quote',
    Blue: 'Blue',
    Bold: 'Bold',
    'Bulleted List': 'Bulleted List',
    'Bulleted list styles toolbar': 'Bulleted list styles toolbar',
    Cancel: 'Cancel',
    'Centered image': 'Centered image',
    'Change image text alternative': 'Change image text alternative',
    'Choose heading': 'Choose heading',
    Circle: 'Circle',
    Column: 'Column',
    Decimal: 'Decimal',
    'Decimal with leading zero': 'Decimal with leading zero',
    'Decrease indent': 'Decrease indent',
    Default: 'Default',
    'Delete column': 'Delete column',
    'Delete row': 'Delete row',
    'Dim grey': 'Dim grey',
    Disc: 'Disc',
    'Document colors': 'Document colors',
    Downloadable: 'Downloadable',
    'Dropdown toolbar': 'Dropdown toolbar',
    'Edit block': 'Edit block',
    'Edit link': 'Edit link',
    'Editor toolbar': 'Editor toolbar',
    'Enter image caption': 'Enter image caption',
    'Font Background Color': 'Font Background Color',
    'Font Color': 'Font Color',
    'Font Family': 'Font Family',
    'Font Size': 'Font Size',
    'Full size image': 'Full size image',
    Green: 'Green',
    Grey: 'Grey',
    'Header column': 'Header column',
    'Header row': 'Header row',
    Heading: 'Heading',
    'Heading 1': 'Heading 1',
    'Heading 2': 'Heading 2',
    'Heading 3': 'Heading 3',
    'Heading 4': 'Heading 4',
    'Heading 5': 'Heading 5',
    'Heading 6': 'Heading 6',
    Huge: 'Huge',
    'Image resize list': 'Image resize list',
    'Image toolbar': 'Image toolbar',
    'image widget': 'image widget',
    'Increase indent': 'Increase indent',
    'Insert column left': 'Insert column left',
    'Insert column right': 'Insert column right',
    'Insert image': 'Insert image',
    'Insert paragraph after block': 'Insert paragraph after block',
    'Insert paragraph before block': 'Insert paragraph before block',
    'Insert row above': 'Insert row above',
    'Insert row below': 'Insert row below',
    'Insert table': 'Insert table',
    Italic: 'Italic',
    Justify: 'Justify',
    'Left aligned image': 'Left aligned image',
    'Light blue': 'Light blue',
    'Light green': 'Light green',
    'Light grey': 'Light grey',
    Link: 'Link',
    'Link URL': 'Link URL',
    'Lower-latin': 'Lower-latin',
    'Lower–roman': 'Lower–roman',
    'Merge cell down': 'Merge cell down',
    'Merge cell left': 'Merge cell left',
    'Merge cell right': 'Merge cell right',
    'Merge cell up': 'Merge cell up',
    'Merge cells': 'Merge cells',
    Next: 'Next',
    'Numbered List': 'Numbered List',
    'Numbered list styles toolbar': 'Numbered list styles toolbar',
    'Open in a new tab': 'Open in a new tab',
    'Open link in new tab': 'Open link in new tab',
    Orange: 'Orange',
    Original: 'Original',
    Paragraph: 'Paragraph',
    Previous: 'Previous',
    Purple: 'Purple',
    Red: 'Red',
    Redo: 'Redo',
    'Remove color': 'Remove color',
    'Remove Format': 'Remove Format',
    'Resize image': 'Resize image',
    'Resize image to %0': 'Resize image to %0',
    'Resize image to the original size': 'Resize image to the original size',
    'Rich Text Editor': 'Rich Text Editor',
    'Rich Text Editor, %0': 'Rich Text Editor, %0',
    'Right aligned image': 'Right aligned image',
    Row: 'Row',
    Save: 'Save',
    'Select all': 'Select all',
    'Select column': 'Select column',
    'Select row': 'Select row',
    'Show more items': 'Show more items',
    'Side image': 'Side image',
    Small: 'Small',
    'Split cell horizontally': 'Split cell horizontally',
    'Split cell vertically': 'Split cell vertically',
    Square: 'Square',
    'Text alignment': 'Text alignment',
    'Text alignment toolbar': 'Text alignment toolbar',
    'Text alternative': 'Text alternative',
    'This link has no URL': 'This link has no URL',
    Tiny: 'Tiny',
    'To-do List': 'To-do List',
    'Toggle the circle list style': 'Toggle the circle list style',
    'Toggle the decimal list style': 'Toggle the decimal list style',
    'Toggle the decimal with leading zero list style': 'Toggle the decimal with leading zero list style',
    'Toggle the disc list style': 'Toggle the disc list style',
    'Toggle the lower–latin list style': 'Toggle the lower–latin list style',
    'Toggle the lower–roman list style': 'Toggle the lower–roman list style',
    'Toggle the square list style': 'Toggle the square list style',
    'Toggle the upper–latin list style': 'Toggle the upper–latin list style',
    'Toggle the upper–roman list style': 'Toggle the upper–roman list style',
    Turquoise: 'Turquoise',
    Underline: 'Underline',
    Undo: 'Undo',
    Unlink: 'Unlink',
    'Upload failed': 'Upload failed',
    'Upload in progress': 'Upload in progress',
    'Upper-latin': 'Upper-latin',
    'Upper-roman': 'Upper-roman',
    White: 'White',
    'Widget toolbar': 'Widget toolbar',
    Yellow: 'Yellow',
  });
})(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})),
  (function (t, e) {
    'object' == typeof exports && 'object' == typeof module
      ? (module.exports = e())
      : 'function' == typeof define && define.amd
      ? define([], e)
      : 'object' == typeof exports
      ? (exports.DecoupledDocumentEditor = e())
      : (t.DecoupledDocumentEditor = e());
  })(window, function () {
    return (function (t) {
      var e = {};
      function n(o) {
        if (e[o]) return e[o].exports;
        var i = (e[o] = { i: o, l: !1, exports: {} });
        return t[o].call(i.exports, i, i.exports, n), (i.l = !0), i.exports;
      }
      return (
        (n.m = t),
        (n.c = e),
        (n.d = function (t, e, o) {
          n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: o });
        }),
        (n.r = function (t) {
          'undefined' != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }),
            Object.defineProperty(t, '__esModule', { value: !0 });
        }),
        (n.t = function (t, e) {
          if ((1 & e && (t = n(t)), 8 & e)) return t;
          if (4 & e && 'object' == typeof t && t && t.__esModule) return t;
          var o = Object.create(null);
          if (
            (n.r(o), Object.defineProperty(o, 'default', { enumerable: !0, value: t }), 2 & e && 'string' != typeof t)
          )
            for (var i in t)
              n.d(
                o,
                i,
                function (e) {
                  return t[e];
                }.bind(null, i),
              );
          return o;
        }),
        (n.n = function (t) {
          var e =
            t && t.__esModule
              ? function () {
                  return t.default;
                }
              : function () {
                  return t;
                };
          return n.d(e, 'a', e), e;
        }),
        (n.o = function (t, e) {
          return Object.prototype.hasOwnProperty.call(t, e);
        }),
        (n.p = ''),
        n((n.s = 63))
      );
    })([
      function (t, e, n) {
        'use strict';
        n.d(e, 'a', function () {
          return o;
        }),
          n.d(e, 'b', function () {
            return i;
          });
        class o extends Error {
          constructor(t, e, n) {
            super(`${t}${n ? ` ${JSON.stringify(n)}` : ''}${r(t)}`),
              (this.name = 'CKEditorError'),
              (this.context = e),
              (this.data = n);
          }
          is(t) {
            return 'CKEditorError' === t;
          }
          static rethrowUnexpectedError(t, e) {
            if (t.is && t.is('CKEditorError')) throw t;
            const n = new o(t.message, e);
            throw ((n.stack = t.stack), n);
          }
        }
        function i(t, e) {
          console.warn(...s(t, e));
        }
        function r(t) {
          return `\nRead more: https://ckeditor.com/docs/ckeditor5/latest/framework/guides/support/error-codes.html#error-${t}`;
        }
        function s(t, e) {
          const n = r(t);
          return e ? [t, e, n] : [t, n];
        }
      },
      function (t, e, n) {
        'use strict';
        var o,
          i = function () {
            return void 0 === o && (o = Boolean(window && document && document.all && !window.atob)), o;
          },
          r = (function () {
            var t = {};
            return function (e) {
              if (void 0 === t[e]) {
                var n = document.querySelector(e);
                if (window.HTMLIFrameElement && n instanceof window.HTMLIFrameElement)
                  try {
                    n = n.contentDocument.head;
                  } catch (t) {
                    n = null;
                  }
                t[e] = n;
              }
              return t[e];
            };
          })(),
          s = [];
        function a(t) {
          for (var e = -1, n = 0; n < s.length; n++)
            if (s[n].identifier === t) {
              e = n;
              break;
            }
          return e;
        }
        function c(t, e) {
          for (var n = {}, o = [], i = 0; i < t.length; i++) {
            var r = t[i],
              c = e.base ? r[0] + e.base : r[0],
              l = n[c] || 0,
              d = ''.concat(c, ' ').concat(l);
            n[c] = l + 1;
            var h = a(d),
              u = { css: r[1], media: r[2], sourceMap: r[3] };
            -1 !== h
              ? (s[h].references++, s[h].updater(u))
              : s.push({ identifier: d, updater: f(u, e), references: 1 }),
              o.push(d);
          }
          return o;
        }
        function l(t) {
          var e = document.createElement('style'),
            o = t.attributes || {};
          if (void 0 === o.nonce) {
            var i = n.nc;
            i && (o.nonce = i);
          }
          if (
            (Object.keys(o).forEach(function (t) {
              e.setAttribute(t, o[t]);
            }),
            'function' == typeof t.insert)
          )
            t.insert(e);
          else {
            var s = r(t.insert || 'head');
            if (!s)
              throw new Error(
                "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.",
              );
            s.appendChild(e);
          }
          return e;
        }
        var d,
          h =
            ((d = []),
            function (t, e) {
              return (d[t] = e), d.filter(Boolean).join('\n');
            });
        function u(t, e, n, o) {
          var i = n ? '' : o.media ? '@media '.concat(o.media, ' {').concat(o.css, '}') : o.css;
          if (t.styleSheet) t.styleSheet.cssText = h(e, i);
          else {
            var r = document.createTextNode(i),
              s = t.childNodes;
            s[e] && t.removeChild(s[e]), s.length ? t.insertBefore(r, s[e]) : t.appendChild(r);
          }
        }
        function p(t, e, n) {
          var o = n.css,
            i = n.media,
            r = n.sourceMap;
          if (
            (i ? t.setAttribute('media', i) : t.removeAttribute('media'),
            r &&
              'undefined' != typeof btoa &&
              (o += '\n/*# sourceMappingURL=data:application/json;base64,'.concat(
                btoa(unescape(encodeURIComponent(JSON.stringify(r)))),
                ' */',
              )),
            t.styleSheet)
          )
            t.styleSheet.cssText = o;
          else {
            for (; t.firstChild; ) t.removeChild(t.firstChild);
            t.appendChild(document.createTextNode(o));
          }
        }
        var m = null,
          g = 0;
        function f(t, e) {
          var n, o, i;
          if (e.singleton) {
            var r = g++;
            (n = m || (m = l(e))), (o = u.bind(null, n, r, !1)), (i = u.bind(null, n, r, !0));
          } else
            (n = l(e)),
              (o = p.bind(null, n, e)),
              (i = function () {
                !(function (t) {
                  if (null === t.parentNode) return !1;
                  t.parentNode.removeChild(t);
                })(n);
              });
          return (
            o(t),
            function (e) {
              if (e) {
                if (e.css === t.css && e.media === t.media && e.sourceMap === t.sourceMap) return;
                o((t = e));
              } else i();
            }
          );
        }
        t.exports = function (t, e) {
          (e = e || {}).singleton || 'boolean' == typeof e.singleton || (e.singleton = i());
          var n = c((t = t || []), e);
          return function (t) {
            if (((t = t || []), '[object Array]' === Object.prototype.toString.call(t))) {
              for (var o = 0; o < n.length; o++) {
                var i = a(n[o]);
                s[i].references--;
              }
              for (var r = c(t, e), l = 0; l < n.length; l++) {
                var d = a(n[l]);
                0 === s[d].references && (s[d].updater(), s.splice(d, 1));
              }
              n = r;
            }
          };
        };
      },
      function (t, e, n) {
        'use strict';
        function o(t, e) {
          return (
            (function (t) {
              if (Array.isArray(t)) return t;
            })(t) ||
            (function (t, e) {
              var n = t && (('undefined' != typeof Symbol && t[Symbol.iterator]) || t['@@iterator']);
              if (null == n) return;
              var o,
                i,
                r = [],
                s = !0,
                a = !1;
              try {
                for (n = n.call(t); !(s = (o = n.next()).done) && (r.push(o.value), !e || r.length !== e); s = !0);
              } catch (t) {
                (a = !0), (i = t);
              } finally {
                try {
                  s || null == n.return || n.return();
                } finally {
                  if (a) throw i;
                }
              }
              return r;
            })(t, e) ||
            (function (t, e) {
              if (!t) return;
              if ('string' == typeof t) return i(t, e);
              var n = Object.prototype.toString.call(t).slice(8, -1);
              'Object' === n && t.constructor && (n = t.constructor.name);
              if ('Map' === n || 'Set' === n) return Array.from(t);
              if ('Arguments' === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return i(t, e);
            })(t, e) ||
            (function () {
              throw new TypeError(
                'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
              );
            })()
          );
        }
        function i(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
          return o;
        }
        t.exports = function (t) {
          var e = o(t, 4),
            n = e[1],
            i = e[3];
          if ('function' == typeof btoa) {
            var r = btoa(unescape(encodeURIComponent(JSON.stringify(i)))),
              s = 'sourceMappingURL=data:application/json;charset=utf-8;base64,'.concat(r),
              a = '/*# '.concat(s, ' */'),
              c = i.sources.map(function (t) {
                return '/*# sourceURL='.concat(i.sourceRoot || '').concat(t, ' */');
              });
            return [n].concat(c).concat([a]).join('\n');
          }
          return [n].join('\n');
        };
      },
      function (t, e, n) {
        'use strict';
        t.exports = function (t) {
          var e = [];
          return (
            (e.toString = function () {
              return this.map(function (e) {
                var n = t(e);
                return e[2] ? '@media '.concat(e[2], ' {').concat(n, '}') : n;
              }).join('');
            }),
            (e.i = function (t, n, o) {
              'string' == typeof t && (t = [[null, t, '']]);
              var i = {};
              if (o)
                for (var r = 0; r < this.length; r++) {
                  var s = this[r][0];
                  null != s && (i[s] = !0);
                }
              for (var a = 0; a < t.length; a++) {
                var c = [].concat(t[a]);
                (o && i[c[0]]) || (n && (c[2] ? (c[2] = ''.concat(n, ' and ').concat(c[2])) : (c[2] = n)), e.push(c));
              }
            }),
            e
          );
        };
      },
      ,
      function (t, e, n) {
        'use strict';
        var o = n(9),
          i = 'object' == typeof self && self && self.Object === Object && self,
          r = o.a || i || Function('return this')();
        e.a = r;
      },
      function (t, e, n) {
        'use strict';
        (function (t) {
          var o = n(5),
            i = n(62),
            r = 'object' == typeof exports && exports && !exports.nodeType && exports,
            s = r && 'object' == typeof t && t && !t.nodeType && t,
            a = s && s.exports === r ? o.a.Buffer : void 0,
            c = (a ? a.isBuffer : void 0) || i.a;
          e.a = c;
        }.call(this, n(11)(t)));
      },
      function (t, e, n) {
        'use strict';
        (function (t) {
          var o = n(9),
            i = 'object' == typeof exports && exports && !exports.nodeType && exports,
            r = i && 'object' == typeof t && t && !t.nodeType && t,
            s = r && r.exports === i && o.a.process,
            a = (function () {
              try {
                var t = r && r.require && r.require('util').types;
                return t || (s && s.binding && s.binding('util'));
              } catch (t) {}
            })();
          e.a = a;
        }.call(this, n(11)(t)));
      },
      function (t, e, n) {
        'use strict';
        (function (t) {
          var e = n(0);
          const o = '28.0.0';
          const i = 'object' == typeof window ? window : t;
          if (i.CKEDITOR_VERSION) throw new e.a('ckeditor-duplicated-modules', null);
          i.CKEDITOR_VERSION = o;
        }.call(this, n(61)));
      },
      function (t, e, n) {
        'use strict';
        (function (t) {
          var n = 'object' == typeof t && t && t.Object === Object && t;
          e.a = n;
        }.call(this, n(61)));
      },
      function (t, e, n) {
        'use strict';
        (function (t) {
          var o = n(5),
            i = 'object' == typeof exports && exports && !exports.nodeType && exports,
            r = i && 'object' == typeof t && t && !t.nodeType && t,
            s = r && r.exports === i ? o.a.Buffer : void 0,
            a = s ? s.allocUnsafe : void 0;
          e.a = function (t, e) {
            if (e) return t.slice();
            var n = t.length,
              o = a ? a(n) : new t.constructor(n);
            return t.copy(o), o;
          };
        }.call(this, n(11)(t)));
      },
      function (t, e) {
        t.exports = function (t) {
          if (!t.webpackPolyfill) {
            var e = Object.create(t);
            e.children || (e.children = []),
              Object.defineProperty(e, 'loaded', {
                enumerable: !0,
                get: function () {
                  return e.l;
                },
              }),
              Object.defineProperty(e, 'id', {
                enumerable: !0,
                get: function () {
                  return e.i;
                },
              }),
              Object.defineProperty(e, 'exports', { enumerable: !0 }),
              (e.webpackPolyfill = 1);
          }
          return e;
        };
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck-hidden{display:none!important}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{box-sizing:border-box;width:auto;height:auto;position:static}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#c4c4c4;--ck-color-base-action:#61b045;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#198cf0;--ck-color-base-active-focus:#0e7fe1;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:208,79%,51%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#bcdefb;--ck-color-focus-disabled-shadow:rgba(119,186,248,0.3);--ck-color-focus-error-shadow:rgba(255,64,31,0.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,0.15);--ck-color-shadow-drop-active:rgba(0,0,0,0.2);--ck-color-shadow-inner:rgba(0,0,0,0.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#e6e6e6;--ck-color-button-default-active-background:#d9d9d9;--ck-color-button-default-active-shadow:#bfbfbf;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#dedede;--ck-color-button-on-hover-background:#c4c4c4;--ck-color-button-on-active-background:#bababa;--ck-color-button-on-active-shadow:#a1a1a1;--ck-color-button-on-disabled-background:#dedede;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#579e3d;--ck-color-button-action-active-background:#53973b;--ck-color-button-action-active-shadow:#498433;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#b0b0b0;--ck-color-switch-button-off-hover-background:#a3a3a3;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#579e3d;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,0.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:#c7c7c7;--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:#c7c7c7;--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-base-active);--ck-color-list-button-on-background-focus:var(--ck-color-base-active-focus);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-foreground);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,177,255,0.1);--ck-color-link-fake-selection:rgba(31,177,255,0.3);--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{margin:0;padding:0;border:0;background:transparent;text-decoration:none;vertical-align:middle;transition:none;word-wrap:break-word}.ck.ck-reset_all,.ck.ck-reset_all *{border-collapse:collapse;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);color:var(--ck-color-text);text-align:left;white-space:nowrap;cursor:auto;float:none}.ck.ck-reset_all .ck-rtl *{text-align:right}.ck.ck-reset_all iframe{vertical-align:inherit}.ck.ck-reset_all textarea{white-space:pre-wrap}.ck.ck-reset_all input[type=password],.ck.ck-reset_all input[type=text],.ck.ck-reset_all textarea{cursor:text}.ck.ck-reset_all input[type=password][disabled],.ck.ck-reset_all input[type=text][disabled],.ck.ck-reset_all textarea[disabled]{cursor:default}.ck.ck-reset_all fieldset{padding:10px;border:2px groove #dfdee3}.ck.ck-reset_all button::-moz-focus-inner{padding:0;border:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_hidden.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_reset.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_zindex.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_transition.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css',
            ],
            names: [],
            mappings:
              'AAQA,WAGC,sBACD,CCPA,iDAGC,qBAAsB,CACtB,UAAW,CACX,WAAY,CACZ,eACD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAgD,CAChD,8BAAmD,CACnD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAmD,CACnD,oCAAuD,CACvD,6BAAkD,CAIlD,+CAAwD,CACxD,qEAA+E,CAC/E,qCAAwD,CACxD,sDAA8D,CAC9D,iDAAyD,CACzD,yCAAqD,CACrD,uCAAsD,CACtD,6CAA0D,CAC1D,uCAAsD,CAItD,gDAAuD,CACvD,kDAA+D,CAC/D,mDAAgE,CAChE,+CAA6D,CAC7D,yDAA8D,CAE9D,uCAAuD,CACvD,6CAA4D,CAC5D,8CAA4D,CAC5D,0CAAyD,CACzD,gDAA8D,CAE9D,+DAAsE,CACtE,iDAAkE,CAClE,kDAAkE,CAClE,8CAA+D,CAC/D,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA4D,CAC5D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAmE,CACnE,yEAA8E,CAC9E,qDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,+BAAiD,CACjD,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,wCAAwD,CACxD,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,gEAAuE,CACvE,4EAAiF,CACjF,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,wDAAmE,CACnE,mDAAgE,CCpGhE,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJoGD,CI9FA,iDAIC,QAAS,CACT,SAAU,CACV,QAAS,CACT,sBAAuB,CACvB,oBAAqB,CACrB,qBAAsB,CACtB,eAAgB,CAGhB,oBACD,CAKA,oCAGC,wBAAyB,CACzB,iGAAkG,CAClG,0BAA2B,CAC3B,eAAgB,CAChB,kBAAmB,CACnB,WAAY,CACZ,UACD,CAGC,2BACC,gBACD,CAEA,wBAEC,sBACD,CAEA,0BACC,oBACD,CAEA,kGAGC,WACD,CAEA,gIAGC,cACD,CAEA,0BACC,YAAa,CACb,yBACD,CAEA,0CAEC,SAAU,CACV,QACD,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck.ck-reset_all * {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n\ttransition: none !important;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(0, 0%, 77%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 44%, 48%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(208, 88%, 52%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(208, 88%, 47%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t208, 79%, 51%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(207, 89%, 86%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 90%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 85%);\n\t--ck-color-button-default-active-shadow: \t\t\t\t\thsl(0, 0%, 75%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(0, 0%, 87%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(0, 0%, 77%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(0, 0%, 73%);\n\t--ck-color-button-on-active-shadow: \t\t\t\t\t\thsl(0, 0%, 63%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(0, 0%, 87%);\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 44%, 43%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 44%, 41%);\n\t--ck-color-button-action-active-shadow: \t\t\t\t\thsl(104, 44%, 36%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 69%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 64%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 44%, 43%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\thsl(0, 0%, 78%);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\thsl(0, 0%, 78%);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 46%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-base-active);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-base-active-focus);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-foreground);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n',
              "/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n",
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck.ck-reset_all * {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck.ck-reset_all * {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck.ck-reset_all {\n\t& .ck-rtl * {\n\t\ttext-align: right;\n\t}\n\n\t& iframe {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea,\n\t& input[type="text"],\n\t& input[type="password"] {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled],\n\t& input[type="text"][disabled],\n\t& input[type="password"][disabled] {\n\t\tcursor: default;\n\t}\n\n\t& fieldset {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n',
              "/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n",
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{width:var(--ck-icon-size);height:var(--ck-icon-size);font-size:.8333350694em;will-change:transform}.ck.ck-icon,.ck.ck-icon *{color:inherit;cursor:inherit}.ck.ck-icon :not([fill]){fill:currentColor}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css',
            ],
            names: [],
            mappings:
              'AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YACC,yBAA0B,CAC1B,0BAA2B,CAG3B,uBAAwB,CAQxB,qBAcD,CAZC,0BARA,aAAc,CAGd,cAgBA,CAJC,yBAEC,iBACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\tcolor: inherit;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\n\t\t/* Allows dynamic coloring of the icons. */\n\t\tcolor: inherit;\n\n\t\t&:not([fill]) {\n\t\t\t/* Needed by FF. */\n\t\t\tfill: currentColor;\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-tooltip,.ck.ck-tooltip .ck-tooltip__text:after{position:absolute;pointer-events:none;-webkit-backface-visibility:hidden}.ck.ck-tooltip{visibility:hidden;opacity:0;display:none;z-index:var(--ck-z-modal)}.ck.ck-tooltip .ck-tooltip__text{display:inline-block}.ck.ck-tooltip .ck-tooltip__text:after{content:"";width:0;height:0}:root{--ck-tooltip-arrow-size:5px}.ck.ck-tooltip{left:50%;top:0;transition:opacity .2s ease-in-out .2s}.ck.ck-tooltip .ck-tooltip__text{border-radius:0}.ck-rounded-corners .ck.ck-tooltip .ck-tooltip__text,.ck.ck-tooltip .ck-tooltip__text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-tooltip .ck-tooltip__text{font-size:.9em;line-height:1.5;color:var(--ck-color-tooltip-text);padding:var(--ck-spacing-small) var(--ck-spacing-medium);background:var(--ck-color-tooltip-background);position:relative;left:-50%}.ck.ck-tooltip .ck-tooltip__text:after{transition:opacity .2s ease-in-out .2s;border-style:solid;left:50%}.ck.ck-tooltip.ck-tooltip_s,.ck.ck-tooltip.ck-tooltip_se,.ck.ck-tooltip.ck-tooltip_sw{bottom:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateY(100%)}.ck.ck-tooltip.ck-tooltip_s .ck-tooltip__text:after,.ck.ck-tooltip.ck-tooltip_se .ck-tooltip__text:after,.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text:after{top:calc(var(--ck-tooltip-arrow-size)*-1 + 1px);transform:translateX(-50%);border-left-color:transparent;border-bottom-color:var(--ck-color-tooltip-background);border-right-color:transparent;border-top-color:transparent;border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:var(--ck-tooltip-arrow-size);border-top-width:0}.ck.ck-tooltip.ck-tooltip_sw{right:50%;left:auto}.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text{left:auto;right:calc(var(--ck-tooltip-arrow-size)*-2)}.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text:after{left:auto;right:0}.ck.ck-tooltip.ck-tooltip_se{left:50%;right:auto}.ck.ck-tooltip.ck-tooltip_se .ck-tooltip__text{right:auto;left:calc(var(--ck-tooltip-arrow-size)*-2)}.ck.ck-tooltip.ck-tooltip_se .ck-tooltip__text:after{right:auto;left:0;transform:translateX(50%)}.ck.ck-tooltip.ck-tooltip_n{top:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateY(-100%)}.ck.ck-tooltip.ck-tooltip_n .ck-tooltip__text:after{bottom:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateX(-50%);border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;border-top-color:var(--ck-color-tooltip-background);border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:0;border-right-width:var(--ck-tooltip-arrow-size);border-top-width:var(--ck-tooltip-arrow-size)}.ck.ck-tooltip.ck-tooltip_e{left:calc(100% + var(--ck-tooltip-arrow-size));top:50%}.ck.ck-tooltip.ck-tooltip_e .ck-tooltip__text{left:0;transform:translateY(-50%)}.ck.ck-tooltip.ck-tooltip_e .ck-tooltip__text:after{left:calc(var(--ck-tooltip-arrow-size)*-1);top:calc(50% - var(--ck-tooltip-arrow-size)*1);border-left-color:transparent;border-bottom-color:transparent;border-right-color:var(--ck-color-tooltip-background);border-top-color:transparent;border-left-width:0;border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:var(--ck-tooltip-arrow-size);border-top-width:var(--ck-tooltip-arrow-size)}.ck.ck-tooltip.ck-tooltip_w{right:calc(100% + var(--ck-tooltip-arrow-size));left:auto;top:50%}.ck.ck-tooltip.ck-tooltip_w .ck-tooltip__text{left:0;transform:translateY(-50%)}.ck.ck-tooltip.ck-tooltip_w .ck-tooltip__text:after{left:100%;top:calc(50% - var(--ck-tooltip-arrow-size)*1);border-left-color:var(--ck-color-tooltip-background);border-bottom-color:transparent;border-right-color:transparent;border-top-color:transparent;border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:0;border-top-width:var(--ck-tooltip-arrow-size)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAKA,sDAEC,iBAAkB,CAGlB,mBAAoB,CAIpB,kCACD,CAEA,eAEC,iBAAkB,CAClB,SAAU,CACV,YAAa,CACb,yBAWD,CATC,iCACC,oBAOD,CALC,uCACC,UAAW,CACX,OAAQ,CACR,QACD,CCxBF,MACC,2BACD,CAEA,eACC,QAAS,CAMT,KAAM,CAON,sCAwKD,CAtKC,iCChBA,eDqCA,CArBA,yGCZC,qCDiCD,CArBA,iCAGC,cAAe,CACf,eAAgB,CAChB,kCAAmC,CACnC,wDAAyD,CACzD,6CAA8C,CAC9C,iBAAkB,CAClB,SAYD,CAVC,uCAMC,sCAAuC,CACvC,kBAAmB,CACnB,QACD,CAYD,sFAGC,4CAA+C,CAC/C,0BASD,CAPC,8JAEC,+CAAkD,CAClD,0BAA6B,CAC7B,6BAAoF,CAApF,sDAAoF,CAApF,8BAAoF,CAApF,4BAAoF,CACpF,8CAAsG,CAAtG,gDAAsG,CAAtG,+CAAsG,CAAtG,kBACD,CAaD,6BACC,SAAU,CACV,SAWD,CATC,+CACC,SAAU,CACV,2CACD,CAEA,qDACC,SAAU,CACV,OACD,CAYD,6BACC,QAAS,CACT,UAYD,CAVC,+CACC,UAAW,CACX,0CACD,CAEA,qDACC,UAAW,CACX,MAAO,CACP,yBACD,CAYD,4BACC,yCAA4C,CAC5C,2BAQD,CANC,oDACC,4CAA+C,CAC/C,0BAA6B,CAC7B,6BAAoF,CAApF,+BAAoF,CAApF,8BAAoF,CAApF,mDAAoF,CACpF,8CAAsG,CAAtG,qBAAsG,CAAtG,+CAAsG,CAAtG,6CACD,CAUD,4BACC,8CAA+C,CAC/C,OAaD,CAXC,8CACC,MAAO,CACP,0BAQD,CANC,oDACC,0CAA6C,CAC7C,8CAAiD,CACjD,6BAAoF,CAApF,+BAAoF,CAApF,qDAAoF,CAApF,4BAAoF,CACpF,mBAAsG,CAAtG,gDAAsG,CAAtG,+CAAsG,CAAtG,6CACD,CAWF,4BACC,+CAAgD,CAChD,SAAU,CACV,OAaD,CAXC,8CACC,MAAO,CACP,0BAQD,CANC,oDACC,SAAU,CACV,8CAAiD,CACjD,oDAAoF,CAApF,+BAAoF,CAApF,8BAAoF,CAApF,4BAAoF,CACpF,8CAAsG,CAAtG,gDAAsG,CAAtG,oBAAsG,CAAtG,6CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-tooltip,\n.ck.ck-tooltip .ck-tooltip__text::after {\n\tposition: absolute;\n\n\t/* Without this, hovering the tooltip could keep it visible. */\n\tpointer-events: none;\n\n\t/* This is to get rid of flickering when transitioning opacity in Chrome.\n\tIt\'s weird but it works. */\n\t-webkit-backface-visibility: hidden;\n}\n\n.ck.ck-tooltip {\n\t/* Tooltip is hidden by default. */\n\tvisibility: hidden;\n\topacity: 0;\n\tdisplay: none;\n\tz-index: var(--ck-z-modal);\n\n\t& .ck-tooltip__text {\n\t\tdisplay: inline-block;\n\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-tooltip-arrow-size: 5px;\n}\n\n.ck.ck-tooltip {\n\tleft: 50%;\n\n\t/*\n\t * Prevent blurry tooltips in LoDPI environments.\n\t * See https://github.com/ckeditor/ckeditor5/issues/1802.\n\t */\n\ttop: 0;\n\n\t/*\n\t * For the transition to work, the tooltip must be controlled\n\t * using visibility+opacity. A delay prevents a "tooltip avalanche"\n\t * i.e. when scanning the toolbar with mouse cursor.\n\t */\n\ttransition: opacity .2s ease-in-out .2s;\n\n\t& .ck-tooltip__text {\n\t\t@mixin ck-rounded-corners;\n\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t\tpadding: var(--ck-spacing-small) var(--ck-spacing-medium);\n\t\tbackground: var(--ck-color-tooltip-background);\n\t\tposition: relative;\n\t\tleft: -50%;\n\n\t\t&::after {\n\t\t\t/*\n\t\t\t * For the transition to work, the tooltip must be controlled\n\t\t\t * using visibility+opacity. A delay prevents a "tooltip avalanche"\n\t\t\t * i.e. when scanning the toolbar with mouse cursor.\n\t\t\t */\n\t\t\ttransition: opacity .2s ease-in-out .2s;\n\t\t\tborder-style: solid;\n\t\t\tleft: 50%;\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip south of the element.\n\t *\n\t *       [element]\n\t *           ^\n\t *     +-----------+\n\t *     |  Tooltip  |\n\t *     +-----------+\n\t */\n\t&.ck-tooltip_s,\n\t&.ck-tooltip_sw,\n\t&.ck-tooltip_se {\n\t\tbottom: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\ttransform: translateY( 100% );\n\n\t\t& .ck-tooltip__text::after {\n\t\t\t/* 1px addresses gliches in rendering causing gap between the triangle and the text */\n\t\t\ttop: calc(-1 * var(--ck-tooltip-arrow-size) + 1px);\n\t\t\ttransform: translateX( -50% );\n\t\t\tborder-color: transparent transparent var(--ck-color-tooltip-background) transparent;\n\t\t\tborder-width: 0 var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size);\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip south-west of the element.\n\t *\n\t *        [element]\n\t *            ^\n\t *  +-----------+\n\t *  |  Tooltip  |\n\t *  +-----------+\n\t */\n\n\t&.ck-tooltip_sw {\n\t\tright: 50%;\n\t\tleft: auto;\n\n\t\t& .ck-tooltip__text {\n\t\t\tleft: auto;\n\t\t\tright: calc( -2 * var(--ck-tooltip-arrow-size));\n\t\t}\n\n\t\t& .ck-tooltip__text::after {\n\t\t\tleft: auto;\n\t\t\tright: 0;\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip south-east of the element.\n\t *\n\t *  [element]\n\t *      ^\n\t *    +-----------+\n\t *    |  Tooltip  |\n\t *    +-----------+\n\t */\n\t&.ck-tooltip_se {\n\t\tleft: 50%;\n\t\tright: auto;\n\n\t\t& .ck-tooltip__text {\n\t\t\tright: auto;\n\t\t\tleft: calc( -2 * var(--ck-tooltip-arrow-size));\n\t\t}\n\n\t\t& .ck-tooltip__text::after {\n\t\t\tright: auto;\n\t\t\tleft: 0;\n\t\t\ttransform: translateX( 50% );\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip north of the element.\n\t *\n\t *     +-----------+\n\t *     |  Tooltip  |\n\t *     +-----------+\n\t *           V\n\t *       [element]\n\t */\n\t&.ck-tooltip_n {\n\t\ttop: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\ttransform: translateY( -100% );\n\n\t\t& .ck-tooltip__text::after {\n\t\t\tbottom: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\t\ttransform: translateX( -50% );\n\t\t\tborder-color: var(--ck-color-tooltip-background) transparent transparent transparent;\n\t\t\tborder-width: var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) 0 var(--ck-tooltip-arrow-size);\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip east of the element.\n\t *\n\t *                +----------+\n\t *    [element] < |   east   |\n\t *                +----------+\n\t */\n\t&.ck-tooltip_e {\n\t\tleft: calc(100% + var(--ck-tooltip-arrow-size));\n\t\ttop: 50%;\n\n\t\t& .ck-tooltip__text {\n\t\t\tleft: 0;\n\t\t\ttransform: translateY( -50% );\n\n\t\t\t&::after {\n\t\t\t\tleft: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\t\t\ttop: calc(50% - 1 * var(--ck-tooltip-arrow-size));\n\t\t\t\tborder-color: transparent var(--ck-color-tooltip-background) transparent transparent;\n\t\t\t\tborder-width: var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip west of the element.\n\t *\n\t *    +----------+\n\t *    |   west   | > [element]\n\t *    +----------+\n\t */\n\t&.ck-tooltip_w {\n\t\tright: calc(100% + var(--ck-tooltip-arrow-size));\n\t\tleft: auto;\n\t\ttop: 50%;\n\n\t\t& .ck-tooltip__text {\n\t\t\tleft: 0;\n\t\t\ttransform: translateY( -50% );\n\n\t\t\t&::after {\n\t\t\t\tleft: 100%;\n\t\t\t\ttop: calc(50% - 1 * var(--ck-tooltip-arrow-size));\n\t\t\t\tborder-color: transparent transparent transparent var(--ck-color-tooltip-background);\n\t\t\t\tborder-width: var(--ck-tooltip-arrow-size) 0 var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size);\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-button,a.ck.ck-button{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:block}@media (hover:none){.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:none}}.ck.ck-button,a.ck.ck-button{position:relative;display:inline-flex;align-items:center;justify-content:left}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button:hover .ck-tooltip,a.ck.ck-button:hover .ck-tooltip{visibility:visible;opacity:1}.ck.ck-button:focus:not(:hover) .ck-tooltip,a.ck.ck-button:focus:not(:hover) .ck-tooltip{display:none}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-default-active-shadow)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{white-space:nowrap;cursor:default;vertical-align:middle;padding:var(--ck-spacing-tiny);text-align:center;min-width:var(--ck-ui-component-min-height);min-height:var(--ck-ui-component-min-height);line-height:1;font-size:inherit;border:1px solid transparent;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;-webkit-appearance:none}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{font-size:inherit;font-weight:inherit;color:inherit;cursor:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__icon{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-right:calc(var(--ck-spacing-small)*-1);margin-left:var(--ck-spacing-small)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-on-active-shadow)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-action-active-shadow)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css',
            ],
            names: [],
            mappings:
              'AAQA,6BCCC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6BD,CE/BC,qDACC,aAqBD,CAHC,oBAnBD,qDAoBE,YAEF,CADC,CFvBF,6BAKC,iBAAkB,CAClB,mBAAoB,CACpB,kBAAmB,CACnB,oBAyBD,CAvBC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEkBA,iEACC,kBAAmB,CACnB,SACD,CAbA,yFACC,YACD,CC7BD,6BCAC,oDD0ID,CCvIE,6EACC,0DACD,CAEA,+EACC,2DAA4C,CAC5C,uEACD,CAID,qDACC,6DACD,CDhBD,6BEDC,eF2ID,CA1IA,wIEGE,qCFuIF,CA1IA,6BAKC,kBAAmB,CACnB,cAAe,CACf,qBAAsB,CACtB,8BAA+B,CAC/B,iBAAkB,CAGlB,2CAA4C,CAC5C,4CAA6C,CAI7C,aAAc,CAGd,iBAAkB,CAGlB,4BAA6B,CAG7B,4DAA8D,CAG9D,uBA6GD,CA3GC,oFGjCA,YAAa,CACb,2BAA2B,CCF3B,2CJsCA,CAIC,kJAEC,aACD,CAGD,iEAEC,iBAAkB,CAClB,mBAAoB,CACpB,aAAc,CACd,cAAe,CAIf,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAEA,uFK3FD,kCL6FC,CAGA,yFKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAOE,6CAAgD,CAChD,mCAEF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDiIA,CC9HC,yFACC,qDACD,CAEA,2FACC,sDAA4C,CAC5C,kEACD,CAID,iEACC,wDACD,CDmHA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC7IC,mDDkJD,CC/IE,2FACC,yDACD,CAEA,6FACC,0DAA4C,CAC5C,sEACD,CAID,mEACC,4DACD,CD6HD,2CAIC,wCACD,CAEA,uCAEC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n@import "../tooltip/mixins/_tooltip.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\t@mixin ck-tooltip_enabled;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\tjustify-content: left;\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n\n\t&:hover {\n\t\t@mixin ck-tooltip_visible;\n\t}\n\n\t/* Get rid of the native focus outline around the tooltip when focused (but not :hover). */\n\t&:focus:not(:hover) {\n\t\t@mixin ck-tooltip_disabled;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n',
              "/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n",
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t\tbox-shadow: inset 0 2px 2px var($(prefix)-active-shadow);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:1.0769230769em;--ck-switch-button-toggle-spacing:1px;--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - var(--ck-switch-button-toggle-spacing)*2)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{transition:background .4s ease;width:var(--ck-switch-button-toggle-width);background:var(--ck-color-switch-button-off-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*0.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{margin:var(--ck-switch-button-toggle-spacing);width:var(--ck-switch-button-toggle-inner-size);height:var(--ck-switch-button-toggle-inner-size);background:var(--ck-color-switch-button-inner-background);transition:all .3s ease}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var(--ck-switch-button-translation))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var(--ck-switch-button-translation)*-1))}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css',
            ],
            names: [],
            mappings:
              'AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,mDAAoD,CACpD,qCAAsC,CACtC,gKAKD,CAGC,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDC3BA,eDoEA,CAzCA,yICvBC,qCDgED,CAzCA,2DAKE,gBAoCF,CAzCA,2DAUE,iBA+BF,CAzCA,iDAcC,8BAAiC,CAEjC,0CAA2C,CAC3C,uDAwBD,CAtBC,2EC9CD,eD2DC,CAbA,6LC1CA,qCAAsC,CD4CpC,+CAWF,CAbA,2EAMC,6CAA8C,CAC9C,+CAAgD,CAChD,gDAAiD,CACjD,yDAA0D,CAG1D,uBACD,CAEA,uDACC,6DAKD,CAHC,iFACC,+DACD,CAIF,6DExEA,kCF0EA,CAEA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,yDAMF,CAXA,2FASE,kEAEF',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floating–point numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: 1.0769230769em;\n\t--ck-switch-button-toggle-spacing: 1px;\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2 * var(--ck-switch-button-toggle-spacing)\n\t);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease;\n\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\t/* Leave some tiny bit of space around the inner part of the switch */\n\t\t\tmargin: var(--ck-switch-button-toggle-spacing);\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t&.ck-on .ck-button__toggle {\n\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t}\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t/*\n\t\t\t * Move the toggle switch to the right. It will be animated.\n\t\t\t */\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#000}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{width:var(--ck-color-grid-tile-size);height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;border:0}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{display:none;color:var(--ck-color-color-grid-check-icon)}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css',
            ],
            names: [],
            mappings:
              'AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,qCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBACC,oCAAqC,CACrC,qCAAsC,CACtC,wCAAyC,CACzC,yCAA0C,CAC1C,SAAU,CACV,8BAA+B,CAC/B,QAmCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCACC,YAAa,CACb,2CACD,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n\tdisplay: grid;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-grid-tile-size: 24px;\n\n\t/* Not using global colors here because these may change but some colors in a pallette\n\t * require special treatment. For instance, this ensures no matter what the UI text color is,\n\t * the check icon will look good on the black color tile. */\n\t--ck-color-color-grid-check-icon: hsl(0, 0%, 0%);\n}\n\n.ck.ck-color-grid {\n\tgrid-gap: 5px;\n\tpadding: 8px;\n}\n\n.ck.ck-color-grid__tile {\n\twidth: var(--ck-color-grid-tile-size);\n\theight: var(--ck-color-grid-tile-size);\n\tmin-width: var(--ck-color-grid-tile-size);\n\tmin-height: var(--ck-color-grid-tile-size);\n\tpadding: 0;\n\ttransition: .2s ease box-shadow;\n\tborder: 0;\n\n\t&.ck-disabled {\n\t\tcursor: unset;\n\t\ttransition: unset;\n\t}\n\n\t&.ck-color-table__color-tile_bordered {\n\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\tdisplay: none;\n\t\tcolor: var(--ck-color-color-grid-check-icon);\n\t}\n\n\t&.ck-on {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\n\n\t\t& .ck.ck-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t&.ck-on,\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\t/* Disable the default .ck-button\'s border ring. */\n\t\tborder: 0;\n\t}\n\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t}\n}\n\n.ck.ck-color-grid__label {\n\tpadding: 0 var(--ck-spacing-standard);\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button .ck-tooltip{display:none}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__action{border-top-right-radius:unset;border-bottom-right-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__action{border-top-left-radius:unset;border-bottom-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-radius:0}.ck-rounded-corners [dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow,[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:unset;border-bottom-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-top-right-radius:unset;border-bottom-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled){border-left-color:var(--ck-color-split-button-hover-border)}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled){border-right-color:var(--ck-color-split-button-hover-border)}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAOA,mBAEC,iBAUD,CARC,iDACC,qCACD,CC0BA,8DACC,YACD,CClCD,MACC,gDAAyD,CACzD,4CACD,CAMC,qDAGE,6BAA8B,CAC9B,gCAQF,CAZA,qDASE,4BAA6B,CAC7B,+BAEF,CAEA,0CAGC,eAmBD,CAtBA,oDCnBA,eDyCA,CAtBA,+ICfC,qCAAsC,CDuBpC,4BAA6B,CAC7B,+BAaH,CAtBA,oDAeE,6BAA8B,CAC9B,gCAMF,CAHC,8CACC,mCACD,CASA,0KACC,wDACD,CAGC,sKACC,2DACD,CAIA,sKACC,4DACD,CAMF,uCCpEA,eD8EA,CAVA,qHChEC,qCD0ED,CARE,qKACC,2BACD,CAEA,mKACC,4BACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../tooltip/mixins/_tooltip.css";\n\n.ck.ck-splitbutton {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-splitbutton__action:focus {\n\t\tz-index: calc(var(--ck-z-default) + 1);\n\t}\n\n\t/* Disable tooltips for the buttons when the button is "open" */\n\t&.ck-splitbutton_open > .ck-button {\n\t\t@mixin ck-tooltip_disabled;\n\t}\n}\n\n',
              "/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n",
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\n\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\n}\n\n.ck.ck-splitbutton {\n\t/*\n\t * Note: ck-rounded and ck-dir mixins don\'t go together (because they both use @nest).\n\t */\n\t& > .ck-splitbutton__action {\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the action button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the action button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\t}\n\n\t& > .ck-splitbutton__arrow {\n\t\t/* It\'s a text-less button and since the icon is positioned absolutely in such situation,\n\t\tit must get some arbitrary min-width. */\n\t\tmin-width: unset;\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the arrow button on the left side */\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: unset;\n\t\t\t\tborder-bottom-left-radius: unset;\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the arrow button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t& svg {\n\t\t\twidth: var(--ck-dropdown-arrow-size);\n\t\t}\n\t}\n\n\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\n\tas a whole. The background of both buttons should stand out and there should be a visual\n\tseparation between both buttons. */\n\t&.ck-splitbutton_open,\n\t&:hover {\n\t\t/* When the split button hovered as a whole, not as individual buttons. */\n\t\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\n\t\t\tbackground: var(--ck-color-split-button-hover-background);\n\t\t}\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled) {\n\t\t\t\tborder-left-color: var(--ck-color-split-button-hover-border);\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled) {\n\t\t\t\tborder-right-color: var(--ck-color-split-button-hover-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Don\'t round the bottom left and right corners of the buttons when "open"\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-splitbutton_open {\n\t\t@mixin ck-rounded-corners {\n\t\t\t& > .ck-splitbutton__action {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\n\t\t\t& > .ck-splitbutton__arrow {\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          ':root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on .ck-tooltip{display:none}.ck.ck-dropdown .ck-dropdown__panel{-webkit-backface-visibility:hidden;display:none;z-index:var(--ck-z-modal);max-width:var(--ck-dropdown-max-width);position:absolute}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{top:100%;bottom:auto}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{width:7em;overflow:hidden;text-overflow:ellipsis}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{box-shadow:var(--ck-drop-shadow),0 0;background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAOA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBAqFD,CAnFC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UAOD,CCUA,iEACC,YACD,CDVA,oCAGC,kCAAmC,CAEnC,YAAa,CACb,yBAA0B,CAC1B,sCAAuC,CAEvC,iBAyDD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSASC,QAAS,CACT,WACD,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CEhGA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CACC,gCAAiC,CAGjC,sCACD,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEACC,SAAU,CACV,eAAgB,CAChB,sBACD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eH8GD,CA5BA,qFG9EE,qCH0GF,CA5BA,uBEpFC,oCAA8B,CFwF9B,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CAGT,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../tooltip/mixins/_tooltip.css";\n\n:root {\n\t--ck-dropdown-max-width: 75vw;\n}\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\n\t\t/* Disable main button\'s tooltip when the dropdown is open. Otherwise the panel may\n\t\tpartially cover the tooltip */\n\t\t&.ck-on {\n\t\t\t@mixin ck-tooltip_disabled;\n\t\t}\n\t}\n\n\t& .ck-dropdown__panel {\n\t\t/* This is to get rid of flickering when the tooltip is shown under the panel,\n\t\twhich looks like the panel moves vertically a pixel down and up. */\n\t\t-webkit-backface-visibility: hidden;\n\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\t\tmax-width: var(--ck-dropdown-max-width);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_n,\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_nme {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw,\n\t\t&.ck-dropdown__panel_smw,\n\t\t&.ck-dropdown__panel_sme,\n\t\t&.ck-dropdown__panel_s {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_s,\n\t\t&.ck-dropdown__panel_n {\n\t\t\t/* Positioning panels relative to the center of the button */\n\t\t\tleft: 50%;\n\t\t\ttransform: translateX(-50%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_smw {\n\t\t\t/* Positioning panels relative to the middle-west of the button */\n\t\t\tleft: 75%;\n\t\t\ttransform: translateX(-75%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nme,\n\t\t&.ck-dropdown__panel_sme {\n\t\t\t/* Positioning panels relative to the middle-east of the button */\n\t\t\tleft: 25%;\n\t\t\ttransform: translateX(-25%);\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor\'s content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n',
              "/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n",
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/8699 */\n\t\t&.ck-off:active,\n\t\t&.ck-on:active {\n\t\t\tbox-shadow: none;\n\t\t\t\n\t\t\t&:focus {\n\t\t\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-toolbar{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-flow:row nowrap;align-items:center}.ck.ck-toolbar>.ck-toolbar__items{display:flex;flex-flow:row wrap;align-items:center;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);padding:0 var(--ck-spacing-small);border:1px solid var(--ck-color-toolbar-border)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;width:1px;min-width:1px;background:var(--ck-color-toolbar-border);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{width:100%;margin:0;border-radius:0;border:0}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-right:var(--ck-spacing-small)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAOA,eCEC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBAAgB,CDFhB,YAAa,CACb,oBAAqB,CACrB,kBA6CD,CA3CC,kCACC,YAAa,CACb,kBAAmB,CACnB,kBAAmB,CACnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eD0FD,CA7FA,qECOE,qCDsFF,CA7FA,eAGC,6CAA8C,CAC9C,iCAAkC,CAClC,+CAwFD,CAtFC,yCACC,kBAAmB,CACnB,SAAU,CACV,aAAc,CACd,yCAA0C,CAM1C,kCAAmC,CACnC,qCACD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAGC,kCAAmC,CACnC,qCACD,CAEA,mCAEC,SAgBD,CAbC,0DAEC,UAAW,CAGX,QAAS,CAGT,eAAgB,CAGhB,QACD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAvFF,qCA2FE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JACC,wBAAyB,CACzB,2BACD,CAGA,2JACC,yBAA0B,CAC1B,4BACD,CAID,qGACC,mCACD,CAGA,yLACC,mCACD,CAWA,qHACC,cACD,CAIC,6JACC,yBAA0B,CAC1B,4BACD,CAGA,2JACC,wBAAyB,CACzB,2BACD,CAID,qGACC,oCACD,CAGA,yLACC,oCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\tflex-basis: 100%;\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\theight: 0;\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > *:not(.ck-toolbar__line-break) {\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so any border is pointless. */\n\t\t\tborder: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-list{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{list-style-type:none;background:var(--ck-color-list-background)}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{min-height:unset;width:100%;text-align:left;border-radius:0;padding:calc(var(--ck-line-height-base)*0.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*0.4*var(--ck-font-size-base))}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{height:1px;width:100%;background:var(--ck-color-base-border)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAOA,YCEC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBAAgB,CDFhB,YAAa,CACb,qBAcD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAGC,oBAAqB,CACrB,0CACD,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BACC,gBAAiB,CACjB,UAAW,CACX,eAAgB,CAChB,eAAgB,CAKhB,mIAiCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,2DACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBACC,UAAW,CACX,UAAW,CACX,sCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\ttext-align: left;\n\t\tborder-radius: 0;\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          ':root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{width:max-content;max-width:var(--ck-toolbar-dropdown-max-width)}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css',
            ],
            names: [],
            mappings: 'AAKA,MACC,oCACD,CAEA,4CAEC,iBAAkB,CAClB,8CAOD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n\t/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n\twidth: max-content;\n\tmax-width: var(--ck-toolbar-dropdown-max-width);\n\n\t& .ck-button {\n\t\t&:focus {\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDIpC,wBAAyB,CACzB,2BAA4B,CAC5B,4BAEF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          ':root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-focused{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0}.ck.ck-editor__editable_inline{overflow:auto;padding:0 var(--ck-spacing-standard);border:1px solid transparent}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEERA,YAAa,CACb,2BAA2B,CCF3B,qCHYA,CAGD,+BACC,aAAc,CACd,oCAAqC,CACrC,4BAwBD,CAtBC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CACC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-base-foreground);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-base-foreground);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css',
            ],
            names: [],
            mappings: 'AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-form__header{display:flex;flex-direction:row;flex-wrap:nowrap;align-items:center;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{padding:var(--ck-spacing-small) var(--ck-spacing-large);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);border-bottom:1px solid var(--ck-color-base-border)}.ck.ck-form__header .ck-form__header__label{font-weight:700}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css',
            ],
            names: [],
            mappings:
              'AAKA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,kBAAmB,CACnB,6BACD,CCNA,MACC,4BACD,CAEA,oBACC,uDAAwD,CACxD,mCAAoC,CACpC,wCAAyC,CACzC,mDAKD,CAHC,4CACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\talign-items: center;\n\tjustify-content: space-between;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\theight: var(--ck-form-header-height);\n\tline-height: var(--ck-form-header-height);\n\tborder-bottom: 1px solid var(--ck-color-base-border);\n\n\t& .ck-form__header__label {\n\t\tfont-weight: bold;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          ':root{--ck-input-text-width:18em}.ck.ck-input-text{border-radius:0}.ck-rounded-corners .ck.ck-input-text,.ck.ck-input-text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-text{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);min-width:var(--ck-input-text-width);min-height:var(--ck-ui-component-min-height);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input-text:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-input-text[readonly]{border:1px solid var(--ck-color-input-disabled-border);background:var(--ck-color-input-disabled-background);color:var(--ck-color-input-disabled-text)}.ck.ck-input-text[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input-text.ck-error{border-color:var(--ck-color-input-error-border);animation:ck-text-input-shake .3s ease both}.ck.ck-input-text.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-text-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/inputtext/inputtext.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AASA,MACC,0BACD,CAEA,kBCFC,eDwCD,CAtCA,2ECEE,qCDoCF,CAtCA,kBAGC,2CAA4C,CAC5C,6CAA8C,CAC9C,6DAA8D,CAC9D,oCAAqC,CAGrC,4CAA6C,CAG7C,4DA0BD,CAxBC,wBEjBA,YAAa,CACb,2BAA2B,CCF3B,2CHqBA,CAEA,4BACC,sDAAuD,CACvD,oDAAqD,CACrD,yCAMD,CAJC,kCG5BD,oDH+BC,CAGD,2BACC,+CAAgD,CAChD,2CAKD,CAHC,iCGtCD,iDHwCC,CAIF,+BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-text-width: 18em;\n}\n\n.ck.ck-input-text {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-text-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-text-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-text-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{pointer-events:none;transform-origin:0 0;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);background:var(--ck-color-labeled-field-label-background);padding:0 calc(var(--ck-font-size-tiny)*0.5);line-height:normal;font-weight:400;text-overflow:ellipsis;overflow:hidden;max-width:100%;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-spacing-medium),calc(var(--ck-font-size-base)*0.6)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-spacing-medium)*-1),calc(var(--ck-font-size-base)*0.6)) scale(1)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));background:transparent;padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,yEACD,CAEA,0BCHC,eD4GD,CAzGA,2FCCE,qCDwGF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAWC,mBAAoB,CACpB,oBAAqB,CAGrB,6DAA+D,CAE/D,yDAA0D,CAC1D,4CAA8C,CAC9C,kBAAoB,CACpB,eAAmB,CAGnB,sBAAuB,CACvB,eAAgB,CAEhB,cAAe,CAEf,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,wSAGE,yFAYF,CAfA,wSAOE,kGAQF,CAfA,oRAWC,iEAAkE,CAElE,sBAAuB,CACvB,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\tdisplay: flex;\n\t\tposition: relative;\n\t}\n\n\t& .ck.ck-label {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);\n\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);\n\t--ck-color-labeled-field-label-background: var(--ck-color-base-background);\n}\n\n.ck.ck-labeled-field-view {\n\t@mixin ck-rounded-corners;\n\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\twidth: 100%;\n\n\t\t& > .ck.ck-label {\n\t\t\ttop: 0px;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: 0px;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: 0px;\n\t\t\t}\n\n\t\t\tpointer-events: none;\n\t\t\ttransform-origin: 0 0;\n\n\t\t\t/* By default, display the label scaled down above the field. */\n\t\t\ttransform: translate(var(--ck-spacing-medium), -6px) scale(.75);\n\n\t\t\tbackground: var(--ck-color-labeled-field-label-background);\n\t\t\tpadding: 0 calc(.5 * var(--ck-font-size-tiny));\n\t\t\tline-height: initial;\n\t\t\tfont-weight: normal;\n\n\t\t\t/* Prevent overflow when the label is longer than the input */\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\n\t\t\tmax-width: 100%;\n\n\t\t\ttransition:\n\t\t\t\ttransform var(--ck-labeled-field-view-transition),\n\t\t\t\tpadding var(--ck-labeled-field-view-transition),\n\t\t\t\tbackground var(--ck-labeled-field-view-transition);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\t& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\n\t\t& .ck-input:not([readonly]) + .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t& .ck-labeled-field-view__status {\n\t\tfont-size: var(--ck-font-size-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\n\t\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\t\tThe status could be very long. */\n\t\twhite-space: normal;\n\n\t\t&.ck-labeled-field-view__status_error {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t/* Disabled fields and fields that have no focus should fade out. */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\tcolor: var(--ck-color-input-disabled-text);\n\t}\n\n\t/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t@mixin ck-dir ltr {\n\t\t\ttransform: translate(var(--ck-spacing-medium), calc(0.6 * var(--ck-font-size-base))) scale(1);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttransform: translate(calc(-1 * var(--ck-spacing-medium)), calc(0.6 * var(--ck-font-size-base))) scale(1);\n\t\t}\n\n\t\t/* Compensate for the default translate position. */\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));\n\n\t\tbackground: transparent;\n\t\tpadding: 0;\n\t}\n\n\t/*------ DropdownView integration ----------------------------------------------------------------------------------- */\n\n\t/* Make sure dropdown\' background color in any of dropdown\'s state does not collide with labeled field. */\n\t& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {\n\t\tbackground: transparent;\n\t}\n\n\t/* When the dropdown is "empty", the labeled field label replaces its label. */\n\t&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {\n\t\topacity: 0;\n\t}\n\n\t/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{width:0;height:0;border-style:solid}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:var(--ck-balloon-arrow-height);border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:0}.ck.ck-balloon-panel[class*=arrow_n]:before{border-bottom-color:var(--ck-color-panel-border)}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-color:transparent;border-right-color:transparent;border-top-color:transparent}.ck.ck-balloon-panel[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background);margin-top:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:0;border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-top-color:var(--ck-color-panel-border);filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent}.ck.ck-balloon-panel[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background);margin-bottom:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{right:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{right:25%;margin-right:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{right:25%;margin-right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCJC,eD4ID,CAxIA,iFCAE,qCDwIF,CAxIA,qBENC,oCAA8B,CFU9B,eAAgB,CAEhB,2CAA4C,CAC5C,6CAiID,CA9HE,+GAEC,OAAQ,CACR,QAAS,CACT,kBACD,CAIA,uFAEC,oDAAoH,CAApH,kDAAoH,CAApH,qDAAoH,CAApH,kBACD,CAEA,4CACC,gDACD,CAEA,uFAHC,6BAA8E,CAA9E,8BAA8E,CAA9E,4BAMD,CAHA,2CACC,oDAAkF,CAClF,yCACD,CAIA,uFAEC,oDAAoH,CAApH,qBAAoH,CAApH,qDAAoH,CAApH,+CACD,CAEA,4CACC,6CAAkE,CAClE,uDACD,CAEA,uFAJC,6BAAkE,CAAlE,+BAAkE,CAAlE,8BAOD,CAHA,2CACC,iDAAkF,CAClF,4CACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,8CACD,CAIA,2GAEC,+CAAkD,CAClD,8CACD,CAIA,2GAEC,gDAAmD,CACnD,8CACD,CAIA,6GAEC,SAAU,CACV,uDAA0D,CAC1D,8CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,8CACD,CAIA,6GAEC,SAAU,CACV,uDAA0D,CAC1D,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: var(--ck-balloon-arrow-offset);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: var(--ck-balloon-arrow-offset);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck .ck-balloon-rotator__navigation{display:flex;align-items:center;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-small)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css',
            ],
            names: [],
            mappings:
              'AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCACC,oCAAqC,CACrC,kCAAmC,CACnC,qCACD,CAGA,iEACC,uCAAwC,CAGxC,mCACD,CAMA,2DACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n',
              "/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);width:100%;height:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBCJC,oCAA8B,CDO9B,eAAgB,CAEhB,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CAEtC,UAAW,CACX,WACD,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{z-index:var(--ck-z-modal);position:fixed;top:0}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{top:auto;position:absolute}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{box-shadow:var(--ck-drop-shadow),0 0;border-width:0 1px 1px;border-top-left-radius:0;border-top-right-radius:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAMC,qDACC,yBAA0B,CAC1B,cAAe,CACf,KACD,CAEA,kEACC,QAAS,CACT,iBACD,CCPA,qDCCA,oCAA8B,CDE7B,sBAAuB,CACvB,wBAAyB,CACzB,yBACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\tz-index: var(--ck-z-modal); /* #315 */\n\t\tposition: fixed;\n\t\ttop: 0;\n\t}\n\n\t& .ck-sticky-panel__content_sticky_bottom-limit {\n\t\ttop: auto;\n\t\tposition: absolute;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\t@mixin ck-drop-shadow;\n\n\t\tborder-width: 0 1px 1px;\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/blocktoolbar.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css',
            ],
            names: [],
            mappings: 'AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n\tposition: absolute;\n\tz-index: var(--ck-z-default);\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-block-toolbar-button: var(--ck-color-text);\n\t--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n\tcolor: var(--ck-color-block-toolbar-button);\n\tfont-size: var(--ck-block-toolbar-size);\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-placeholder,.ck .ck-placeholder{position:relative}.ck.ck-placeholder:before,.ck .ck-placeholder:before{position:absolute;left:0;right:0;content:attr(data-placeholder);pointer-events:none}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-placeholder:before,.ck .ck-placeholder:before{cursor:text;color:var(--ck-color-engine-placeholder-text)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css',
            ],
            names: [],
            mappings:
              'AAMA,uCAEC,iBAWD,CATC,qDACC,iBAAkB,CAClB,MAAO,CACP,OAAQ,CACR,8BAA+B,CAG/B,mBACD,CAKA,wCACC,YACD,CClBA,qDACC,WAAY,CACZ,6CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\tposition: relative;\n\n\t&::before {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck-content blockquote{overflow:hidden;padding-right:1.5em;padding-left:1.5em;margin-left:0;margin-right:0;font-style:italic;border-left:5px solid #ccc}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-block-quote/theme/blockquote.css'],
            names: [],
            mappings:
              'AAKA,uBAEC,eAAgB,CAGhB,mBAAoB,CACpB,kBAAmB,CAEnB,aAAc,CACd,cAAe,CACf,iBAAkB,CAClB,0BACD,CAEA,gCACC,aAAc,CACd,2BACD',
            sourcesContent: [
              '/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content blockquote {\n\t/* See #12 */\n\toverflow: hidden;\n\n\t/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */\n\tpadding-right: 1.5em;\n\tpadding-left: 1.5em;\n\n\tmargin-left: 0;\n\tmargin-right: 0;\n\tfont-style: italic;\n\tborder-left: solid 5px hsl(0, 0%, 80%);\n}\n\n.ck-content[dir="rtl"] blockquote {\n\tborder-left: 0;\n\tborder-right: solid 5px hsl(0, 0%, 80%);\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck .ck-widget .ck-widget__type-around__button{display:block;position:absolute;overflow:hidden;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{position:absolute;top:50%;left:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{top:calc(var(--ck-widget-outline-thickness)*-0.5);left:min(10%,30px);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-0.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;position:absolute;top:1px;left:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;position:absolute;left:0;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{top:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{width:var(--ck-widget-type-around-button-size);height:var(--ck-widget-type-around-button-size);background:var(--ck-color-widget-type-around-button);border-radius:100px;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);opacity:0;pointer-events:none}.ck .ck-widget .ck-widget__type-around__button svg{width:10px;height:8px;transform:translate(-50%,-50%);transition:transform .5s ease;margin-top:1px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{width:calc(var(--ck-widget-type-around-button-size) - 2px);height:calc(var(--ck-widget-type-around-button-size) - 2px);border-radius:100px;background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3))}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{pointer-events:none;height:1px;animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;outline:1px solid hsla(0,0%,100%,.5);background:var(--ck-color-base-text)}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css',
            ],
            names: [],
            mappings:
              'AASC,+CACC,aAAc,CACd,iBAAkB,CAClB,eAAgB,CAChB,2BAwBD,CAtBC,mDACC,iBAAkB,CAClB,OAAQ,CACR,QAAS,CACT,qCACD,CAEA,qFAEC,iDAAoD,CACpD,kBAAoB,CAEpB,0BACD,CAEA,oFAEC,oDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CACd,iBAAkB,CAClB,OAAQ,CACR,QAAS,CACT,qCACD,CAMD,2EACC,YAAa,CACb,iBAAkB,CAClB,MAAO,CACP,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHACC,qDAA0D,CAC1D,aACD,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CACC,8CAA+C,CAC/C,+CAAgD,CAChD,oDAAqD,CACrD,mBAAoB,CACpB,uMAAyM,CAb1M,SAAU,CACV,mBA0DA,CA1CC,mDACC,UAAW,CACX,UAAW,CACX,8BAA+B,CAC/B,6BAA8B,CAC9B,cAgBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLACC,0DAA2D,CAC3D,2DAA4D,CAC5D,mBAAoB,CACpB,uEACD,CAOD,8GACC,gBACD,CAKA,mDACC,mBAAoB,CACpB,UAAW,CACX,mFAAoF,CAMpF,oCAAwC,CACxC,oCACD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CASE,0jBACC,SACD,CASF,mPACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Styles for the "before" button when the widget has a selection handle in an RTL environment.\n * The selection handler is aligned to the right side of the widget so there is no need to create\n * additional space for it next to the "before" button.\n */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {\n\tmargin-left: 0;\n\tmargin-right: 20px;\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          ':root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);color:var(--ck-color-resizer-tooltip-text);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);font-size:var(--ck-font-size-tiny);display:block;padding:var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{top:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{top:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-width:var(--ck-widget-outline-thickness);outline-style:solid;outline-color:transparent;transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;background-color:var(--ck-color-widget-editable-focus-background)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{padding:4px;box-sizing:border-box;background-color:transparent;opacity:0;transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;transform:translateY(-100%);left:calc(0px - var(--ck-widget-outline-thickness));top:0}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{width:var(--ck-widget-handler-icon-size);height:var(--ck-widget-handler-icon-size);color:var(--ck-color-widget-drag-handler-icon-color)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-focus-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widget.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CACtD,0CAA2C,CAC3C,qDAAsD,CACtD,6CAA8C,CAC9C,kCAAmC,CACnC,aAAc,CACd,+BA4BD,CA1BC,gLAIC,iBACD,CAEA,0CACC,oCAAqC,CACrC,qCACD,CAEA,2CACC,oCAAqC,CACrC,sCACD,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CCtED,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eACC,gDAAiD,CACjD,mBAAoB,CACpB,yBAA0B,CAC1B,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGC/BA,YAAa,CACb,2BAA2B,CCF3B,qCAA8B,CFqC7B,iEACD,CAIA,4EACC,WAAY,CACZ,qBAAsB,CAGtB,4BAA6B,CAC7B,SAAU,CAMV,6SAG6F,CAG7F,iEAAkE,CAGlE,2BAA4B,CAC5B,mDAAoD,CACpD,KAqBD,CAnBC,qFAEC,wCAAyC,CACzC,yCAA0C,CAC1C,oDASD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFACC,SAAU,CACV,oDACD,CAKC,oMACC,SAAU,CACV,6CAMD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n\t--ck-resizer-border-radius: var(--ck-border-radius);\n\t--ck-resizer-tooltip-offset: 10px;\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n\n\t/* Show the selection handle when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: var(--ck-spacing-small);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\t\ttop: 0;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& > .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& > .ck-widget__selection-handle,\n\t\t\t& > .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n',
              "/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;position:relative;pointer-events:none}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-0.5);top:calc(var(--ck-clipboard-drop-target-dot-height)*-0.5);border:1px solid var(--ck-clipboard-drop-target-color);background:var(--ck-clipboard-drop-target-color);margin-left:-1px}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{content:"";width:0;height:0;display:block;position:absolute;left:50%;top:calc(var(--ck-clipboard-drop-target-dot-height)*-0.5);transform:translateX(-50%);border-left:calc(var(--ck-clipboard-drop-target-dot-width)*0.5) solid transparent;border-bottom:0 solid transparent;border-right:calc(var(--ck-clipboard-drop-target-dot-width)*0.5) solid transparent;border-top:calc(var(--ck-clipboard-drop-target-dot-height)) solid var(--ck-clipboard-drop-target-color)}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css',
            ],
            names: [],
            mappings:
              'AASC,8DACC,cAAe,CACf,iBAAkB,CAClB,mBAMD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CCzBF,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEACC,4DAA8D,CAC9D,yDAA2D,CAC3D,sDAAuD,CACvD,gDAAiD,CACjD,gBAkBD,CAfC,yEACC,UAAW,CACX,OAAQ,CACR,QAAS,CAET,aAAc,CACd,iBAAkB,CAClB,QAAS,CACT,yDAA2D,CAE3D,0BAA2B,CAG3B,iFAAmB,CAAnB,iCAAmB,CAAnB,kFAAmB,CAAnB,uGACD,CA2DF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: inline;\n\t\tposition: relative;\n\t\tpointer-events: none;\n\n\t\t& span {\n\t\t\tposition: absolute;\n\t\t\twidth: 0;\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\t& > .ck-widget__selection-handle {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t& > .ck-widget__type-around {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-clipboard-drop-target-dot-width: 12px;\n\t--ck-clipboard-drop-target-dot-height: 8px;\n\t--ck-clipboard-drop-target-color: var(--ck-color-focus-border)\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\t& span {\n\t\t\tbottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tbackground: var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-left: -1px;\n\n\t\t\t/* The triangle above the marker */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: 50%;\n\t\t\t\ttop: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);\n\n\t\t\t\ttransform: translateX(-50%);\n\t\t\t\tborder-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;\n\t\t\t\tborder-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t// Horizontal drop target (between blocks).\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: block;\n\t\tposition: relative;\n\t\twidth: 100%;\n\t\theight: 0;\n\t\tmargin: 0;\n\t\ttext-align: initial;\n\n\t\t& .ck-clipboard-drop-target__line {\n\t\t\tposition: absolute;\n\t\t\twidth: 100%;\n\t\t\theight: 0;\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-top: -1px;\n\n\t\t\t&::before {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) 0 var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size)) var(--ck-clipboard-drop-target-dot-size) 0;\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\t/*\n\t * Styles of the widget that it a drop target.\n\t */\n\t& .ck-widget.ck-clipboard-drop-target-range {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\tzoom: 0.6;\n\t\toutline: none !important;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck .ck-button.ck-color-table__remove-color{display:flex;align-items:center;width:100%}label.ck.ck-color-grid__label{font-weight:unset}.ck .ck-button.ck-color-table__remove-color{padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck .ck-button.ck-color-table__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-base-border)}[dir=ltr] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-font/theme/fontcolor.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-font/fontcolor.css',
            ],
            names: [],
            mappings:
              'AAKA,4CACC,YAAa,CACb,kBAAmB,CACnB,UACD,CAEA,8BACC,iBACD,CCNA,4CACC,qEAAyE,CACzE,2BAA4B,CAC5B,4BAeD,CAbC,wDACC,mDACD,CAEA,kEAEE,uCAMF,CARA,kEAME,sCAEF',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-button.ck-color-table__remove-color {\n\tdisplay: flex;\n\talign-items: center;\n\twidth: 100%;\n}\n\nlabel.ck.ck-color-grid__label {\n\tfont-weight: unset;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck .ck-button.ck-color-table__remove-color {\n\tpadding: calc(var(--ck-spacing-standard) / 2 ) var(--ck-spacing-standard);\n\tborder-bottom-left-radius: 0;\n\tborder-bottom-right-radius: 0;\n\n\t&:not(:focus) {\n\t\tborder-bottom: 1px solid var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-right: var(--ck-spacing-standard);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n}\n\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck-content .text-tiny{font-size:.7em}.ck-content .text-small{font-size:.85em}.ck-content .text-big{font-size:1.4em}.ck-content .text-huge{font-size:1.8em}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-font/theme/fontsize.css'],
            names: [],
            mappings: 'AAUC,uBACC,cACD,CAEA,wBACC,eACD,CAEA,sBACC,eACD,CAEA,uBACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* The values should be synchronized with the "FONT_SIZE_PRESET_UNITS" object in the "/src/fontsize/utils.js" file. */\n\n/* Styles should be prefixed with the `.ck-content` class.\nSee https://github.com/ckeditor/ckeditor5/issues/6636 */\n.ck-content {\n\t& .text-tiny {\n\t\tfont-size: .7em;\n\t}\n\n\t& .text-small {\n\t\tfont-size: .85em;\n\t}\n\n\t& .text-big {\n\t\tfont-size: 1.4em;\n\t}\n\n\t& .text-huge {\n\t\tfont-size: 1.8em;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-heading/theme/heading.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css',
            ],
            names: [],
            mappings: 'AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-heading_heading1 {\n\tfont-size: 20px;\n}\n\n.ck.ck-heading_heading2 {\n\tfont-size: 17px;\n}\n\n.ck.ck-heading_heading3 {\n\tfont-size: 14px;\n}\n\n.ck[class*="ck-heading_heading"] {\n\tfont-weight: bold;\n}\n',
              "/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Resize dropdown's button label. */\n.ck.ck-dropdown.ck-heading-dropdown {\n\t& .ck-dropdown__button .ck-button__label {\n\t\twidth: 8em;\n\t}\n\n\t& .ck-dropdown__panel .ck-list__item {\n\t\tmin-width: 18em;\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;position:absolute;pointer-events:none;left:0;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{position:absolute;pointer-events:all}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{width:var(--ck-resizer-size);height:var(--ck-resizer-size);background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{top:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{top:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css',
            ],
            names: [],
            mappings:
              'AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CACb,iBAAkB,CAGlB,mBAAoB,CAEpB,MAAO,CACP,KACD,CAGC,2EACC,aACD,CAGD,gCACC,iBAAkB,CAGlB,kBAWD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCACC,4BAA6B,CAC7B,6BAA8B,CAC9B,uCAAwC,CACxC,gDAA6D,CAC7D,6CAqBD,CAnBC,oEACC,4BAA6B,CAC7B,6BACD,CAEA,qEACC,4BAA6B,CAC7B,8BACD,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n}\n\n.ck .ck-widget__resizer {\n\tdisplay: none;\n\tposition: absolute;\n\n\t/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n\tpointer-events: none;\n\n\tleft: 0;\n\ttop: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n\t& > .ck-widget__resizer {\n\t\tdisplay: block;\n\t}\n}\n\n.ck .ck-widget__resizer__handle {\n\tposition: absolute;\n\n\t/* Resizers are the only UI elements that should interfere with a pointer device. */\n\tpointer-events: all;\n\n\t&.ck-widget__resizer__handle-top-left,\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tcursor: nwse-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-top-right,\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tcursor: nesw-resize;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-resizer-size: 10px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\t--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n\toutline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n\twidth: var(--ck-resizer-size);\n\theight: var(--ck-resizer-size);\n\tbackground: var(--ck-color-focus-border);\n\tborder: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n\tborder-radius: var(--ck-resizer-border-radius);\n\n\t&.ck-widget__resizer__handle-top-left {\n\t\ttop: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-top-right {\n\t\ttop: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/textalternativeform.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css',
            ],
            names: [],
            mappings:
              'AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck-vertical-form .ck-button:after{content:"";width:0;position:absolute;right:-1px;top:var(--ck-spacing-small);bottom:var(--ck-spacing-small);z-index:1}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{content:"";width:0;position:absolute;right:-1px;top:var(--ck-spacing-small);bottom:var(--ck-spacing-small);z-index:1}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-text-width)*0.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-large);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after,[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css',
            ],
            names: [],
            mappings:
              'AAOA,mCACC,UAAW,CACX,OAAQ,CACR,iBAAkB,CAClB,UAAW,CACX,2BAA4B,CAC5B,8BAA+B,CAC/B,SACD,CCTC,oCDaC,wCACC,UAAW,CACX,OAAQ,CACR,iBAAkB,CAClB,UAAW,CACX,2BAA4B,CAC5B,8BAA+B,CAC/B,SACD,CCnBD,CCAD,qDACC,kDACD,CAEA,uBACC,+BAkED,CAhEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,0CA6CF,CA3CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAID,iGAEC,kCAAmC,CACnC,kCAAmC,CAEnC,eAAgB,CAChB,QAAS,CACT,gDAaD,CApBA,0OAcE,aAMF,CAGC,yMACC,kDACD,CDpEF',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button::after {\n\tcontent: "";\n\twidth: 0;\n\tposition: absolute;\n\tright: -1px;\n\ttop: var(--ck-spacing-small);\n\tbottom: var(--ck-spacing-small);\n\tz-index: 1;\n}\n\n.ck.ck-responsive-form {\n\t@mixin ck-media-phone {\n\t\t& .ck-button::after {\n\t\t\tcontent: "";\n\t\t\twidth: 0;\n\t\t\tposition: absolute;\n\t\t\tright: -1px;\n\t\t\ttop: var(--ck-spacing-small);\n\t\t\tbottom: var(--ck-spacing-small);\n\t\t\tz-index: 1;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n\tborder-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n\tpadding: var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& > :not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& > :not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tpadding: 0;\n\t\twidth: calc(.8 * var(--ck-input-text-width));\n\n\t\t& .ck-labeled-field-view {\n\t\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) 0;\n\n\t\t\t& .ck-input-text {\n\t\t\t\tmin-width: 0;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\n\t\t\t/* Let the long error messages wrap in the narrow form. */\n\t\t\t& .ck-labeled-field-view__error {\n\t\t\t\twhite-space: normal;\n\t\t\t}\n\t\t}\n\n\t\t/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n\t\t& > .ck-button:nth-last-child(1),\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\tpadding: var(--ck-spacing-standard);\n\t\t\tmargin-top: var(--ck-spacing-large);\n\n\t\t\tborder-radius: 0;\n\t\t\tborder: 0;\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\t&::after {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck-content .image{display:table;clear:both;text-align:center;margin:1em auto}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:50px}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{position:static}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-image/theme/image.css'],
            names: [],
            mappings:
              'AAKA,mBACC,aAAc,CACd,UAAW,CACX,iBAAkB,CAGlB,eAeD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD,CAQD,gEACC,eACD',
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .image {\n\tdisplay: table;\n\tclear: both;\n\ttext-align: center;\n\n\t/* Make sure there is some space between the content and the image. Center image by default. */\n\tmargin: 1em auto;\n\n\t& img {\n\t\t/* Prevent unnecessary margins caused by line-height (see #44). */\n\t\tdisplay: block;\n\n\t\t/* Center the image if its width is smaller than the content's width. */\n\t\tmargin: 0 auto;\n\n\t\t/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n\t\tmax-width: 100%;\n\n\t\t/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n\t\tmin-width: 50px;\n\t}\n}\n\n/*\n * Since the caption placeholder for images disappears when focused, it does not require special treatment\n * and can go with a position that follows text alignment of an .image out-of-the-box (center by default).\n * See https://github.com/ckeditor/ckeditor5/issues/8689.\n */\n.ck.ck-editor__editable .image > figcaption.ck-placeholder::before {\n\tposition: static;\n}\n",
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck-content .image>figcaption{display:table-caption;caption-side:bottom;word-break:break-word;color:#333;background-color:#f7f7f7;padding:.6em;font-size:.75em;outline-offset:-1px}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagecaption.css'],
            names: [],
            mappings:
              'AAKA,8BACC,qBAAsB,CACtB,mBAAoB,CACpB,qBAAsB,CACtB,UAAsB,CACtB,wBAAiC,CACjC,YAAa,CACb,eAAgB,CAChB,mBACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .image > figcaption {\n\tdisplay: table-caption;\n\tcaption-side: bottom;\n\tword-break: break-word;\n\tcolor: hsl(0, 0%, 20%);\n\tbackground-color: hsl(0, 0%, 97%);\n\tpadding: .6em;\n\tfont-size: .75em;\n\toutline-offset: -1px;\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck-content .image.image_resized{max-width:100%;display:block;box-sizing:border-box}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageresize.css'],
            names: [],
            mappings:
              'AAKA,iCACC,cAAe,CAMf,aAAc,CACd,qBAWD,CATC,qCAEC,UACD,CAEA,4CAEC,aACD,CAGD,oFACC,uCACD,CAEA,oFACC,sCACD,CAEA,oEACC,SACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .image.image_resized {\n\tmax-width: 100%;\n\t/*\n\tThe `<figure>` element for resized images must not use `display:table` as browsers do not support `max-width` for it well.\n\tSee https://stackoverflow.com/questions/4019604/chrome-safari-ignoring-max-width-in-table/14420691#14420691 for more.\n\tFortunately, since we control the width, there is no risk that the image will look bad.\n\t*/\n\tdisplay: block;\n\tbox-sizing: border-box;\n\n\t& img {\n\t\t/* For resized images it is the `<figure>` element that determines the image width. */\n\t\twidth: 100%;\n\t}\n\n\t& > figcaption {\n\t\t/* The `<figure>` element uses `display:block`, so `<figcaption>` also has to. */\n\t\tdisplay: block;\n\t}\n}\n\n[dir="ltr"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n\tmargin-right: var(--ck-spacing-standard);\n}\n\n[dir="rtl"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n\tmargin-left: var(--ck-spacing-standard);\n}\n\n.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label {\n\twidth: 4em;\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          ':root{--ck-image-style-spacing:1.5em}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagestyle.css'],
            names: [],
            mappings:
              'AAKA,MACC,8BACD,CAGC,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-image-style-spacing: 1.5em;\n}\n\n.ck-content {\n\t& .image-style-side {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t\tmax-width: 50%;\n\t}\n\n\t& .image-style-align-left {\n\t\tfloat: left;\n\t\tmargin-right: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-align-center {\n\t\tmargin-left: auto;\n\t\tmargin-right: auto;\n\t}\n\n\t& .image-style-align-right {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-editor__editable .image{position:relative}.ck.ck-editor__editable .image .ck-progress-bar{position:absolute;top:0;left:0}.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar{height:2px;width:0;background:var(--ck-color-upload-bar-background);transition:width .1s}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadprogress.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css',
            ],
            names: [],
            mappings:
              'AAKA,+BACC,iBACD,CAGA,gDACC,iBAAkB,CAClB,KAAM,CACN,MACD,CCPC,yCACC,oBACD,CAID,gDACC,UAAW,CACX,OAAQ,CACR,gDAAiD,CACjD,oBACD,CAEA,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable .image {\n\tposition: relative;\n}\n\n/* Upload progress bar. */\n.ck.ck-editor__editable .image .ck-progress-bar {\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable .image {\n\t/* Showing animation. */\n\t&.ck-appear {\n\t\tanimation: fadeIn 700ms;\n\t}\n}\n\n/* Upload progress bar. */\n.ck.ck-editor__editable .image .ck-progress-bar {\n\theight: 2px;\n\twidth: 0;\n\tbackground: var(--ck-color-upload-bar-background);\n\ttransition: width 100ms;\n}\n\n@keyframes fadeIn {\n\tfrom { opacity: 0; }\n\tto   { opacity: 1; }\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck-image-upload-complete-icon{display:block;position:absolute;top:10px;right:10px;border-radius:50%}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20px;--ck-image-upload-icon-width:2px}.ck-image-upload-complete-icon{width:var(--ck-image-upload-icon-size);height:var(--ck-image-upload-icon-size);opacity:0;background:var(--ck-color-image-upload-icon-background);animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;animation-fill-mode:forwards,forwards;animation-duration:.5s,.5s;font-size:var(--ck-image-upload-icon-size);animation-delay:0ms,3s}.ck-image-upload-complete-icon:after{left:25%;top:50%;opacity:0;height:0;width:0;transform:scaleX(-1) rotate(135deg);transform-origin:left top;border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);animation-name:ck-upload-complete-icon-check;animation-duration:.5s;animation-delay:.5s;animation-fill-mode:forwards;box-sizing:border-box}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{opacity:1;width:0;height:0}33%{width:.3em;height:0}to{opacity:1;width:.3em;height:.45em}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadicon.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css',
            ],
            names: [],
            mappings:
              'AAKA,+BACC,aAAc,CACd,iBAAkB,CAClB,QAAS,CACT,UAAW,CACX,iBAMD,CAJC,qCACC,UAAW,CACX,iBACD,CCVD,MACC,iCAA8C,CAC9C,+CAA4D,CAE5D,gCAAiC,CACjC,gCACD,CAEA,+BACC,sCAAuC,CACvC,uCAAwC,CACxC,SAAU,CACV,uDAAwD,CACxD,wEAA0E,CAC1E,qCAAuC,CACvC,0BAAgC,CAGhC,0CAA2C,CAG3C,sBAyBD,CAtBC,qCAEC,QAAS,CAET,OAAQ,CACR,SAAU,CACV,QAAS,CACT,OAAQ,CAER,mCAAoC,CACpC,yBAA0B,CAC1B,oFAAqF,CACrF,sFAAuF,CAEvF,4CAA6C,CAC7C,sBAAyB,CACzB,mBAAsB,CACtB,4BAA6B,CAG7B,qBACD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GACC,SAAU,CACV,OAAQ,CACR,QACD,CACA,IACC,UAAY,CACZ,QACD,CACA,GACC,SAAU,CACV,UAAY,CACZ,YACD,CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-image-upload-complete-icon {\n\tdisplay: block;\n\tposition: absolute;\n\ttop: 10px;\n\tright: 10px;\n\tborder-radius: 50%;\n\n\t&::after {\n\t\tcontent: "";\n\t\tposition: absolute;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-upload-icon: hsl(0, 0%, 100%);\n\t--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\n\n\t--ck-image-upload-icon-size: 20px;\n\t--ck-image-upload-icon-width: 2px;\n}\n\n.ck-image-upload-complete-icon {\n\twidth: var(--ck-image-upload-icon-size);\n\theight: var(--ck-image-upload-icon-size);\n\topacity: 0;\n\tbackground: var(--ck-color-image-upload-icon-background);\n\tanimation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\n\tanimation-fill-mode: forwards, forwards;\n\tanimation-duration: 500ms, 500ms;\n\n\t/* To make animation scalable. */\n\tfont-size: var(--ck-image-upload-icon-size);\n\n\t/* Hide completed upload icon after 3 seconds. */\n\tanimation-delay: 0ms, 3000ms;\n\n\t/* This is check icon element made from border-width mixed with animations. */\n\t&::after {\n\t\t/* Because of border transformation we need to "hard code" left position. */\n\t\tleft: 25%;\n\n\t\ttop: 50%;\n\t\topacity: 0;\n\t\theight: 0;\n\t\twidth: 0;\n\n\t\ttransform: scaleX(-1) rotate(135deg);\n\t\ttransform-origin: left top;\n\t\tborder-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\t\tborder-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\n\t\tanimation-name: ck-upload-complete-icon-check;\n\t\tanimation-duration: 500ms;\n\t\tanimation-delay: 500ms;\n\t\tanimation-fill-mode: forwards;\n\n\t\t/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\n\t\tbox-sizing: border-box;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-show {\n\tfrom {\n\t\topacity: 0;\n\t}\n\n\tto {\n\t\topacity: 1;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-hide {\n\tfrom {\n\t\topacity: 1;\n\t}\n\n\tto {\n\t\topacity: 0;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-check {\n\t0% {\n\t\topacity: 1;\n\t\twidth: 0;\n\t\theight: 0;\n\t}\n\t33% {\n\t\twidth: 0.3em;\n\t\theight: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t\twidth: 0.3em;\n\t\theight: 0.45em;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck .ck-upload-placeholder-loader{position:absolute;display:flex;align-items:center;justify-content:center;top:0;left:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px}.ck .ck-image-upload-placeholder{width:100%;margin:0}.ck .ck-upload-placeholder-loader{width:100%;height:100%}.ck .ck-upload-placeholder-loader:before{width:var(--ck-upload-placeholder-loader-size);height:var(--ck-upload-placeholder-loader-size);border-radius:50%;border-top:3px solid var(--ck-color-upload-placeholder-loader);border-right:2px solid transparent;animation:ck-upload-placeholder-loader 1s linear infinite}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadloader.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css',
            ],
            names: [],
            mappings:
              'AAKA,kCACC,iBAAkB,CAClB,YAAa,CACb,kBAAmB,CACnB,sBAAuB,CACvB,KAAM,CACN,MAMD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCACD,CAEA,iCAEC,UAAW,CACX,QACD,CAEA,kCACC,UAAW,CACX,WAUD,CARC,yCACC,8CAA+C,CAC/C,+CAAgD,CAChD,iBAAkB,CAClB,8DAA+D,CAC/D,kCAAmC,CACnC,yDACD,CAGD,wCACC,GACC,uBACD,CACD',
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-upload-placeholder-loader {\n\tposition: absolute;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\ttop: 0;\n\tleft: 0;\n\n\t&::before {\n\t\tcontent: '';\n\t\tposition: relative;\n\t}\n}\n",
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\n\t--ck-upload-placeholder-loader-size: 32px;\n}\n\n.ck .ck-image-upload-placeholder {\n\t/* We need to control the full width of the SVG gray background. */\n\twidth: 100%;\n\tmargin: 0;\n}\n\n.ck .ck-upload-placeholder-loader {\n\twidth: 100%;\n\theight: 100%;\n\n\t&::before {\n\t\twidth: var(--ck-upload-placeholder-loader-size);\n\t\theight: var(--ck-upload-placeholder-loader-size);\n\t\tborder-radius: 50%;\n\t\tborder-top: 3px solid var(--ck-color-upload-placeholder-loader);\n\t\tborder-right: 2px solid transparent;\n\t\tanimation: ck-upload-placeholder-loader 1s linear infinite;\n\t}\n}\n\n@keyframes ck-upload-placeholder-loader {\n\tto {\n\t\ttransform: rotate( 360deg );\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{height:100%;border-right:1px solid var(--ck-color-base-text);margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/link.css'],
            names: [],
            mappings: 'AAMA,sBACC,mDACD,CAMA,4BACC,8CACD,CAGA,sCACC,WAAY,CACZ,gDAAiD,CACjD,iBAAkB,CAClB,oCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n\tbackground: var(--ck-color-link-selected-background);\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n\tbackground: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n\theight: 100%;\n\tborder-right: 1px solid var(--ck-color-base-text);\n\tmargin-right: -1px;\n\toutline: solid 1px hsla(0, 0%, 100%, .5);\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{padding:0;min-width:var(--ck-input-text-width)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical .ck-button{padding:var(--ck-spacing-standard);margin:0;border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border);width:50%}[dir=ltr] .ck.ck-link-form_layout-vertical .ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{border:0;padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkform.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css',
            ],
            names: [],
            mappings:
              'AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCACC,SAAU,CACV,oCA8CD,CA5CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CACC,kCAAmC,CACnC,QAAS,CACT,eAAgB,CAChB,QAAS,CACT,gDAAiD,CACjD,SAaD,CAnBA,4GAaE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAWD,CATC,wEACC,QAAS,CACT,SAAU,CACV,UAKD,CAHC,8EACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n\tdisplay: flex;\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tdisplay: block;\n\n\t/*\n\t * Whether the form is in the responsive mode or not, if there are decorator buttons\n\t * keep the top margin of action buttons medium.\n\t */\n\t& .ck-button {\n\t\t&.ck-button-save,\n\t\t&.ck-button-cancel {\n\t\t\tmargin-top: var(--ck-spacing-medium);\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tpadding: 0;\n\tmin-width: var(--ck-input-text-width);\n\n\t& .ck-labeled-field-view {\n\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);\n\n\t\t& .ck-input-text {\n\t\t\tmin-width: 0;\n\t\t\twidth: 100%;\n\t\t}\n\t}\n\n\t& .ck-button {\n\t\tpadding: var(--ck-spacing-standard);\n\t\tmargin: 0;\n\t\tborder-radius: 0;\n\t\tborder: 0;\n\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\twidth: 50%;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: 0;\n\n\t\t\t&:last-of-type {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n\t& .ck.ck-list {\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\n\t\t& .ck-button.ck-switchbutton {\n\t\t\tborder: 0;\n\t\t\tpadding: 0;\n\t\t\twidth: 100%;\n\n\t\t\t&:hover {\n\t\t\t\tbackground: none;\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{padding:0 var(--ck-spacing-medium);color:var(--ck-color-link-default);text-overflow:ellipsis;cursor:pointer;max-width:var(--ck-input-text-width);min-width:3em;text-align:center}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{min-width:0;max-width:100%}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkactions.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css',
            ],
            names: [],
            mappings:
              'AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCKA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EACC,kCAAmC,CACnC,kCAAmC,CACnC,sBAAuB,CACvB,cAAe,CAIf,oCAAqC,CACrC,aAAc,CACd,iBAKD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDvDD,oCC2DC,wDACC,8DAMD,CAJC,0EACC,WAAY,CACZ,cACD,CAGD,gJAME,aAEF,CD1ED',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-link-actions__preview {\n\t\tdisplay: inline-block;\n\n\t\t& .ck-button__label {\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-link-actions__preview {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\t& .ck-button.ck-link-actions__preview {\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\n\t\t& .ck-button__label {\n\t\t\tpadding: 0 var(--ck-spacing-medium);\n\t\t\tcolor: var(--ck-color-link-default);\n\t\t\ttext-overflow: ellipsis;\n\t\t\tcursor: pointer;\n\n\t\t\t/* Match the box model of the link editor form\'s input so the balloon\n\t\t\tdoes not change width when moving between actions and the form. */\n\t\t\tmax-width: var(--ck-input-text-width);\n\t\t\tmin-width: 3em;\n\t\t\ttext-align: center;\n\n\t\t\t&:hover {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\n\t\t&,\n\t\t&:hover,\n\t\t&:focus,\n\t\t&:active {\n\t\t\tbackground: none;\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&:focus {\n\t\t\t& .ck-button__label {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-button:not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-button:not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\t& .ck-button.ck-link-actions__preview {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-button__label {\n\t\t\t\tmin-width: 0;\n\t\t\t\tmax-width: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck.ck-list-styles-dropdown>.ck-dropdown__panel>.ck-toolbar>.ck-toolbar__items{display:grid}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-dropdown>.ck-dropdown__panel>.ck-toolbar{background:none;padding:0}.ck.ck-list-styles-dropdown>.ck-dropdown__panel>.ck-toolbar>.ck-toolbar__items{grid-template-columns:repeat(3,auto);row-gap:var(--ck-spacing-medium);column-gap:var(--ck-spacing-medium);padding:var(--ck-spacing-medium)}.ck.ck-list-styles-dropdown>.ck-dropdown__panel>.ck-toolbar>.ck-toolbar__items .ck-button{width:var(--ck-list-style-button-size);height:var(--ck-list-style-button-size);padding:0;margin:0;box-sizing:content-box}.ck.ck-list-styles-dropdown>.ck-dropdown__panel>.ck-toolbar>.ck-toolbar__items .ck-button .ck-icon{width:var(--ck-list-style-button-size);height:var(--ck-list-style-button-size)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-list/theme/liststyles.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/liststyles.css',
            ],
            names: [],
            mappings:
              'AAKA,+EAKC,YACD,CCNA,MACC,gCACD,CAEA,4DACC,eAAgB,CAChB,SAiCD,CA/BC,+EACC,oCAAwC,CACxC,gCAAiC,CACjC,mCAAoC,CACpC,gCA0BD,CAxBC,0FAEC,sCAAuC,CACvC,uCAAwC,CACxC,SAAU,CAMV,QAAS,CAOT,sBAMD,CAJC,mGACC,sCAAuC,CACvC,uCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-styles-dropdown > .ck-dropdown__panel > .ck-toolbar > .ck-toolbar__items {\n\t/*\n\t * Use the benefits of the toolbar (e.g. out-of-the-box keyboard navigation) but make it look\n\t * like a panel with thumbnails (previews).\n\t */\n\tdisplay: grid;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-list-style-button-size: 44px;\n}\n\n.ck.ck-list-styles-dropdown > .ck-dropdown__panel > .ck-toolbar {\n\tbackground: none;\n\tpadding: 0;\n\n\t& > .ck-toolbar__items {\n\t\tgrid-template-columns: repeat( 3, auto );\n\t\trow-gap: var(--ck-spacing-medium);\n\t\tcolumn-gap: var(--ck-spacing-medium);\n\t\tpadding: var(--ck-spacing-medium);\n\n\t\t& .ck-button {\n\t\t\t/* Make the button look like a thumbnail (the icon "takes it all"). */\n\t\t\twidth: var(--ck-list-style-button-size);\n\t\t\theight: var(--ck-list-style-button-size);\n\t\t\tpadding: 0;\n\n\t\t\t/*\n\t\t\t * Buttons are aligned by the grid so disable default button margins to not collide with the\n\t\t\t * gaps in the grid.\n\t\t\t */\n\t\t\tmargin: 0;\n\n\t\t\t/*\n\t\t\t * Make sure the button border (which is displayed on focus, BTW) does not steal pixels\n\t\t\t * from the button dimensions and, as a result, decrease the size of the icon\n\t\t\t * (which becomes blurry as it scales down).\n\t\t\t */\n\t\t\tbox-sizing: content-box;\n\n\t\t\t& .ck-icon {\n\t\t\t\twidth: var(--ck-list-style-button-size);\n\t\t\t\theight: var(--ck-list-style-button-size);\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          ':root{--ck-color-table-focused-cell-background:rgba(158,207,250,0.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css'],
            names: [],
            mappings: 'AAKA,MACC,8DACD,CAKE,8QAGC,wDAAyD,CAKzD,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD',
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-table-focused-cell-background: hsla(208, 90%, 80%, .3);\n}\n\n.ck-widget.table {\n\t& td,\n\t& th {\n\t\t&.ck-editor__nested-editable.ck-editor__nested-editable_focused,\n\t\t&.ck-editor__nested-editable:focus {\n\t\t\t/* A very slight background to highlight the focused cell */\n\t\t\tbackground: var(--ck-color-table-focused-cell-background);\n\n\t\t\t/* Fixes the problem where surrounding cells cover the focused cell's border.\n\t\t\tIt does not fix the problem in all places but the UX is improved.\n\t\t\tSee https://github.com/ckeditor/ckeditor5-table/issues/29. */\n\t\t\tborder-style: none;\n\t\t\toutline: 1px solid var(--ck-color-focus-border);\n\t\t\toutline-offset: -1px; /* progressive enhancement - no IE support */\n\t\t}\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2);padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0}.ck .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{width:var(--ck-insert-table-dropdown-box-width);height:var(--ck-insert-table-dropdown-box-height);margin:var(--ck-insert-table-dropdown-box-margin);border:1px solid var(--ck-color-base-border);border-radius:1px}.ck .ck-insert-table-dropdown-grid-box.ck-on{border-color:var(--ck-color-focus-border);background:var(--ck-color-focus-outer-shadow)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-table/theme/inserttable.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css',
            ],
            names: [],
            mappings:
              'AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAEC,oJAA2J,CAC3J,yFACD,CAEA,qCACC,iBACD,CAEA,uCACC,+CAAgD,CAChD,iDAAkD,CAClD,iDAAkD,CAClD,4CAA6C,CAC7C,iBAMD,CAJC,6CACC,yCAA0C,CAC1C,6CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-insert-table-dropdown__grid {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: wrap;\n}\n',
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-insert-table-dropdown-padding: 10px;\n\t--ck-insert-table-dropdown-box-height: 11px;\n\t--ck-insert-table-dropdown-box-width: 12px;\n\t--ck-insert-table-dropdown-box-margin: 1px;\n}\n\n.ck .ck-insert-table-dropdown__grid {\n\t/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */\n\twidth: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);\n\tpadding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;\n}\n\n.ck .ck-insert-table-dropdown__label {\n\ttext-align: center;\n}\n\n.ck .ck-insert-table-dropdown-grid-box {\n\twidth: var(--ck-insert-table-dropdown-box-width);\n\theight: var(--ck-insert-table-dropdown-box-height);\n\tmargin: var(--ck-insert-table-dropdown-box-margin);\n\tborder: 1px solid var(--ck-color-base-border);\n\tborder-radius: 1px;\n\n\t&.ck-on {\n\t\tborder-color: var(--ck-color-focus-border);\n\t\tbackground: var(--ck-color-focus-outer-shadow);\n\t}\n}\n\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          ':root{--ck-table-selected-cell-background:rgba(158,207,250,0.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{position:relative;caret-color:transparent;outline:unset;box-shadow:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{content:"";pointer-events:none;background-color:var(--ck-table-selected-cell-background);position:absolute;top:0;left:0;right:0;bottom:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget_selected{outline:unset}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css',
            ],
            names: [],
            mappings:
              'AAKA,MACC,yDACD,CAGC,0IAEC,iBAAkB,CAClB,uBAAwB,CACxB,aAAc,CACd,gBAsBD,CAnBC,sJACC,UAAW,CACX,mBAAoB,CACpB,yDAA0D,CAC1D,iBAAkB,CAClB,KAAM,CACN,MAAO,CACP,OAAQ,CACR,QACD,CAEA,wTAEC,4BACD,CAEA,kLACC,aACD',
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);\n}\n\n.ck.ck-editor__editable .table table {\n\t& td.ck-editor__editable_selected,\n\t& th.ck-editor__editable_selected {\n\t\tposition: relative;\n\t\tcaret-color: transparent;\n\t\toutline: unset;\n\t\tbox-shadow: unset;\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/6446 */\n\t\t&:after {\n\t\t\tcontent: '';\n\t\t\tpointer-events: none;\n\t\t\tbackground-color: var(--ck-table-selected-cell-background);\n\t\t\tposition: absolute;\n\t\t\ttop: 0;\n\t\t\tleft: 0;\n\t\t\tright: 0;\n\t\t\tbottom: 0;\n\t\t}\n\n\t\t& ::selection,\n\t\t&:focus {\n\t\t\tbackground-color: transparent;\n\t\t}\n\n\t\t& .ck-widget_selected {\n\t\t\toutline: unset;\n\t\t}\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          '.ck-content .table{margin:1em auto;display:table}.ck-content .table table{border-collapse:collapse;border-spacing:0;width:100%;height:100%;border:1px double #b3b3b3}.ck-content .table table td,.ck-content .table table th{min-width:2em;padding:.4em;border:1px solid #bfbfbf}.ck-content .table table th{font-weight:700;background:hsla(0,0%,0%,5%)}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-table/theme/table.css'],
            names: [],
            mappings:
              'AAKA,mBAEC,eAAgB,CAChB,aAgCD,CA9BC,yBAEC,wBAAyB,CACzB,gBAAiB,CAIjB,UAAW,CACX,WAAY,CAIZ,yBAiBD,CAfC,wDAEC,aAAc,CACd,YAAa,CAKb,wBACD,CAEA,4BACC,eAAiB,CACjB,2BACD,CAMF,+BACC,gBACD,CAEA,+BACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .table {\n\t/* Give the table widget some air and center it horizontally */\n\tmargin: 1em auto;\n\tdisplay: table;\n\n\t& table {\n\t\t/* The table cells should have slight borders */\n\t\tborder-collapse: collapse;\n\t\tborder-spacing: 0;\n\n\t\t/* Table width and height are set on the parent <figure>. Make sure the table inside stretches\n\t\tto the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */\n\t\twidth: 100%;\n\t\theight: 100%;\n\n\t\t/* The outer border of the table should be slightly darker than the inner lines.\n\t\tAlso see https://github.com/ckeditor/ckeditor5-table/issues/50. */\n\t\tborder: 1px double hsl(0, 0%, 70%);\n\n\t\t& td,\n\t\t& th {\n\t\t\tmin-width: 2em;\n\t\t\tpadding: .4em;\n\n\t\t\t/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it\'s not necessary here.\n\t\t\tHowever, the border is a content style, so it should use .ck-content (so it works outside the editor).\n\t\t\tHence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */\n\t\t\tborder: 1px solid hsl(0, 0%, 75%);\n\t\t}\n\n\t\t& th {\n\t\t\tfont-weight: bold;\n\t\t\tbackground: hsla(0, 0%, 0%, 5%);\n\t\t}\n\t}\n}\n\n/* Text alignment of the table header should match the editor settings and override the native browser styling,\nwhen content is available outside the ediitor. See https://github.com/ckeditor/ckeditor5/issues/6638 */\n.ck-content[dir="rtl"] .table th {\n\ttext-align: right;\n}\n\n.ck-content[dir="ltr"] .table th {\n\ttext-align: left;\n}\n',
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e, n) {
        'use strict';
        var o = n(2),
          i = n.n(o),
          r = n(3),
          s = n.n(r)()(i.a);
        s.push([
          t.i,
          ':root{--ck-todo-list-checkmark-size:16px}.ck-content .todo-list{list-style:none}.ck-content .todo-list li{margin-bottom:5px}.ck-content .todo-list li .todo-list{margin-top:5px}.ck-content .todo-list .todo-list__label>input{-webkit-appearance:none;display:inline-block;position:relative;width:var(--ck-todo-list-checkmark-size);height:var(--ck-todo-list-checkmark-size);vertical-align:middle;border:0;left:-25px;margin-right:-15px;right:0;margin-left:0}.ck-content .todo-list .todo-list__label>input:before{display:block;position:absolute;box-sizing:border-box;content:"";width:100%;height:100%;border:1px solid #333;border-radius:2px;transition:box-shadow .25s ease-in-out,background .25s ease-in-out,border .25s ease-in-out}.ck-content .todo-list .todo-list__label>input:after{display:block;position:absolute;box-sizing:content-box;pointer-events:none;content:"";left:calc(var(--ck-todo-list-checkmark-size)/3);top:calc(var(--ck-todo-list-checkmark-size)/5.3);width:calc(var(--ck-todo-list-checkmark-size)/5.3);height:calc(var(--ck-todo-list-checkmark-size)/2.6);border-left:0 solid transparent;border-bottom:calc(var(--ck-todo-list-checkmark-size)/8) solid transparent;border-right:calc(var(--ck-todo-list-checkmark-size)/8) solid transparent;border-top:0 solid transparent;transform:rotate(45deg)}.ck-content .todo-list .todo-list__label>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-content .todo-list .todo-list__label>input[checked]:after{border-color:#fff}.ck-content .todo-list .todo-list__label .todo-list__label__description{vertical-align:middle}[dir=rtl] .todo-list .todo-list__label>input{left:0;margin-right:0;right:-25px;margin-left:-15px}.ck-editor__editable .todo-list .todo-list__label>input{cursor:pointer}.ck-editor__editable .todo-list .todo-list__label>input:hover:before{box-shadow:0 0 0 5px rgba(0,0,0,.1)}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-list/theme/todolist.css'],
            names: [],
            mappings:
              'AAKA,MACC,kCACD,CAEA,uBACC,eA0ED,CAxEC,0BACC,iBAKD,CAHC,qCACC,cACD,CAIA,+CACC,uBAAwB,CACxB,oBAAqB,CACrB,iBAAkB,CAClB,wCAAyC,CACzC,yCAA0C,CAC1C,qBAAsB,CAGtB,QAAS,CAGT,UAAW,CACX,kBAAmB,CACnB,OAAQ,CACR,aA0CD,CAxCC,sDACC,aAAc,CACd,iBAAkB,CAClB,qBAAsB,CACtB,UAAW,CACX,UAAW,CACX,WAAY,CACZ,qBAAiC,CACjC,iBAAkB,CAClB,0FACD,CAEA,qDACC,aAAc,CACd,iBAAkB,CAClB,sBAAuB,CACvB,mBAAoB,CACpB,UAAW,CAGX,+CAAoD,CACpD,gDAAqD,CACrD,kDAAuD,CACvD,mDAAwD,CAGxD,+BAA+G,CAA/G,0EAA+G,CAA/G,yEAA+G,CAA/G,8BAA+G,CAC/G,uBACD,CAGC,+DACC,kBAA8B,CAC9B,oBACD,CAEA,8DACC,iBACD,CAIF,wEACC,qBACD,CAKF,6CACC,MAAO,CACP,cAAe,CACf,WAAY,CACZ,iBACD,CAMA,wDACC,cAKD,CAHC,qEACC,mCACD',
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-todo-list-checkmark-size: 16px;\n}\n\n.ck-content .todo-list {\n\tlist-style: none;\n\n\t& li {\n\t\tmargin-bottom: 5px;\n\n\t\t& .todo-list {\n\t\t\tmargin-top: 5px;\n\t\t}\n\t}\n\n\t& .todo-list__label {\n\t\t& > input {\n\t\t\t-webkit-appearance: none;\n\t\t\tdisplay: inline-block;\n\t\t\tposition: relative;\n\t\t\twidth: var(--ck-todo-list-checkmark-size);\n\t\t\theight: var(--ck-todo-list-checkmark-size);\n\t\t\tvertical-align: middle;\n\n\t\t\t/* Needed on iOS */\n\t\t\tborder: 0;\n\n\t\t\t/* LTR styles */\n\t\t\tleft: -25px;\n\t\t\tmargin-right: -15px;\n\t\t\tright: 0;\n\t\t\tmargin-left: 0;\n\n\t\t\t&::before {\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tbox-sizing: border-box;\n\t\t\t\tcontent: '';\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t\tborder: 1px solid hsl(0, 0%, 20%);\n\t\t\t\tborder-radius: 2px;\n\t\t\t\ttransition: 250ms ease-in-out box-shadow, 250ms ease-in-out background, 250ms ease-in-out border;\n\t\t\t}\n\n\t\t\t&::after {\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tbox-sizing: content-box;\n\t\t\t\tpointer-events: none;\n\t\t\t\tcontent: '';\n\n\t\t\t\t/* Calculate tick position, size and border-width proportional to the checkmark size. */\n\t\t\t\tleft: calc( var(--ck-todo-list-checkmark-size) / 3 );\n\t\t\t\ttop: calc( var(--ck-todo-list-checkmark-size) / 5.3 );\n\t\t\t\twidth: calc( var(--ck-todo-list-checkmark-size) / 5.3 );\n\t\t\t\theight: calc( var(--ck-todo-list-checkmark-size) / 2.6 );\n\t\t\t\tborder-style: solid;\n\t\t\t\tborder-color: transparent;\n\t\t\t\tborder-width: 0 calc( var(--ck-todo-list-checkmark-size) / 8 ) calc( var(--ck-todo-list-checkmark-size) / 8 ) 0;\n\t\t\t\ttransform: rotate(45deg);\n\t\t\t}\n\n\t\t\t&[checked] {\n\t\t\t\t&::before {\n\t\t\t\t\tbackground: hsl(126, 64%, 41%);\n\t\t\t\t\tborder-color: hsl(126, 64%, 41%);\n\t\t\t\t}\n\n\t\t\t\t&::after {\n\t\t\t\t\tborder-color: hsl(0, 0%, 100%);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t& .todo-list__label__description {\n\t\t\tvertical-align: middle;\n\t\t}\n\t}\n}\n\n/* RTL styles */\n[dir=\"rtl\"] .todo-list .todo-list__label > input {\n\tleft: 0;\n\tmargin-right: 0;\n\tright: -25px;\n\tmargin-left: -15px;\n}\n\n/*\n * To-do list should be interactive only during the editing\n * (https://github.com/ckeditor/ckeditor5/issues/2090).\n */\n.ck-editor__editable .todo-list .todo-list__label > input {\n\tcursor: pointer;\n\n\t&:hover::before {\n\t\tbox-shadow: 0 0 0 5px hsla(0, 0%, 0%, 0.1);\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ]),
          (e.a = s);
      },
      function (t, e) {
        var n;
        n = (function () {
          return this;
        })();
        try {
          n = n || new Function('return this')();
        } catch (t) {
          'object' == typeof window && (n = window);
        }
        t.exports = n;
      },
      function (t, e, n) {
        'use strict';
        e.a = function () {
          return !1;
        };
      },
      function (t, e, n) {
        'use strict';
        n.r(e);
        var o = function () {
          return function t() {
            t.called = !0;
          };
        };
        class i {
          constructor(t, e) {
            (this.source = t), (this.name = e), (this.path = []), (this.stop = o()), (this.off = o());
          }
        }
        const r = new Array(256).fill().map((t, e) => ('0' + e.toString(16)).slice(-2));
        function s() {
          const t = (4294967296 * Math.random()) >>> 0,
            e = (4294967296 * Math.random()) >>> 0,
            n = (4294967296 * Math.random()) >>> 0,
            o = (4294967296 * Math.random()) >>> 0;
          return (
            'e' +
            r[(t >> 0) & 255] +
            r[(t >> 8) & 255] +
            r[(t >> 16) & 255] +
            r[(t >> 24) & 255] +
            r[(e >> 0) & 255] +
            r[(e >> 8) & 255] +
            r[(e >> 16) & 255] +
            r[(e >> 24) & 255] +
            r[(n >> 0) & 255] +
            r[(n >> 8) & 255] +
            r[(n >> 16) & 255] +
            r[(n >> 24) & 255] +
            r[(o >> 0) & 255] +
            r[(o >> 8) & 255] +
            r[(o >> 16) & 255] +
            r[(o >> 24) & 255]
          );
        }
        var a = {
            get(t) {
              return 'number' != typeof t ? this[t] || this.normal : t;
            },
            highest: 1e5,
            high: 1e3,
            normal: 0,
            low: -1e3,
            lowest: -1e5,
          },
          c = (n(8), n(0));
        const l = Symbol('listeningTo'),
          d = Symbol('emitterId');
        var h = {
          on(t, e, n = {}) {
            this.listenTo(this, t, e, n);
          },
          once(t, e, n) {
            let o = !1;
            this.listenTo(
              this,
              t,
              function (t, ...n) {
                o || ((o = !0), t.off(), e.call(this, t, ...n));
              },
              n,
            );
          },
          off(t, e) {
            this.stopListening(this, t, e);
          },
          listenTo(t, e, n, o = {}) {
            let i, r;
            this[l] || (this[l] = {});
            const s = this[l];
            p(t) || u(t);
            const a = p(t);
            (i = s[a]) || (i = s[a] = { emitter: t, callbacks: {} }),
              (r = i.callbacks[e]) || (r = i.callbacks[e] = []),
              r.push(n),
              (function (t, e, n, o, i) {
                e._addEventListener ? e._addEventListener(n, o, i) : t._addEventListener.call(e, n, o, i);
              })(this, t, e, n, o);
          },
          stopListening(t, e, n) {
            const o = this[l];
            let i = t && p(t);
            const r = o && i && o[i],
              s = r && e && r.callbacks[e];
            if (!(!o || (t && !r) || (e && !s)))
              if (n) {
                b(this, t, e, n);
                -1 !== s.indexOf(n) && (1 === s.length ? delete r.callbacks[e] : b(this, t, e, n));
              } else if (s) {
                for (; (n = s.pop()); ) b(this, t, e, n);
                delete r.callbacks[e];
              } else if (r) {
                for (e in r.callbacks) this.stopListening(t, e);
                delete o[i];
              } else {
                for (i in o) this.stopListening(o[i].emitter);
                delete this[l];
              }
          },
          fire(t, ...e) {
            try {
              const n = t instanceof i ? t : new i(this, t),
                o = n.name;
              let r = f(this, o);
              if ((n.path.push(this), r)) {
                const t = [n, ...e];
                r = Array.from(r);
                for (
                  let e = 0;
                  e < r.length &&
                  (r[e].callback.apply(this, t),
                  n.off.called && (delete n.off.called, this._removeEventListener(o, r[e].callback)),
                  !n.stop.called);
                  e++
                );
              }
              if (this._delegations) {
                const t = this._delegations.get(o),
                  i = this._delegations.get('*');
                t && k(t, n, e), i && k(i, n, e);
              }
              return n.return;
            } catch (t) {
              c.a.rethrowUnexpectedError(t, this);
            }
          },
          delegate(...t) {
            return {
              to: (e, n) => {
                this._delegations || (this._delegations = new Map()),
                  t.forEach(t => {
                    const o = this._delegations.get(t);
                    o ? o.set(e, n) : this._delegations.set(t, new Map([[e, n]]));
                  });
              },
            };
          },
          stopDelegating(t, e) {
            if (this._delegations)
              if (t)
                if (e) {
                  const n = this._delegations.get(t);
                  n && n.delete(e);
                } else this._delegations.delete(t);
              else this._delegations.clear();
          },
          _addEventListener(t, e, n) {
            !(function (t, e) {
              const n = m(t);
              if (n[e]) return;
              let o = e,
                i = null;
              const r = [];
              for (; '' !== o && !n[o]; )
                (n[o] = { callbacks: [], childEvents: [] }),
                  r.push(n[o]),
                  i && n[o].childEvents.push(i),
                  (i = o),
                  (o = o.substr(0, o.lastIndexOf(':')));
              if ('' !== o) {
                for (const t of r) t.callbacks = n[o].callbacks.slice();
                n[o].childEvents.push(i);
              }
            })(this, t);
            const o = g(this, t),
              i = a.get(n.priority),
              r = { callback: e, priority: i };
            for (const t of o) {
              let e = !1;
              for (let n = 0; n < t.length; n++)
                if (t[n].priority < i) {
                  t.splice(n, 0, r), (e = !0);
                  break;
                }
              e || t.push(r);
            }
          },
          _removeEventListener(t, e) {
            const n = g(this, t);
            for (const t of n) for (let n = 0; n < t.length; n++) t[n].callback == e && (t.splice(n, 1), n--);
          },
        };
        function u(t, e) {
          t[d] || (t[d] = e || s());
        }
        function p(t) {
          return t[d];
        }
        function m(t) {
          return t._events || Object.defineProperty(t, '_events', { value: {} }), t._events;
        }
        function g(t, e) {
          const n = m(t)[e];
          if (!n) return [];
          let o = [n.callbacks];
          for (let e = 0; e < n.childEvents.length; e++) {
            const i = g(t, n.childEvents[e]);
            o = o.concat(i);
          }
          return o;
        }
        function f(t, e) {
          let n;
          return t._events && (n = t._events[e]) && n.callbacks.length
            ? n.callbacks
            : e.indexOf(':') > -1
            ? f(t, e.substr(0, e.lastIndexOf(':')))
            : null;
        }
        function k(t, e, n) {
          for (let [o, r] of t) {
            r ? 'function' == typeof r && (r = r(e.name)) : (r = e.name);
            const t = new i(e.source, r);
            (t.path = [...e.path]), o.fire(t, ...n);
          }
        }
        function b(t, e, n, o) {
          e._removeEventListener ? e._removeEventListener(n, o) : t._removeEventListener.call(e, n, o);
        }
        var w = function (t) {
            var e = typeof t;
            return null != t && ('object' == e || 'function' == e);
          },
          A = n(5),
          _ = A.a.Symbol,
          C = Object.prototype,
          v = C.hasOwnProperty,
          y = C.toString,
          x = _ ? _.toStringTag : void 0;
        var E = function (t) {
            var e = v.call(t, x),
              n = t[x];
            try {
              t[x] = void 0;
              var o = !0;
            } catch (t) {}
            var i = y.call(t);
            return o && (e ? (t[x] = n) : delete t[x]), i;
          },
          D = Object.prototype.toString;
        var S = function (t) {
            return D.call(t);
          },
          B = _ ? _.toStringTag : void 0;
        var T = function (t) {
          return null == t
            ? void 0 === t
              ? '[object Undefined]'
              : '[object Null]'
            : B && B in Object(t)
            ? E(t)
            : S(t);
        };
        var P,
          I = function (t) {
            if (!w(t)) return !1;
            var e = T(t);
            return (
              '[object Function]' == e ||
              '[object GeneratorFunction]' == e ||
              '[object AsyncFunction]' == e ||
              '[object Proxy]' == e
            );
          },
          z = A.a['__core-js_shared__'],
          F = (P = /[^.]+$/.exec((z && z.keys && z.keys.IE_PROTO) || '')) ? 'Symbol(src)_1.' + P : '';
        var R = function (t) {
            return !!F && F in t;
          },
          O = Function.prototype.toString;
        var M = function (t) {
            if (null != t) {
              try {
                return O.call(t);
              } catch (t) {}
              try {
                return t + '';
              } catch (t) {}
            }
            return '';
          },
          N = /^\[object .+?Constructor\]$/,
          V = Function.prototype,
          L = Object.prototype,
          K = V.toString,
          q = L.hasOwnProperty,
          H = RegExp(
            '^' +
              K.call(q)
                .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
              '$',
          );
        var j = function (t) {
          return !(!w(t) || R(t)) && (I(t) ? H : N).test(M(t));
        };
        var $ = function (t, e) {
          return null == t ? void 0 : t[e];
        };
        var G = function (t, e) {
            var n = $(t, e);
            return j(n) ? n : void 0;
          },
          W = (function () {
            try {
              var t = G(Object, 'defineProperty');
              return t({}, '', {}), t;
            } catch (t) {}
          })();
        var U = function (t, e, n) {
          '__proto__' == e && W ? W(t, e, { configurable: !0, enumerable: !0, value: n, writable: !0 }) : (t[e] = n);
        };
        var J = function (t, e) {
            return t === e || (t != t && e != e);
          },
          Y = Object.prototype.hasOwnProperty;
        var Q = function (t, e, n) {
          var o = t[e];
          (Y.call(t, e) && J(o, n) && (void 0 !== n || e in t)) || U(t, e, n);
        };
        var X = function (t, e, n, o) {
          var i = !n;
          n || (n = {});
          for (var r = -1, s = e.length; ++r < s; ) {
            var a = e[r],
              c = o ? o(n[a], t[a], a, n, t) : void 0;
            void 0 === c && (c = t[a]), i ? U(n, a, c) : Q(n, a, c);
          }
          return n;
        };
        var Z = function (t) {
          return t;
        };
        var tt = function (t, e, n) {
            switch (n.length) {
              case 0:
                return t.call(e);
              case 1:
                return t.call(e, n[0]);
              case 2:
                return t.call(e, n[0], n[1]);
              case 3:
                return t.call(e, n[0], n[1], n[2]);
            }
            return t.apply(e, n);
          },
          et = Math.max;
        var nt = function (t, e, n) {
          return (
            (e = et(void 0 === e ? t.length - 1 : e, 0)),
            function () {
              for (var o = arguments, i = -1, r = et(o.length - e, 0), s = Array(r); ++i < r; ) s[i] = o[e + i];
              i = -1;
              for (var a = Array(e + 1); ++i < e; ) a[i] = o[i];
              return (a[e] = n(s)), tt(t, this, a);
            }
          );
        };
        var ot = function (t) {
            return function () {
              return t;
            };
          },
          it = W
            ? function (t, e) {
                return W(t, 'toString', { configurable: !0, enumerable: !1, value: ot(e), writable: !0 });
              }
            : Z,
          rt = Date.now;
        var st = (function (t) {
          var e = 0,
            n = 0;
          return function () {
            var o = rt(),
              i = 16 - (o - n);
            if (((n = o), i > 0)) {
              if (++e >= 800) return arguments[0];
            } else e = 0;
            return t.apply(void 0, arguments);
          };
        })(it);
        var at = function (t, e) {
          return st(nt(t, e, Z), t + '');
        };
        var ct = function (t) {
          return 'number' == typeof t && t > -1 && t % 1 == 0 && t <= 9007199254740991;
        };
        var lt = function (t) {
            return null != t && ct(t.length) && !I(t);
          },
          dt = /^(?:0|[1-9]\d*)$/;
        var ht = function (t, e) {
          var n = typeof t;
          return (
            !!(e = null == e ? 9007199254740991 : e) &&
            ('number' == n || ('symbol' != n && dt.test(t))) &&
            t > -1 &&
            t % 1 == 0 &&
            t < e
          );
        };
        var ut = function (t, e, n) {
          if (!w(n)) return !1;
          var o = typeof e;
          return !!('number' == o ? lt(n) && ht(e, n.length) : 'string' == o && e in n) && J(n[e], t);
        };
        var pt = function (t) {
          return at(function (e, n) {
            var o = -1,
              i = n.length,
              r = i > 1 ? n[i - 1] : void 0,
              s = i > 2 ? n[2] : void 0;
            for (
              r = t.length > 3 && 'function' == typeof r ? (i--, r) : void 0,
                s && ut(n[0], n[1], s) && ((r = i < 3 ? void 0 : r), (i = 1)),
                e = Object(e);
              ++o < i;

            ) {
              var a = n[o];
              a && t(e, a, o, r);
            }
            return e;
          });
        };
        var mt = function (t, e) {
          for (var n = -1, o = Array(t); ++n < t; ) o[n] = e(n);
          return o;
        };
        var gt = function (t) {
          return null != t && 'object' == typeof t;
        };
        var ft = function (t) {
            return gt(t) && '[object Arguments]' == T(t);
          },
          kt = Object.prototype,
          bt = kt.hasOwnProperty,
          wt = kt.propertyIsEnumerable,
          At = ft(
            (function () {
              return arguments;
            })(),
          )
            ? ft
            : function (t) {
                return gt(t) && bt.call(t, 'callee') && !wt.call(t, 'callee');
              },
          _t = Array.isArray,
          Ct = n(6),
          vt = {};
        (vt['[object Float32Array]'] =
          vt['[object Float64Array]'] =
          vt['[object Int8Array]'] =
          vt['[object Int16Array]'] =
          vt['[object Int32Array]'] =
          vt['[object Uint8Array]'] =
          vt['[object Uint8ClampedArray]'] =
          vt['[object Uint16Array]'] =
          vt['[object Uint32Array]'] =
            !0),
          (vt['[object Arguments]'] =
            vt['[object Array]'] =
            vt['[object ArrayBuffer]'] =
            vt['[object Boolean]'] =
            vt['[object DataView]'] =
            vt['[object Date]'] =
            vt['[object Error]'] =
            vt['[object Function]'] =
            vt['[object Map]'] =
            vt['[object Number]'] =
            vt['[object Object]'] =
            vt['[object RegExp]'] =
            vt['[object Set]'] =
            vt['[object String]'] =
            vt['[object WeakMap]'] =
              !1);
        var yt = function (t) {
          return gt(t) && ct(t.length) && !!vt[T(t)];
        };
        var xt = function (t) {
            return function (e) {
              return t(e);
            };
          },
          Et = n(7),
          Dt = Et.a && Et.a.isTypedArray,
          St = Dt ? xt(Dt) : yt,
          Bt = Object.prototype.hasOwnProperty;
        var Tt = function (t, e) {
            var n = _t(t),
              o = !n && At(t),
              i = !n && !o && Object(Ct.a)(t),
              r = !n && !o && !i && St(t),
              s = n || o || i || r,
              a = s ? mt(t.length, String) : [],
              c = a.length;
            for (var l in t)
              (!e && !Bt.call(t, l)) ||
                (s &&
                  ('length' == l ||
                    (i && ('offset' == l || 'parent' == l)) ||
                    (r && ('buffer' == l || 'byteLength' == l || 'byteOffset' == l)) ||
                    ht(l, c))) ||
                a.push(l);
            return a;
          },
          Pt = Object.prototype;
        var It = function (t) {
          var e = t && t.constructor;
          return t === (('function' == typeof e && e.prototype) || Pt);
        };
        var zt = function (t) {
            var e = [];
            if (null != t) for (var n in Object(t)) e.push(n);
            return e;
          },
          Ft = Object.prototype.hasOwnProperty;
        var Rt = function (t) {
          if (!w(t)) return zt(t);
          var e = It(t),
            n = [];
          for (var o in t) ('constructor' != o || (!e && Ft.call(t, o))) && n.push(o);
          return n;
        };
        var Ot = function (t) {
            return lt(t) ? Tt(t, !0) : Rt(t);
          },
          Mt = pt(function (t, e) {
            X(e, Ot(e), t);
          });
        const Nt = Symbol('observableProperties'),
          Vt = Symbol('boundObservables'),
          Lt = Symbol('boundProperties'),
          Kt = Symbol('decoratedMethods'),
          qt = Symbol('decoratedOriginal'),
          Ht = {
            set(t, e) {
              if (w(t))
                return void Object.keys(t).forEach(e => {
                  this.set(e, t[e]);
                }, this);
              $t(this);
              const n = this[Nt];
              if (t in this && !n.has(t)) throw new c.a('observable-set-cannot-override', this);
              Object.defineProperty(this, t, {
                enumerable: !0,
                configurable: !0,
                get: () => n.get(t),
                set(e) {
                  const o = n.get(t);
                  let i = this.fire('set:' + t, t, e, o);
                  void 0 === i && (i = e), (o === i && n.has(t)) || (n.set(t, i), this.fire('change:' + t, t, i, o));
                },
              }),
                (this[t] = e);
            },
            bind(...t) {
              if (!t.length || !Ut(t)) throw new c.a('observable-bind-wrong-properties', this);
              if (new Set(t).size !== t.length) throw new c.a('observable-bind-duplicate-properties', this);
              $t(this);
              const e = this[Lt];
              t.forEach(t => {
                if (e.has(t)) throw new c.a('observable-bind-rebind', this);
              });
              const n = new Map();
              return (
                t.forEach(t => {
                  const o = { property: t, to: [] };
                  e.set(t, o), n.set(t, o);
                }),
                { to: Gt, toMany: Wt, _observable: this, _bindProperties: t, _to: [], _bindings: n }
              );
            },
            unbind(...t) {
              if (!this[Nt]) return;
              const e = this[Lt],
                n = this[Vt];
              if (t.length) {
                if (!Ut(t)) throw new c.a('observable-unbind-wrong-properties', this);
                t.forEach(t => {
                  const o = e.get(t);
                  if (!o) return;
                  let i, r, s, a;
                  o.to.forEach(t => {
                    (i = t[0]),
                      (r = t[1]),
                      (s = n.get(i)),
                      (a = s[r]),
                      a.delete(o),
                      a.size || delete s[r],
                      Object.keys(s).length || (n.delete(i), this.stopListening(i, 'change'));
                  }),
                    e.delete(t);
                });
              } else
                n.forEach((t, e) => {
                  this.stopListening(e, 'change');
                }),
                  n.clear(),
                  e.clear();
            },
            decorate(t) {
              const e = this[t];
              if (!e) throw new c.a('observablemixin-cannot-decorate-undefined', this, { object: this, methodName: t });
              this.on(t, (t, n) => {
                t.return = e.apply(this, n);
              }),
                (this[t] = function (...e) {
                  return this.fire(t, e);
                }),
                (this[t][qt] = e),
                this[Kt] || (this[Kt] = []),
                this[Kt].push(t);
            },
          };
        Mt(Ht, h),
          (Ht.stopListening = function (t, e, n) {
            if (!t && this[Kt]) {
              for (const t of this[Kt]) this[t] = this[t][qt];
              delete this[Kt];
            }
            h.stopListening.call(this, t, e, n);
          });
        var jt = Ht;
        function $t(t) {
          t[Nt] ||
            (Object.defineProperty(t, Nt, { value: new Map() }),
            Object.defineProperty(t, Vt, { value: new Map() }),
            Object.defineProperty(t, Lt, { value: new Map() }));
        }
        function Gt(...t) {
          const e = (function (...t) {
              if (!t.length) throw new c.a('observable-bind-to-parse-error', null);
              const e = { to: [] };
              let n;
              'function' == typeof t[t.length - 1] && (e.callback = t.pop());
              return (
                t.forEach(t => {
                  if ('string' == typeof t) n.properties.push(t);
                  else {
                    if ('object' != typeof t) throw new c.a('observable-bind-to-parse-error', null);
                    (n = { observable: t, properties: [] }), e.to.push(n);
                  }
                }),
                e
              );
            })(...t),
            n = Array.from(this._bindings.keys()),
            o = n.length;
          if (!e.callback && e.to.length > 1) throw new c.a('observable-bind-to-no-callback', this);
          if (o > 1 && e.callback) throw new c.a('observable-bind-to-extra-callback', this);
          var i;
          e.to.forEach(t => {
            if (t.properties.length && t.properties.length !== o)
              throw new c.a('observable-bind-to-properties-length', this);
            t.properties.length || (t.properties = this._bindProperties);
          }),
            (this._to = e.to),
            e.callback && (this._bindings.get(n[0]).callback = e.callback),
            (i = this._observable),
            this._to.forEach(t => {
              const e = i[Vt];
              let n;
              e.get(t.observable) ||
                i.listenTo(t.observable, 'change', (o, r) => {
                  (n = e.get(t.observable)[r]),
                    n &&
                      n.forEach(t => {
                        Jt(i, t.property);
                      });
                });
            }),
            (function (t) {
              let e;
              t._bindings.forEach((n, o) => {
                t._to.forEach(i => {
                  (e = i.properties[n.callback ? 0 : t._bindProperties.indexOf(o)]),
                    n.to.push([i.observable, e]),
                    (function (t, e, n, o) {
                      const i = t[Vt],
                        r = i.get(n),
                        s = r || {};
                      s[o] || (s[o] = new Set());
                      s[o].add(e), r || i.set(n, s);
                    })(t._observable, n, i.observable, e);
                });
              });
            })(this),
            this._bindProperties.forEach(t => {
              Jt(this._observable, t);
            });
        }
        function Wt(t, e, n) {
          if (this._bindings.size > 1) throw new c.a('observable-bind-to-many-not-one-binding', this);
          this.to(
            ...(function (t, e) {
              const n = t.map(t => [t, e]);
              return Array.prototype.concat.apply([], n);
            })(t, e),
            n,
          );
        }
        function Ut(t) {
          return t.every(t => 'string' == typeof t);
        }
        function Jt(t, e) {
          const n = t[Lt].get(e);
          let o;
          n.callback
            ? (o = n.callback.apply(
                t,
                n.to.map(t => t[0][t[1]]),
              ))
            : ((o = n.to[0]), (o = o[0][o[1]])),
            Object.prototype.hasOwnProperty.call(t, e) ? (t[e] = o) : t.set(e, o);
        }
        function Yt(t, ...e) {
          e.forEach(e => {
            Object.getOwnPropertyNames(e)
              .concat(Object.getOwnPropertySymbols(e))
              .forEach(n => {
                if (n in t.prototype) return;
                const o = Object.getOwnPropertyDescriptor(e, n);
                (o.enumerable = !1), Object.defineProperty(t.prototype, n, o);
              });
          });
        }
        class Qt {
          constructor(t) {
            (this.editor = t), this.set('isEnabled', !0), (this._disableStack = new Set());
          }
          forceDisabled(t) {
            this._disableStack.add(t),
              1 == this._disableStack.size &&
                (this.on('set:isEnabled', Xt, { priority: 'highest' }), (this.isEnabled = !1));
          }
          clearForceDisabled(t) {
            this._disableStack.delete(t),
              0 == this._disableStack.size && (this.off('set:isEnabled', Xt), (this.isEnabled = !0));
          }
          destroy() {
            this.stopListening();
          }
          static get isContextPlugin() {
            return !1;
          }
        }
        function Xt(t) {
          (t.return = !1), t.stop();
        }
        Yt(Qt, jt);
        class Zt {
          constructor(t) {
            (this.editor = t),
              this.set('value', void 0),
              this.set('isEnabled', !1),
              (this._disableStack = new Set()),
              this.decorate('execute'),
              this.listenTo(this.editor.model.document, 'change', () => {
                this.refresh();
              }),
              this.on(
                'execute',
                t => {
                  this.isEnabled || t.stop();
                },
                { priority: 'high' },
              ),
              this.listenTo(t, 'change:isReadOnly', (t, e, n) => {
                n ? this.forceDisabled('readOnlyMode') : this.clearForceDisabled('readOnlyMode');
              });
          }
          refresh() {
            this.isEnabled = !0;
          }
          forceDisabled(t) {
            this._disableStack.add(t),
              1 == this._disableStack.size &&
                (this.on('set:isEnabled', te, { priority: 'highest' }), (this.isEnabled = !1));
          }
          clearForceDisabled(t) {
            this._disableStack.delete(t),
              0 == this._disableStack.size && (this.off('set:isEnabled', te), this.refresh());
          }
          execute() {}
          destroy() {
            this.stopListening();
          }
        }
        function te(t) {
          (t.return = !1), t.stop();
        }
        Yt(Zt, jt);
        class ee extends Zt {
          constructor(t) {
            super(t), (this._childCommands = []);
          }
          refresh() {}
          execute(...t) {
            const e = this._getFirstEnabledCommand();
            return null != e && e.execute(t);
          }
          registerChildCommand(t) {
            this._childCommands.push(t), t.on('change:isEnabled', () => this._checkEnabled()), this._checkEnabled();
          }
          _checkEnabled() {
            this.isEnabled = !!this._getFirstEnabledCommand();
          }
          _getFirstEnabledCommand() {
            return this._childCommands.find(t => t.isEnabled);
          }
        }
        var ne = function (t, e) {
            return function (n) {
              return t(e(n));
            };
          },
          oe = ne(Object.getPrototypeOf, Object),
          ie = Function.prototype,
          re = Object.prototype,
          se = ie.toString,
          ae = re.hasOwnProperty,
          ce = se.call(Object);
        var le = function (t) {
          if (!gt(t) || '[object Object]' != T(t)) return !1;
          var e = oe(t);
          if (null === e) return !0;
          var n = ae.call(e, 'constructor') && e.constructor;
          return 'function' == typeof n && n instanceof n && se.call(n) == ce;
        };
        var de = function () {
          (this.__data__ = []), (this.size = 0);
        };
        var he = function (t, e) {
            for (var n = t.length; n--; ) if (J(t[n][0], e)) return n;
            return -1;
          },
          ue = Array.prototype.splice;
        var pe = function (t) {
          var e = this.__data__,
            n = he(e, t);
          return !(n < 0) && (n == e.length - 1 ? e.pop() : ue.call(e, n, 1), --this.size, !0);
        };
        var me = function (t) {
          var e = this.__data__,
            n = he(e, t);
          return n < 0 ? void 0 : e[n][1];
        };
        var ge = function (t) {
          return he(this.__data__, t) > -1;
        };
        var fe = function (t, e) {
          var n = this.__data__,
            o = he(n, t);
          return o < 0 ? (++this.size, n.push([t, e])) : (n[o][1] = e), this;
        };
        function ke(t) {
          var e = -1,
            n = null == t ? 0 : t.length;
          for (this.clear(); ++e < n; ) {
            var o = t[e];
            this.set(o[0], o[1]);
          }
        }
        (ke.prototype.clear = de),
          (ke.prototype.delete = pe),
          (ke.prototype.get = me),
          (ke.prototype.has = ge),
          (ke.prototype.set = fe);
        var be = ke;
        var we = function () {
          (this.__data__ = new be()), (this.size = 0);
        };
        var Ae = function (t) {
          var e = this.__data__,
            n = e.delete(t);
          return (this.size = e.size), n;
        };
        var _e = function (t) {
          return this.__data__.get(t);
        };
        var Ce = function (t) {
            return this.__data__.has(t);
          },
          ve = G(A.a, 'Map'),
          ye = G(Object, 'create');
        var xe = function () {
          (this.__data__ = ye ? ye(null) : {}), (this.size = 0);
        };
        var Ee = function (t) {
            var e = this.has(t) && delete this.__data__[t];
            return (this.size -= e ? 1 : 0), e;
          },
          De = Object.prototype.hasOwnProperty;
        var Se = function (t) {
            var e = this.__data__;
            if (ye) {
              var n = e[t];
              return '__lodash_hash_undefined__' === n ? void 0 : n;
            }
            return De.call(e, t) ? e[t] : void 0;
          },
          Be = Object.prototype.hasOwnProperty;
        var Te = function (t) {
          var e = this.__data__;
          return ye ? void 0 !== e[t] : Be.call(e, t);
        };
        var Pe = function (t, e) {
          var n = this.__data__;
          return (
            (this.size += this.has(t) ? 0 : 1), (n[t] = ye && void 0 === e ? '__lodash_hash_undefined__' : e), this
          );
        };
        function Ie(t) {
          var e = -1,
            n = null == t ? 0 : t.length;
          for (this.clear(); ++e < n; ) {
            var o = t[e];
            this.set(o[0], o[1]);
          }
        }
        (Ie.prototype.clear = xe),
          (Ie.prototype.delete = Ee),
          (Ie.prototype.get = Se),
          (Ie.prototype.has = Te),
          (Ie.prototype.set = Pe);
        var ze = Ie;
        var Fe = function () {
          (this.size = 0), (this.__data__ = { hash: new ze(), map: new (ve || be)(), string: new ze() });
        };
        var Re = function (t) {
          var e = typeof t;
          return 'string' == e || 'number' == e || 'symbol' == e || 'boolean' == e ? '__proto__' !== t : null === t;
        };
        var Oe = function (t, e) {
          var n = t.__data__;
          return Re(e) ? n['string' == typeof e ? 'string' : 'hash'] : n.map;
        };
        var Me = function (t) {
          var e = Oe(this, t).delete(t);
          return (this.size -= e ? 1 : 0), e;
        };
        var Ne = function (t) {
          return Oe(this, t).get(t);
        };
        var Ve = function (t) {
          return Oe(this, t).has(t);
        };
        var Le = function (t, e) {
          var n = Oe(this, t),
            o = n.size;
          return n.set(t, e), (this.size += n.size == o ? 0 : 1), this;
        };
        function Ke(t) {
          var e = -1,
            n = null == t ? 0 : t.length;
          for (this.clear(); ++e < n; ) {
            var o = t[e];
            this.set(o[0], o[1]);
          }
        }
        (Ke.prototype.clear = Fe),
          (Ke.prototype.delete = Me),
          (Ke.prototype.get = Ne),
          (Ke.prototype.has = Ve),
          (Ke.prototype.set = Le);
        var qe = Ke;
        var He = function (t, e) {
          var n = this.__data__;
          if (n instanceof be) {
            var o = n.__data__;
            if (!ve || o.length < 199) return o.push([t, e]), (this.size = ++n.size), this;
            n = this.__data__ = new qe(o);
          }
          return n.set(t, e), (this.size = n.size), this;
        };
        function je(t) {
          var e = (this.__data__ = new be(t));
          this.size = e.size;
        }
        (je.prototype.clear = we),
          (je.prototype.delete = Ae),
          (je.prototype.get = _e),
          (je.prototype.has = Ce),
          (je.prototype.set = He);
        var $e = je;
        var Ge = function (t, e) {
            for (var n = -1, o = null == t ? 0 : t.length; ++n < o && !1 !== e(t[n], n, t); );
            return t;
          },
          We = ne(Object.keys, Object),
          Ue = Object.prototype.hasOwnProperty;
        var Je = function (t) {
          if (!It(t)) return We(t);
          var e = [];
          for (var n in Object(t)) Ue.call(t, n) && 'constructor' != n && e.push(n);
          return e;
        };
        var Ye = function (t) {
          return lt(t) ? Tt(t) : Je(t);
        };
        var Qe = function (t, e) {
          return t && X(e, Ye(e), t);
        };
        var Xe = function (t, e) {
            return t && X(e, Ot(e), t);
          },
          Ze = n(10);
        var tn = function (t, e) {
          var n = -1,
            o = t.length;
          for (e || (e = Array(o)); ++n < o; ) e[n] = t[n];
          return e;
        };
        var en = function (t, e) {
          for (var n = -1, o = null == t ? 0 : t.length, i = 0, r = []; ++n < o; ) {
            var s = t[n];
            e(s, n, t) && (r[i++] = s);
          }
          return r;
        };
        var nn = function () {
            return [];
          },
          on = Object.prototype.propertyIsEnumerable,
          rn = Object.getOwnPropertySymbols,
          sn = rn
            ? function (t) {
                return null == t
                  ? []
                  : ((t = Object(t)),
                    en(rn(t), function (e) {
                      return on.call(t, e);
                    }));
              }
            : nn;
        var an = function (t, e) {
          return X(t, sn(t), e);
        };
        var cn = function (t, e) {
            for (var n = -1, o = e.length, i = t.length; ++n < o; ) t[i + n] = e[n];
            return t;
          },
          ln = Object.getOwnPropertySymbols
            ? function (t) {
                for (var e = []; t; ) cn(e, sn(t)), (t = oe(t));
                return e;
              }
            : nn;
        var dn = function (t, e) {
          return X(t, ln(t), e);
        };
        var hn = function (t, e, n) {
          var o = e(t);
          return _t(t) ? o : cn(o, n(t));
        };
        var un = function (t) {
          return hn(t, Ye, sn);
        };
        var pn = function (t) {
            return hn(t, Ot, ln);
          },
          mn = G(A.a, 'DataView'),
          gn = G(A.a, 'Promise'),
          fn = G(A.a, 'Set'),
          kn = G(A.a, 'WeakMap'),
          bn = '[object Map]',
          wn = '[object Promise]',
          An = '[object Set]',
          _n = '[object WeakMap]',
          Cn = '[object DataView]',
          vn = M(mn),
          yn = M(ve),
          xn = M(gn),
          En = M(fn),
          Dn = M(kn),
          Sn = T;
        ((mn && Sn(new mn(new ArrayBuffer(1))) != Cn) ||
          (ve && Sn(new ve()) != bn) ||
          (gn && Sn(gn.resolve()) != wn) ||
          (fn && Sn(new fn()) != An) ||
          (kn && Sn(new kn()) != _n)) &&
          (Sn = function (t) {
            var e = T(t),
              n = '[object Object]' == e ? t.constructor : void 0,
              o = n ? M(n) : '';
            if (o)
              switch (o) {
                case vn:
                  return Cn;
                case yn:
                  return bn;
                case xn:
                  return wn;
                case En:
                  return An;
                case Dn:
                  return _n;
              }
            return e;
          });
        var Bn = Sn,
          Tn = Object.prototype.hasOwnProperty;
        var Pn = function (t) {
            var e = t.length,
              n = new t.constructor(e);
            return e && 'string' == typeof t[0] && Tn.call(t, 'index') && ((n.index = t.index), (n.input = t.input)), n;
          },
          In = A.a.Uint8Array;
        var zn = function (t) {
          var e = new t.constructor(t.byteLength);
          return new In(e).set(new In(t)), e;
        };
        var Fn = function (t, e) {
            var n = e ? zn(t.buffer) : t.buffer;
            return new t.constructor(n, t.byteOffset, t.byteLength);
          },
          Rn = /\w*$/;
        var On = function (t) {
            var e = new t.constructor(t.source, Rn.exec(t));
            return (e.lastIndex = t.lastIndex), e;
          },
          Mn = _ ? _.prototype : void 0,
          Nn = Mn ? Mn.valueOf : void 0;
        var Vn = function (t) {
          return Nn ? Object(Nn.call(t)) : {};
        };
        var Ln = function (t, e) {
          var n = e ? zn(t.buffer) : t.buffer;
          return new t.constructor(n, t.byteOffset, t.length);
        };
        var Kn = function (t, e, n) {
            var o = t.constructor;
            switch (e) {
              case '[object ArrayBuffer]':
                return zn(t);
              case '[object Boolean]':
              case '[object Date]':
                return new o(+t);
              case '[object DataView]':
                return Fn(t, n);
              case '[object Float32Array]':
              case '[object Float64Array]':
              case '[object Int8Array]':
              case '[object Int16Array]':
              case '[object Int32Array]':
              case '[object Uint8Array]':
              case '[object Uint8ClampedArray]':
              case '[object Uint16Array]':
              case '[object Uint32Array]':
                return Ln(t, n);
              case '[object Map]':
                return new o();
              case '[object Number]':
              case '[object String]':
                return new o(t);
              case '[object RegExp]':
                return On(t);
              case '[object Set]':
                return new o();
              case '[object Symbol]':
                return Vn(t);
            }
          },
          qn = Object.create,
          Hn = (function () {
            function t() {}
            return function (e) {
              if (!w(e)) return {};
              if (qn) return qn(e);
              t.prototype = e;
              var n = new t();
              return (t.prototype = void 0), n;
            };
          })();
        var jn = function (t) {
          return 'function' != typeof t.constructor || It(t) ? {} : Hn(oe(t));
        };
        var $n = function (t) {
            return gt(t) && '[object Map]' == Bn(t);
          },
          Gn = Et.a && Et.a.isMap,
          Wn = Gn ? xt(Gn) : $n;
        var Un = function (t) {
            return gt(t) && '[object Set]' == Bn(t);
          },
          Jn = Et.a && Et.a.isSet,
          Yn = Jn ? xt(Jn) : Un,
          Qn = '[object Arguments]',
          Xn = '[object Function]',
          Zn = '[object Object]',
          to = {};
        (to[Qn] =
          to['[object Array]'] =
          to['[object ArrayBuffer]'] =
          to['[object DataView]'] =
          to['[object Boolean]'] =
          to['[object Date]'] =
          to['[object Float32Array]'] =
          to['[object Float64Array]'] =
          to['[object Int8Array]'] =
          to['[object Int16Array]'] =
          to['[object Int32Array]'] =
          to['[object Map]'] =
          to['[object Number]'] =
          to['[object Object]'] =
          to['[object RegExp]'] =
          to['[object Set]'] =
          to['[object String]'] =
          to['[object Symbol]'] =
          to['[object Uint8Array]'] =
          to['[object Uint8ClampedArray]'] =
          to['[object Uint16Array]'] =
          to['[object Uint32Array]'] =
            !0),
          (to['[object Error]'] = to[Xn] = to['[object WeakMap]'] = !1);
        var eo = function t(e, n, o, i, r, s) {
          var a,
            c = 1 & n,
            l = 2 & n,
            d = 4 & n;
          if ((o && (a = r ? o(e, i, r, s) : o(e)), void 0 !== a)) return a;
          if (!w(e)) return e;
          var h = _t(e);
          if (h) {
            if (((a = Pn(e)), !c)) return tn(e, a);
          } else {
            var u = Bn(e),
              p = u == Xn || '[object GeneratorFunction]' == u;
            if (Object(Ct.a)(e)) return Object(Ze.a)(e, c);
            if (u == Zn || u == Qn || (p && !r)) {
              if (((a = l || p ? {} : jn(e)), !c)) return l ? dn(e, Xe(a, e)) : an(e, Qe(a, e));
            } else {
              if (!to[u]) return r ? e : {};
              a = Kn(e, u, c);
            }
          }
          s || (s = new $e());
          var m = s.get(e);
          if (m) return m;
          s.set(e, a),
            Yn(e)
              ? e.forEach(function (i) {
                  a.add(t(i, n, o, i, e, s));
                })
              : Wn(e) &&
                e.forEach(function (i, r) {
                  a.set(r, t(i, n, o, r, e, s));
                });
          var g = h ? void 0 : (d ? (l ? pn : un) : l ? Ot : Ye)(e);
          return (
            Ge(g || e, function (i, r) {
              g && (i = e[(r = i)]), Q(a, r, t(i, n, o, r, e, s));
            }),
            a
          );
        };
        var no = function (t, e) {
          return eo(t, 5, (e = 'function' == typeof e ? e : void 0));
        };
        var oo = function (t) {
          return gt(t) && 1 === t.nodeType && !le(t);
        };
        class io {
          constructor(t, e) {
            (this._config = {}), e && this.define(ro(e)), t && this._setObjectToTarget(this._config, t);
          }
          set(t, e) {
            this._setToTarget(this._config, t, e);
          }
          define(t, e) {
            this._setToTarget(this._config, t, e, !0);
          }
          get(t) {
            return this._getFromSource(this._config, t);
          }
          *names() {
            for (const t of Object.keys(this._config)) yield t;
          }
          _setToTarget(t, e, n, o = !1) {
            if (le(e)) return void this._setObjectToTarget(t, e, o);
            const i = e.split('.');
            e = i.pop();
            for (const e of i) le(t[e]) || (t[e] = {}), (t = t[e]);
            if (le(n)) return le(t[e]) || (t[e] = {}), (t = t[e]), void this._setObjectToTarget(t, n, o);
            (o && void 0 !== t[e]) || (t[e] = n);
          }
          _getFromSource(t, e) {
            const n = e.split('.');
            e = n.pop();
            for (const e of n) {
              if (!le(t[e])) {
                t = null;
                break;
              }
              t = t[e];
            }
            return t ? ro(t[e]) : void 0;
          }
          _setObjectToTarget(t, e, n) {
            Object.keys(e).forEach(o => {
              this._setToTarget(t, o, e[o], n);
            });
          }
        }
        function ro(t) {
          return no(t, so);
        }
        function so(t) {
          return oo(t) ? t : void 0;
        }
        function ao(t) {
          return !(!t || !t[Symbol.iterator]);
        }
        class co {
          constructor(t = {}, e = {}) {
            const n = ao(t);
            if (
              (n || (e = t),
              (this._items = []),
              (this._itemMap = new Map()),
              (this._idProperty = e.idProperty || 'id'),
              (this._bindToExternalToInternalMap = new WeakMap()),
              (this._bindToInternalToExternalMap = new WeakMap()),
              (this._skippedIndexesFromExternal = []),
              n)
            )
              for (const e of t) this._items.push(e), this._itemMap.set(this._getItemIdBeforeAdding(e), e);
          }
          get length() {
            return this._items.length;
          }
          get first() {
            return this._items[0] || null;
          }
          get last() {
            return this._items[this.length - 1] || null;
          }
          add(t, e) {
            return this.addMany([t], e);
          }
          addMany(t, e) {
            if (void 0 === e) e = this._items.length;
            else if (e > this._items.length || e < 0) throw new c.a('collection-add-item-invalid-index', this);
            for (let n = 0; n < t.length; n++) {
              const o = t[n],
                i = this._getItemIdBeforeAdding(o),
                r = e + n;
              this._items.splice(r, 0, o), this._itemMap.set(i, o), this.fire('add', o, r);
            }
            return this.fire('change', { added: t, removed: [], index: e }), this;
          }
          get(t) {
            let e;
            if ('string' == typeof t) e = this._itemMap.get(t);
            else {
              if ('number' != typeof t) throw new c.a('collection-get-invalid-arg', this);
              e = this._items[t];
            }
            return e || null;
          }
          has(t) {
            if ('string' == typeof t) return this._itemMap.has(t);
            {
              const e = t[this._idProperty];
              return this._itemMap.has(e);
            }
          }
          getIndex(t) {
            let e;
            return (e = 'string' == typeof t ? this._itemMap.get(t) : t), this._items.indexOf(e);
          }
          remove(t) {
            const [e, n] = this._remove(t);
            return this.fire('change', { added: [], removed: [e], index: n }), e;
          }
          map(t, e) {
            return this._items.map(t, e);
          }
          find(t, e) {
            return this._items.find(t, e);
          }
          filter(t, e) {
            return this._items.filter(t, e);
          }
          clear() {
            this._bindToCollection && (this.stopListening(this._bindToCollection), (this._bindToCollection = null));
            const t = Array.from(this._items);
            for (; this.length; ) this._remove(0);
            this.fire('change', { added: [], removed: t, index: 0 });
          }
          bindTo(t) {
            if (this._bindToCollection) throw new c.a('collection-bind-to-rebind', this);
            return (
              (this._bindToCollection = t),
              {
                as: t => {
                  this._setUpBindToBinding(e => new t(e));
                },
                using: t => {
                  'function' == typeof t ? this._setUpBindToBinding(e => t(e)) : this._setUpBindToBinding(e => e[t]);
                },
              }
            );
          }
          _setUpBindToBinding(t) {
            const e = this._bindToCollection,
              n = (n, o, i) => {
                const r = e._bindToCollection == this,
                  s = e._bindToInternalToExternalMap.get(o);
                if (r && s) this._bindToExternalToInternalMap.set(o, s), this._bindToInternalToExternalMap.set(s, o);
                else {
                  const n = t(o);
                  if (!n) return void this._skippedIndexesFromExternal.push(i);
                  let r = i;
                  for (const t of this._skippedIndexesFromExternal) i > t && r--;
                  for (const t of e._skippedIndexesFromExternal) r >= t && r++;
                  this._bindToExternalToInternalMap.set(o, n),
                    this._bindToInternalToExternalMap.set(n, o),
                    this.add(n, r);
                  for (let t = 0; t < e._skippedIndexesFromExternal.length; t++)
                    r <= e._skippedIndexesFromExternal[t] && e._skippedIndexesFromExternal[t]++;
                }
              };
            for (const t of e) n(0, t, e.getIndex(t));
            this.listenTo(e, 'add', n),
              this.listenTo(e, 'remove', (t, e, n) => {
                const o = this._bindToExternalToInternalMap.get(e);
                o && this.remove(o),
                  (this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce(
                    (t, e) => (n < e && t.push(e - 1), n > e && t.push(e), t),
                    [],
                  ));
              });
          }
          _getItemIdBeforeAdding(t) {
            const e = this._idProperty;
            let n;
            if (e in t) {
              if (((n = t[e]), 'string' != typeof n)) throw new c.a('collection-add-invalid-id', this);
              if (this.get(n)) throw new c.a('collection-add-item-already-exists', this);
            } else t[e] = n = s();
            return n;
          }
          _remove(t) {
            let e,
              n,
              o,
              i = !1;
            const r = this._idProperty;
            if (
              ('string' == typeof t
                ? ((n = t), (o = this._itemMap.get(n)), (i = !o), o && (e = this._items.indexOf(o)))
                : 'number' == typeof t
                ? ((e = t), (o = this._items[e]), (i = !o), o && (n = o[r]))
                : ((o = t), (n = o[r]), (e = this._items.indexOf(o)), (i = -1 == e || !this._itemMap.get(n))),
              i)
            )
              throw new c.a('collection-remove-404', this);
            this._items.splice(e, 1), this._itemMap.delete(n);
            const s = this._bindToInternalToExternalMap.get(o);
            return (
              this._bindToInternalToExternalMap.delete(o),
              this._bindToExternalToInternalMap.delete(s),
              this.fire('remove', o, e),
              [o, e]
            );
          }
          [Symbol.iterator]() {
            return this._items[Symbol.iterator]();
          }
        }
        Yt(co, h);
        class lo {
          constructor(t, e = [], n = []) {
            (this._context = t), (this._plugins = new Map()), (this._availablePlugins = new Map());
            for (const t of e) t.pluginName && this._availablePlugins.set(t.pluginName, t);
            this._contextPlugins = new Map();
            for (const [t, e] of n)
              this._contextPlugins.set(t, e),
                this._contextPlugins.set(e, t),
                t.pluginName && this._availablePlugins.set(t.pluginName, t);
          }
          *[Symbol.iterator]() {
            for (const t of this._plugins) 'function' == typeof t[0] && (yield t);
          }
          get(t) {
            const e = this._plugins.get(t);
            if (!e) {
              let e = t;
              throw (
                ('function' == typeof t && (e = t.pluginName || t.name),
                new c.a('plugincollection-plugin-not-loaded', this._context, { plugin: e }))
              );
            }
            return e;
          }
          has(t) {
            return this._plugins.has(t);
          }
          init(t, e = [], n = []) {
            const o = this,
              i = this._context;
            !(function t(e, n = new Set()) {
              e.forEach(e => {
                a(e) &&
                  (n.has(e) ||
                    (n.add(e),
                    e.pluginName && !o._availablePlugins.has(e.pluginName) && o._availablePlugins.set(e.pluginName, e),
                    e.requires && t(e.requires, n)));
              });
            })(t),
              u(t);
            const r = [
              ...(function t(e, n = new Set()) {
                return e
                  .map(t => (a(t) ? t : o._availablePlugins.get(t)))
                  .reduce(
                    (e, o) =>
                      n.has(o)
                        ? e
                        : (n.add(o),
                          o.requires && (u(o.requires, o), t(o.requires, n).forEach(t => e.add(t))),
                          e.add(o)),
                    new Set(),
                  );
              })(t.filter(t => !d(t, e))),
            ];
            !(function (t, e) {
              for (const n of e) {
                if ('function' != typeof n)
                  throw new c.a('plugincollection-replace-plugin-invalid-type', null, { pluginItem: n });
                const e = n.pluginName;
                if (!e) throw new c.a('plugincollection-replace-plugin-missing-name', null, { pluginItem: n });
                if (n.requires && n.requires.length)
                  throw new c.a('plugincollection-plugin-for-replacing-cannot-have-dependencies', null, {
                    pluginName: e,
                  });
                const i = o._availablePlugins.get(e);
                if (!i) throw new c.a('plugincollection-plugin-for-replacing-not-exist', null, { pluginName: e });
                const r = t.indexOf(i);
                if (-1 === r) {
                  if (o._contextPlugins.has(i)) return;
                  throw new c.a('plugincollection-plugin-for-replacing-not-loaded', null, { pluginName: e });
                }
                if (i.requires && i.requires.length)
                  throw new c.a('plugincollection-replaced-plugin-cannot-have-dependencies', null, { pluginName: e });
                t.splice(r, 1, n), o._availablePlugins.set(e, n);
              }
            })(r, n);
            const s = (function (t) {
              return t.map(t => {
                const e = o._contextPlugins.get(t) || new t(i);
                return o._add(t, e), e;
              });
            })(r);
            return p(s, 'init')
              .then(() => p(s, 'afterInit'))
              .then(() => s);
            function a(t) {
              return 'function' == typeof t;
            }
            function l(t) {
              return a(t) && t.isContextPlugin;
            }
            function d(t, e) {
              return e.some(e => e === t || h(t) === e || h(e) === t);
            }
            function h(t) {
              return a(t) ? t.pluginName || t.name : t;
            }
            function u(t, n = null) {
              t.map(t => (a(t) ? t : o._availablePlugins.get(t) || t)).forEach(t => {
                !(function (t, e) {
                  if (a(t)) return;
                  if (e) throw new c.a('plugincollection-soft-required', i, { missingPlugin: t, requiredBy: h(e) });
                  throw new c.a('plugincollection-plugin-not-found', i, { plugin: t });
                })(t, n),
                  (function (t, e) {
                    if (!l(e)) return;
                    if (l(t)) return;
                    throw new c.a('plugincollection-context-required', i, { plugin: h(t), requiredBy: h(e) });
                  })(t, n),
                  (function (t, n) {
                    if (!n) return;
                    if (!d(t, e)) return;
                    throw new c.a('plugincollection-required', i, { plugin: h(t), requiredBy: h(n) });
                  })(t, n);
              });
            }
            function p(t, e) {
              return t.reduce(
                (t, n) => (n[e] ? (o._contextPlugins.has(n) ? t : t.then(n[e].bind(n))) : t),
                Promise.resolve(),
              );
            }
          }
          destroy() {
            const t = [];
            for (const [, e] of this)
              'function' != typeof e.destroy || this._contextPlugins.has(e) || t.push(e.destroy());
            return Promise.all(t);
          }
          _add(t, e) {
            this._plugins.set(t, e);
            const n = t.pluginName;
            if (n) {
              if (this._plugins.has(n))
                throw new c.a('plugincollection-plugin-name-conflict', null, {
                  pluginName: n,
                  plugin1: this._plugins.get(n).constructor,
                  plugin2: t,
                });
              this._plugins.set(n, e);
            }
          }
        }
        function ho(t) {
          return Array.isArray(t) ? t : [t];
        }
        function uo(t, e, n = 1) {
          if ('number' != typeof n) throw new c.a('translation-service-quantity-not-a-number', null, { quantity: n });
          const o = Object.keys(window.CKEDITOR_TRANSLATIONS).length;
          1 === o && (t = Object.keys(window.CKEDITOR_TRANSLATIONS)[0]);
          const i = e.id || e.string;
          if (
            0 === o ||
            !(function (t, e) {
              return !!window.CKEDITOR_TRANSLATIONS[t] && !!window.CKEDITOR_TRANSLATIONS[t].dictionary[e];
            })(t, i)
          )
            return 1 !== n ? e.plural : e.string;
          const r = window.CKEDITOR_TRANSLATIONS[t].dictionary,
            s = window.CKEDITOR_TRANSLATIONS[t].getPluralForm || (t => (1 === t ? 0 : 1));
          if ('string' == typeof r[i]) return r[i];
          const a = Number(s(n));
          return r[i][a];
        }
        Yt(lo, h), window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {});
        const po = ['ar', 'ara', 'fa', 'per', 'fas', 'he', 'heb', 'ku', 'kur', 'ug', 'uig'];
        function mo(t) {
          return po.includes(t) ? 'rtl' : 'ltr';
        }
        class go {
          constructor(t = {}) {
            (this.uiLanguage = t.uiLanguage || 'en'),
              (this.contentLanguage = t.contentLanguage || this.uiLanguage),
              (this.uiLanguageDirection = mo(this.uiLanguage)),
              (this.contentLanguageDirection = mo(this.contentLanguage)),
              (this.t = (t, e) => this._t(t, e));
          }
          get language() {
            return (
              console.warn(
                'locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead.',
              ),
              this.uiLanguage
            );
          }
          _t(t, e = []) {
            (e = ho(e)), 'string' == typeof t && (t = { string: t });
            const n = !!t.plural ? e[0] : 1;
            return (function (t, e) {
              return t.replace(/%(\d+)/g, (t, n) => (n < e.length ? e[n] : t));
            })(uo(this.uiLanguage, t, n), e);
          }
        }
        class fo {
          constructor(t) {
            this.config = new io(t, this.constructor.defaultConfig);
            const e = this.constructor.builtinPlugins;
            this.config.define('plugins', e), (this.plugins = new lo(this, e));
            const n = this.config.get('language') || {};
            (this.locale = new go({
              uiLanguage: 'string' == typeof n ? n : n.ui,
              contentLanguage: this.config.get('language.content'),
            })),
              (this.t = this.locale.t),
              (this.editors = new co()),
              (this._contextOwner = null);
          }
          initPlugins() {
            const t = this.config.get('plugins') || [],
              e = this.config.get('substitutePlugins') || [];
            for (const n of t.concat(e)) {
              if ('function' != typeof n) throw new c.a('context-initplugins-constructor-only', null, { Plugin: n });
              if (!0 !== n.isContextPlugin) throw new c.a('context-initplugins-invalid-plugin', null, { Plugin: n });
            }
            return this.plugins.init(t, [], e);
          }
          destroy() {
            return Promise.all(Array.from(this.editors, t => t.destroy())).then(() => this.plugins.destroy());
          }
          _addEditor(t, e) {
            if (this._contextOwner) throw new c.a('context-addeditor-private-context');
            this.editors.add(t), e && (this._contextOwner = t);
          }
          _removeEditor(t) {
            return (
              this.editors.has(t) && this.editors.remove(t),
              this._contextOwner === t ? this.destroy() : Promise.resolve()
            );
          }
          _getEditorConfig() {
            const t = {};
            for (const e of this.config.names())
              ['plugins', 'removePlugins', 'extraPlugins'].includes(e) || (t[e] = this.config.get(e));
            return t;
          }
          static create(t) {
            return new Promise(e => {
              const n = new this(t);
              e(n.initPlugins().then(() => n));
            });
          }
        }
        class ko {
          constructor(t) {
            this.context = t;
          }
          destroy() {
            this.stopListening();
          }
          static get isContextPlugin() {
            return !0;
          }
        }
        function bo(t, e) {
          const n = Math.min(t.length, e.length);
          for (let o = 0; o < n; o++) if (t[o] != e[o]) return o;
          return t.length == e.length ? 'same' : t.length < e.length ? 'prefix' : 'extension';
        }
        Yt(ko, jt);
        var wo = function (t) {
          return eo(t, 4);
        };
        class Ao {
          constructor(t) {
            (this.document = t), (this.parent = null);
          }
          get index() {
            let t;
            if (!this.parent) return null;
            if (-1 == (t = this.parent.getChildIndex(this))) throw new c.a('view-node-not-found-in-parent', this);
            return t;
          }
          get nextSibling() {
            const t = this.index;
            return (null !== t && this.parent.getChild(t + 1)) || null;
          }
          get previousSibling() {
            const t = this.index;
            return (null !== t && this.parent.getChild(t - 1)) || null;
          }
          get root() {
            let t = this;
            for (; t.parent; ) t = t.parent;
            return t;
          }
          isAttached() {
            return this.root.is('rootElement');
          }
          getPath() {
            const t = [];
            let e = this;
            for (; e.parent; ) t.unshift(e.index), (e = e.parent);
            return t;
          }
          getAncestors(t = { includeSelf: !1, parentFirst: !1 }) {
            const e = [];
            let n = t.includeSelf ? this : this.parent;
            for (; n; ) e[t.parentFirst ? 'push' : 'unshift'](n), (n = n.parent);
            return e;
          }
          getCommonAncestor(t, e = {}) {
            const n = this.getAncestors(e),
              o = t.getAncestors(e);
            let i = 0;
            for (; n[i] == o[i] && n[i]; ) i++;
            return 0 === i ? null : n[i - 1];
          }
          isBefore(t) {
            if (this == t) return !1;
            if (this.root !== t.root) return !1;
            const e = this.getPath(),
              n = t.getPath(),
              o = bo(e, n);
            switch (o) {
              case 'prefix':
                return !0;
              case 'extension':
                return !1;
              default:
                return e[o] < n[o];
            }
          }
          isAfter(t) {
            return this != t && this.root === t.root && !this.isBefore(t);
          }
          _remove() {
            this.parent._removeChildren(this.index);
          }
          _fireChange(t, e) {
            this.fire('change:' + t, e), this.parent && this.parent._fireChange(t, e);
          }
          toJSON() {
            const t = wo(this);
            return delete t.parent, t;
          }
          is(t) {
            return 'node' === t || 'view:node' === t;
          }
        }
        Yt(Ao, h);
        class _o extends Ao {
          constructor(t, e) {
            super(t), (this._textData = e);
          }
          is(t) {
            return (
              '$text' === t ||
              'view:$text' === t ||
              'text' === t ||
              'view:text' === t ||
              'node' === t ||
              'view:node' === t
            );
          }
          get data() {
            return this._textData;
          }
          get _data() {
            return this.data;
          }
          set _data(t) {
            this._fireChange('text', this), (this._textData = t);
          }
          isSimilar(t) {
            return t instanceof _o && (this === t || this.data === t.data);
          }
          _clone() {
            return new _o(this.document, this.data);
          }
        }
        class Co {
          constructor(t, e, n) {
            if (((this.textNode = t), e < 0 || e > t.data.length))
              throw new c.a('view-textproxy-wrong-offsetintext', this);
            if (n < 0 || e + n > t.data.length) throw new c.a('view-textproxy-wrong-length', this);
            (this.data = t.data.substring(e, e + n)), (this.offsetInText = e);
          }
          get offsetSize() {
            return this.data.length;
          }
          get isPartial() {
            return this.data.length !== this.textNode.data.length;
          }
          get parent() {
            return this.textNode.parent;
          }
          get root() {
            return this.textNode.root;
          }
          get document() {
            return this.textNode.document;
          }
          is(t) {
            return '$textProxy' === t || 'view:$textProxy' === t || 'textProxy' === t || 'view:textProxy' === t;
          }
          getAncestors(t = { includeSelf: !1, parentFirst: !1 }) {
            const e = [];
            let n = t.includeSelf ? this.textNode : this.parent;
            for (; null !== n; ) e[t.parentFirst ? 'push' : 'unshift'](n), (n = n.parent);
            return e;
          }
        }
        function vo(t) {
          return ao(t)
            ? new Map(t)
            : (function (t) {
                const e = new Map();
                for (const n in t) e.set(n, t[n]);
                return e;
              })(t);
        }
        class yo {
          constructor(...t) {
            (this._patterns = []), this.add(...t);
          }
          add(...t) {
            for (let e of t)
              ('string' == typeof e || e instanceof RegExp) && (e = { name: e }),
                e.classes && ('string' == typeof e.classes || e.classes instanceof RegExp) && (e.classes = [e.classes]),
                this._patterns.push(e);
          }
          match(...t) {
            for (const e of t)
              for (const t of this._patterns) {
                const n = xo(e, t);
                if (n) return { element: e, pattern: t, match: n };
              }
            return null;
          }
          matchAll(...t) {
            const e = [];
            for (const n of t)
              for (const t of this._patterns) {
                const o = xo(n, t);
                o && e.push({ element: n, pattern: t, match: o });
              }
            return e.length > 0 ? e : null;
          }
          getElementName() {
            if (1 !== this._patterns.length) return null;
            const t = this._patterns[0],
              e = t.name;
            return 'function' == typeof t || !e || e instanceof RegExp ? null : e;
          }
        }
        function xo(t, e) {
          if ('function' == typeof e) return e(t);
          const n = {};
          return (e.name &&
            ((n.name = (function (t, e) {
              if (t instanceof RegExp) return t.test(e);
              return t === e;
            })(e.name, t.name)),
            !n.name)) ||
            (e.attributes &&
              ((n.attributes = (function (t, e) {
                const n = [];
                for (const o in t) {
                  const i = t[o];
                  if (!e.hasAttribute(o)) return null;
                  {
                    const t = e.getAttribute(o);
                    if (!0 === i) n.push(o);
                    else if (i instanceof RegExp) {
                      if (!i.test(t)) return null;
                      n.push(o);
                    } else {
                      if (t !== i) return null;
                      n.push(o);
                    }
                  }
                }
                return n;
              })(e.attributes, t)),
              !n.attributes))
            ? null
            : !(
                e.classes &&
                ((n.classes = (function (t, e) {
                  const n = [];
                  for (const o of t)
                    if (o instanceof RegExp) {
                      const t = e.getClassNames();
                      for (const e of t) o.test(e) && n.push(e);
                      if (0 === n.length) return null;
                    } else {
                      if (!e.hasClass(o)) return null;
                      n.push(o);
                    }
                  return n;
                })(e.classes, t)),
                !n.classes)
              ) &&
                !(
                  e.styles &&
                  ((n.styles = (function (t, e) {
                    const n = [];
                    for (const o in t) {
                      const i = t[o];
                      if (!e.hasStyle(o)) return null;
                      {
                        const t = e.getStyle(o);
                        if (i instanceof RegExp) {
                          if (!i.test(t)) return null;
                          n.push(o);
                        } else {
                          if (t !== i) return null;
                          n.push(o);
                        }
                      }
                    }
                    return n;
                  })(e.styles, t)),
                  !n.styles)
                ) &&
                n;
        }
        var Eo = function (t) {
            return 'symbol' == typeof t || (gt(t) && '[object Symbol]' == T(t));
          },
          Do = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          So = /^\w*$/;
        var Bo = function (t, e) {
          if (_t(t)) return !1;
          var n = typeof t;
          return (
            !('number' != n && 'symbol' != n && 'boolean' != n && null != t && !Eo(t)) ||
            So.test(t) ||
            !Do.test(t) ||
            (null != e && t in Object(e))
          );
        };
        function To(t, e) {
          if ('function' != typeof t || (null != e && 'function' != typeof e))
            throw new TypeError('Expected a function');
          var n = function () {
            var o = arguments,
              i = e ? e.apply(this, o) : o[0],
              r = n.cache;
            if (r.has(i)) return r.get(i);
            var s = t.apply(this, o);
            return (n.cache = r.set(i, s) || r), s;
          };
          return (n.cache = new (To.Cache || qe)()), n;
        }
        To.Cache = qe;
        var Po = To;
        var Io = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
          zo = /\\(\\)?/g,
          Fo = (function (t) {
            var e = Po(t, function (t) {
                return 500 === n.size && n.clear(), t;
              }),
              n = e.cache;
            return e;
          })(function (t) {
            var e = [];
            return (
              46 === t.charCodeAt(0) && e.push(''),
              t.replace(Io, function (t, n, o, i) {
                e.push(o ? i.replace(zo, '$1') : n || t);
              }),
              e
            );
          });
        var Ro = function (t, e) {
            for (var n = -1, o = null == t ? 0 : t.length, i = Array(o); ++n < o; ) i[n] = e(t[n], n, t);
            return i;
          },
          Oo = _ ? _.prototype : void 0,
          Mo = Oo ? Oo.toString : void 0;
        var No = function t(e) {
          if ('string' == typeof e) return e;
          if (_t(e)) return Ro(e, t) + '';
          if (Eo(e)) return Mo ? Mo.call(e) : '';
          var n = e + '';
          return '0' == n && 1 / e == -Infinity ? '-0' : n;
        };
        var Vo = function (t) {
          return null == t ? '' : No(t);
        };
        var Lo = function (t, e) {
          return _t(t) ? t : Bo(t, e) ? [t] : Fo(Vo(t));
        };
        var Ko = function (t) {
          var e = null == t ? 0 : t.length;
          return e ? t[e - 1] : void 0;
        };
        var qo = function (t) {
          if ('string' == typeof t || Eo(t)) return t;
          var e = t + '';
          return '0' == e && 1 / t == -Infinity ? '-0' : e;
        };
        var Ho = function (t, e) {
          for (var n = 0, o = (e = Lo(e, t)).length; null != t && n < o; ) t = t[qo(e[n++])];
          return n && n == o ? t : void 0;
        };
        var jo = function (t, e, n) {
          var o = -1,
            i = t.length;
          e < 0 && (e = -e > i ? 0 : i + e),
            (n = n > i ? i : n) < 0 && (n += i),
            (i = e > n ? 0 : (n - e) >>> 0),
            (e >>>= 0);
          for (var r = Array(i); ++o < i; ) r[o] = t[o + e];
          return r;
        };
        var $o = function (t, e) {
          return e.length < 2 ? t : Ho(t, jo(e, 0, -1));
        };
        var Go = function (t, e) {
          return (e = Lo(e, t)), null == (t = $o(t, e)) || delete t[qo(Ko(e))];
        };
        var Wo = function (t, e) {
          return null == t || Go(t, e);
        };
        var Uo = function (t, e, n) {
          var o = null == t ? void 0 : Ho(t, e);
          return void 0 === o ? n : o;
        };
        var Jo = function (t, e, n) {
          ((void 0 !== n && !J(t[e], n)) || (void 0 === n && !(e in t))) && U(t, e, n);
        };
        var Yo = (function (t) {
          return function (e, n, o) {
            for (var i = -1, r = Object(e), s = o(e), a = s.length; a--; ) {
              var c = s[t ? a : ++i];
              if (!1 === n(r[c], c, r)) break;
            }
            return e;
          };
        })();
        var Qo = function (t) {
          return gt(t) && lt(t);
        };
        var Xo = function (t, e) {
          if (('constructor' !== e || 'function' != typeof t[e]) && '__proto__' != e) return t[e];
        };
        var Zo = function (t) {
          return X(t, Ot(t));
        };
        var ti = function (t, e, n, o, i, r, s) {
          var a = Xo(t, n),
            c = Xo(e, n),
            l = s.get(c);
          if (l) Jo(t, n, l);
          else {
            var d = r ? r(a, c, n + '', t, e, s) : void 0,
              h = void 0 === d;
            if (h) {
              var u = _t(c),
                p = !u && Object(Ct.a)(c),
                m = !u && !p && St(c);
              (d = c),
                u || p || m
                  ? _t(a)
                    ? (d = a)
                    : Qo(a)
                    ? (d = tn(a))
                    : p
                    ? ((h = !1), (d = Object(Ze.a)(c, !0)))
                    : m
                    ? ((h = !1), (d = Ln(c, !0)))
                    : (d = [])
                  : le(c) || At(c)
                  ? ((d = a), At(a) ? (d = Zo(a)) : (w(a) && !I(a)) || (d = jn(c)))
                  : (h = !1);
            }
            h && (s.set(c, d), i(d, c, o, r, s), s.delete(c)), Jo(t, n, d);
          }
        };
        var ei = function t(e, n, o, i, r) {
            e !== n &&
              Yo(
                n,
                function (s, a) {
                  if ((r || (r = new $e()), w(s))) ti(e, n, a, o, t, i, r);
                  else {
                    var c = i ? i(Xo(e, a), s, a + '', e, n, r) : void 0;
                    void 0 === c && (c = s), Jo(e, a, c);
                  }
                },
                Ot,
              );
          },
          ni = pt(function (t, e, n) {
            ei(t, e, n);
          });
        var oi = function (t, e, n, o) {
          if (!w(t)) return t;
          for (var i = -1, r = (e = Lo(e, t)).length, s = r - 1, a = t; null != a && ++i < r; ) {
            var c = qo(e[i]),
              l = n;
            if ('__proto__' === c || 'constructor' === c || 'prototype' === c) return t;
            if (i != s) {
              var d = a[c];
              void 0 === (l = o ? o(d, c, a) : void 0) && (l = w(d) ? d : ht(e[i + 1]) ? [] : {});
            }
            Q(a, c, l), (a = a[c]);
          }
          return t;
        };
        var ii = function (t, e, n) {
          return null == t ? t : oi(t, e, n);
        };
        class ri {
          constructor(t) {
            (this._styles = {}), (this._styleProcessor = t);
          }
          get isEmpty() {
            const t = Object.entries(this._styles);
            return !Array.from(t).length;
          }
          get size() {
            return this.isEmpty ? 0 : this.getStyleNames().length;
          }
          setTo(t) {
            this.clear();
            const e = Array.from(
              (function (t) {
                let e = null,
                  n = 0,
                  o = 0,
                  i = null;
                const r = new Map();
                if ('' === t) return r;
                ';' != t.charAt(t.length - 1) && (t += ';');
                for (let s = 0; s < t.length; s++) {
                  const a = t.charAt(s);
                  if (null === e)
                    switch (a) {
                      case ':':
                        i || ((i = t.substr(n, s - n)), (o = s + 1));
                        break;
                      case '"':
                      case "'":
                        e = a;
                        break;
                      case ';': {
                        const e = t.substr(o, s - o);
                        i && r.set(i.trim(), e.trim()), (i = null), (n = s + 1);
                        break;
                      }
                    }
                  else a === e && (e = null);
                }
                return r;
              })(t).entries(),
            );
            for (const [t, n] of e) this._styleProcessor.toNormalizedForm(t, n, this._styles);
          }
          has(t) {
            if (this.isEmpty) return !1;
            const e = this._styleProcessor.getReducedForm(t, this._styles).find(([e]) => e === t);
            return Array.isArray(e);
          }
          set(t, e) {
            if (w(t)) for (const [e, n] of Object.entries(t)) this._styleProcessor.toNormalizedForm(e, n, this._styles);
            else this._styleProcessor.toNormalizedForm(t, e, this._styles);
          }
          remove(t) {
            const e = ai(t);
            Wo(this._styles, e), delete this._styles[t], this._cleanEmptyObjectsOnPath(e);
          }
          getNormalized(t) {
            return this._styleProcessor.getNormalized(t, this._styles);
          }
          toString() {
            return this.isEmpty
              ? ''
              : this._getStylesEntries()
                  .map(t => t.join(':'))
                  .sort()
                  .join(';') + ';';
          }
          getAsString(t) {
            if (this.isEmpty) return;
            if (this._styles[t] && !w(this._styles[t])) return this._styles[t];
            const e = this._styleProcessor.getReducedForm(t, this._styles).find(([e]) => e === t);
            return Array.isArray(e) ? e[1] : void 0;
          }
          getStyleNames() {
            if (this.isEmpty) return [];
            return this._getStylesEntries().map(([t]) => t);
          }
          clear() {
            this._styles = {};
          }
          _getStylesEntries() {
            const t = [],
              e = Object.keys(this._styles);
            for (const n of e) t.push(...this._styleProcessor.getReducedForm(n, this._styles));
            return t;
          }
          _cleanEmptyObjectsOnPath(t) {
            const e = t.split('.');
            if (!(e.length > 1)) return;
            const n = e.splice(0, e.length - 1).join('.'),
              o = Uo(this._styles, n);
            if (!o) return;
            !Array.from(Object.keys(o)).length && this.remove(n);
          }
        }
        class si {
          constructor() {
            (this._normalizers = new Map()),
              (this._extractors = new Map()),
              (this._reducers = new Map()),
              (this._consumables = new Map());
          }
          toNormalizedForm(t, e, n) {
            if (w(e)) ci(n, ai(t), e);
            else if (this._normalizers.has(t)) {
              const o = this._normalizers.get(t),
                { path: i, value: r } = o(e);
              ci(n, i, r);
            } else ci(n, t, e);
          }
          getNormalized(t, e) {
            if (!t) return ni({}, e);
            if (void 0 !== e[t]) return e[t];
            if (this._extractors.has(t)) {
              const n = this._extractors.get(t);
              if ('string' == typeof n) return Uo(e, n);
              const o = n(t, e);
              if (o) return o;
            }
            return Uo(e, ai(t));
          }
          getReducedForm(t, e) {
            const n = this.getNormalized(t, e);
            if (void 0 === n) return [];
            if (this._reducers.has(t)) {
              return this._reducers.get(t)(n);
            }
            return [[t, n]];
          }
          getRelatedStyles(t) {
            return this._consumables.get(t) || [];
          }
          setNormalizer(t, e) {
            this._normalizers.set(t, e);
          }
          setExtractor(t, e) {
            this._extractors.set(t, e);
          }
          setReducer(t, e) {
            this._reducers.set(t, e);
          }
          setStyleRelation(t, e) {
            this._mapStyleNames(t, e);
            for (const n of e) this._mapStyleNames(n, [t]);
          }
          _mapStyleNames(t, e) {
            this._consumables.has(t) || this._consumables.set(t, []), this._consumables.get(t).push(...e);
          }
        }
        function ai(t) {
          return t.replace('-', '.');
        }
        function ci(t, e, n) {
          let o = n;
          w(n) && (o = ni({}, Uo(t, e), n)), ii(t, e, o);
        }
        class li extends Ao {
          constructor(t, e, n, o) {
            if (
              (super(t),
              (this.name = e),
              (this._attrs = (function (t) {
                t = vo(t);
                for (const [e, n] of t) null === n ? t.delete(e) : 'string' != typeof n && t.set(e, String(n));
                return t;
              })(n)),
              (this._children = []),
              o && this._insertChild(0, o),
              (this._classes = new Set()),
              this._attrs.has('class'))
            ) {
              const t = this._attrs.get('class');
              di(this._classes, t), this._attrs.delete('class');
            }
            (this._styles = new ri(this.document.stylesProcessor)),
              this._attrs.has('style') && (this._styles.setTo(this._attrs.get('style')), this._attrs.delete('style')),
              (this._customProperties = new Map()),
              (this._isAllowedInsideAttributeElement = !1);
          }
          get childCount() {
            return this._children.length;
          }
          get isEmpty() {
            return 0 === this._children.length;
          }
          get isAllowedInsideAttributeElement() {
            return this._isAllowedInsideAttributeElement;
          }
          is(t, e = null) {
            return e
              ? e === this.name && ('element' === t || 'view:element' === t)
              : 'element' === t || 'view:element' === t || 'node' === t || 'view:node' === t;
          }
          getChild(t) {
            return this._children[t];
          }
          getChildIndex(t) {
            return this._children.indexOf(t);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          *getAttributeKeys() {
            this._classes.size > 0 && (yield 'class'),
              this._styles.isEmpty || (yield 'style'),
              yield* this._attrs.keys();
          }
          *getAttributes() {
            yield* this._attrs.entries(),
              this._classes.size > 0 && (yield ['class', this.getAttribute('class')]),
              this._styles.isEmpty || (yield ['style', this.getAttribute('style')]);
          }
          getAttribute(t) {
            if ('class' == t) return this._classes.size > 0 ? [...this._classes].join(' ') : void 0;
            if ('style' == t) {
              const t = this._styles.toString();
              return '' == t ? void 0 : t;
            }
            return this._attrs.get(t);
          }
          hasAttribute(t) {
            return 'class' == t ? this._classes.size > 0 : 'style' == t ? !this._styles.isEmpty : this._attrs.has(t);
          }
          isSimilar(t) {
            if (!(t instanceof li)) return !1;
            if (this === t) return !0;
            if (this.name != t.name) return !1;
            if (this.isAllowedInsideAttributeElement != t.isAllowedInsideAttributeElement) return !1;
            if (
              this._attrs.size !== t._attrs.size ||
              this._classes.size !== t._classes.size ||
              this._styles.size !== t._styles.size
            )
              return !1;
            for (const [e, n] of this._attrs) if (!t._attrs.has(e) || t._attrs.get(e) !== n) return !1;
            for (const e of this._classes) if (!t._classes.has(e)) return !1;
            for (const e of this._styles.getStyleNames())
              if (!t._styles.has(e) || t._styles.getAsString(e) !== this._styles.getAsString(e)) return !1;
            return !0;
          }
          hasClass(...t) {
            for (const e of t) if (!this._classes.has(e)) return !1;
            return !0;
          }
          getClassNames() {
            return this._classes.keys();
          }
          getStyle(t) {
            return this._styles.getAsString(t);
          }
          getNormalizedStyle(t) {
            return this._styles.getNormalized(t);
          }
          getStyleNames() {
            return this._styles.getStyleNames();
          }
          hasStyle(...t) {
            for (const e of t) if (!this._styles.has(e)) return !1;
            return !0;
          }
          findAncestor(...t) {
            const e = new yo(...t);
            let n = this.parent;
            for (; n; ) {
              if (e.match(n)) return n;
              n = n.parent;
            }
            return null;
          }
          getCustomProperty(t) {
            return this._customProperties.get(t);
          }
          *getCustomProperties() {
            yield* this._customProperties.entries();
          }
          getIdentity() {
            const t = Array.from(this._classes).sort().join(','),
              e = this._styles.toString(),
              n = Array.from(this._attrs)
                .map(t => `${t[0]}="${t[1]}"`)
                .sort()
                .join(' ');
            return this.name + ('' == t ? '' : ` class="${t}"`) + (e ? ` style="${e}"` : '') + ('' == n ? '' : ` ${n}`);
          }
          _clone(t = !1) {
            const e = [];
            if (t) for (const n of this.getChildren()) e.push(n._clone(t));
            const n = new this.constructor(this.document, this.name, this._attrs, e);
            return (
              (n._classes = new Set(this._classes)),
              n._styles.set(this._styles.getNormalized()),
              (n._customProperties = new Map(this._customProperties)),
              (n.getFillerOffset = this.getFillerOffset),
              (n._isAllowedInsideAttributeElement = this.isAllowedInsideAttributeElement),
              n
            );
          }
          _appendChild(t) {
            return this._insertChild(this.childCount, t);
          }
          _insertChild(t, e) {
            this._fireChange('children', this);
            let n = 0;
            const o = (function (t, e) {
              if ('string' == typeof e) return [new _o(t, e)];
              ao(e) || (e = [e]);
              return Array.from(e).map(e =>
                'string' == typeof e ? new _o(t, e) : e instanceof Co ? new _o(t, e.data) : e,
              );
            })(this.document, e);
            for (const e of o)
              null !== e.parent && e._remove(),
                (e.parent = this),
                (e.document = this.document),
                this._children.splice(t, 0, e),
                t++,
                n++;
            return n;
          }
          _removeChildren(t, e = 1) {
            this._fireChange('children', this);
            for (let n = t; n < t + e; n++) this._children[n].parent = null;
            return this._children.splice(t, e);
          }
          _setAttribute(t, e) {
            (e = String(e)),
              this._fireChange('attributes', this),
              'class' == t ? di(this._classes, e) : 'style' == t ? this._styles.setTo(e) : this._attrs.set(t, e);
          }
          _removeAttribute(t) {
            return (
              this._fireChange('attributes', this),
              'class' == t
                ? this._classes.size > 0 && (this._classes.clear(), !0)
                : 'style' == t
                ? !this._styles.isEmpty && (this._styles.clear(), !0)
                : this._attrs.delete(t)
            );
          }
          _addClass(t) {
            this._fireChange('attributes', this);
            for (const e of ho(t)) this._classes.add(e);
          }
          _removeClass(t) {
            this._fireChange('attributes', this);
            for (const e of ho(t)) this._classes.delete(e);
          }
          _setStyle(t, e) {
            this._fireChange('attributes', this), this._styles.set(t, e);
          }
          _removeStyle(t) {
            this._fireChange('attributes', this);
            for (const e of ho(t)) this._styles.remove(e);
          }
          _setCustomProperty(t, e) {
            this._customProperties.set(t, e);
          }
          _removeCustomProperty(t) {
            return this._customProperties.delete(t);
          }
        }
        function di(t, e) {
          const n = e.split(/\s+/);
          t.clear(), n.forEach(e => t.add(e));
        }
        class hi extends li {
          constructor(t, e, n, o) {
            super(t, e, n, o), (this.getFillerOffset = ui);
          }
          is(t, e = null) {
            return e
              ? e === this.name &&
                  ('containerElement' === t || 'view:containerElement' === t || 'element' === t || 'view:element' === t)
              : 'containerElement' === t ||
                  'view:containerElement' === t ||
                  'element' === t ||
                  'view:element' === t ||
                  'node' === t ||
                  'view:node' === t;
          }
        }
        function ui() {
          const t = [...this.getChildren()],
            e = t[this.childCount - 1];
          if (e && e.is('element', 'br')) return this.childCount;
          for (const e of t) if (!e.is('uiElement')) return null;
          return this.childCount;
        }
        class pi extends hi {
          constructor(t, e, n, o) {
            super(t, e, n, o),
              this.set('isReadOnly', !1),
              this.set('isFocused', !1),
              this.bind('isReadOnly').to(t),
              this.bind('isFocused').to(t, 'isFocused', e => e && t.selection.editableElement == this),
              this.listenTo(t.selection, 'change', () => {
                this.isFocused = t.isFocused && t.selection.editableElement == this;
              });
          }
          is(t, e = null) {
            return e
              ? e === this.name &&
                  ('editableElement' === t ||
                    'view:editableElement' === t ||
                    'containerElement' === t ||
                    'view:containerElement' === t ||
                    'element' === t ||
                    'view:element' === t)
              : 'editableElement' === t ||
                  'view:editableElement' === t ||
                  'containerElement' === t ||
                  'view:containerElement' === t ||
                  'element' === t ||
                  'view:element' === t ||
                  'node' === t ||
                  'view:node' === t;
          }
          destroy() {
            this.stopListening();
          }
        }
        Yt(pi, jt);
        const mi = Symbol('rootName');
        class gi extends pi {
          constructor(t, e) {
            super(t, e), (this.rootName = 'main');
          }
          is(t, e = null) {
            return e
              ? e === this.name &&
                  ('rootElement' === t ||
                    'view:rootElement' === t ||
                    'editableElement' === t ||
                    'view:editableElement' === t ||
                    'containerElement' === t ||
                    'view:containerElement' === t ||
                    'element' === t ||
                    'view:element' === t)
              : 'rootElement' === t ||
                  'view:rootElement' === t ||
                  'editableElement' === t ||
                  'view:editableElement' === t ||
                  'containerElement' === t ||
                  'view:containerElement' === t ||
                  'element' === t ||
                  'view:element' === t ||
                  'node' === t ||
                  'view:node' === t;
          }
          get rootName() {
            return this.getCustomProperty(mi);
          }
          set rootName(t) {
            this._setCustomProperty(mi, t);
          }
          set _name(t) {
            this.name = t;
          }
        }
        class fi {
          constructor(t = {}) {
            if (!t.boundaries && !t.startPosition) throw new c.a('view-tree-walker-no-start-position', null);
            if (t.direction && 'forward' != t.direction && 'backward' != t.direction)
              throw new c.a('view-tree-walker-unknown-direction', t.startPosition, { direction: t.direction });
            (this.boundaries = t.boundaries || null),
              t.startPosition
                ? (this.position = ki._createAt(t.startPosition))
                : (this.position = ki._createAt(t.boundaries['backward' == t.direction ? 'end' : 'start'])),
              (this.direction = t.direction || 'forward'),
              (this.singleCharacters = !!t.singleCharacters),
              (this.shallow = !!t.shallow),
              (this.ignoreElementEnd = !!t.ignoreElementEnd),
              (this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null),
              (this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null);
          }
          [Symbol.iterator]() {
            return this;
          }
          skip(t) {
            let e, n, o;
            do {
              (o = this.position), ({ done: e, value: n } = this.next());
            } while (!e && t(n));
            e || (this.position = o);
          }
          next() {
            return 'forward' == this.direction ? this._next() : this._previous();
          }
          _next() {
            let t = this.position.clone();
            const e = this.position,
              n = t.parent;
            if (null === n.parent && t.offset === n.childCount) return { done: !0 };
            if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset) return { done: !0 };
            let o;
            if (n instanceof _o) {
              if (t.isAtEnd) return (this.position = ki._createAfter(n)), this._next();
              o = n.data[t.offset];
            } else o = n.getChild(t.offset);
            if (o instanceof li)
              return (
                this.shallow ? t.offset++ : (t = new ki(o, 0)),
                (this.position = t),
                this._formatReturnValue('elementStart', o, e, t, 1)
              );
            if (o instanceof _o) {
              if (this.singleCharacters) return (t = new ki(o, 0)), (this.position = t), this._next();
              {
                let n,
                  i = o.data.length;
                return (
                  o == this._boundaryEndParent
                    ? ((i = this.boundaries.end.offset), (n = new Co(o, 0, i)), (t = ki._createAfter(n)))
                    : ((n = new Co(o, 0, o.data.length)), t.offset++),
                  (this.position = t),
                  this._formatReturnValue('text', n, e, t, i)
                );
              }
            }
            if ('string' == typeof o) {
              let o;
              if (this.singleCharacters) o = 1;
              else {
                o = (n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length) - t.offset;
              }
              const i = new Co(n, t.offset, o);
              return (t.offset += o), (this.position = t), this._formatReturnValue('text', i, e, t, o);
            }
            return (
              (t = ki._createAfter(n)),
              (this.position = t),
              this.ignoreElementEnd ? this._next() : this._formatReturnValue('elementEnd', n, e, t)
            );
          }
          _previous() {
            let t = this.position.clone();
            const e = this.position,
              n = t.parent;
            if (null === n.parent && 0 === t.offset) return { done: !0 };
            if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset) return { done: !0 };
            let o;
            if (n instanceof _o) {
              if (t.isAtStart) return (this.position = ki._createBefore(n)), this._previous();
              o = n.data[t.offset - 1];
            } else o = n.getChild(t.offset - 1);
            if (o instanceof li)
              return this.shallow
                ? (t.offset--, (this.position = t), this._formatReturnValue('elementStart', o, e, t, 1))
                : ((t = new ki(o, o.childCount)),
                  (this.position = t),
                  this.ignoreElementEnd ? this._previous() : this._formatReturnValue('elementEnd', o, e, t));
            if (o instanceof _o) {
              if (this.singleCharacters) return (t = new ki(o, o.data.length)), (this.position = t), this._previous();
              {
                let n,
                  i = o.data.length;
                if (o == this._boundaryStartParent) {
                  const e = this.boundaries.start.offset;
                  (n = new Co(o, e, o.data.length - e)), (i = n.data.length), (t = ki._createBefore(n));
                } else (n = new Co(o, 0, o.data.length)), t.offset--;
                return (this.position = t), this._formatReturnValue('text', n, e, t, i);
              }
            }
            if ('string' == typeof o) {
              let o;
              if (this.singleCharacters) o = 1;
              else {
                const e = n === this._boundaryStartParent ? this.boundaries.start.offset : 0;
                o = t.offset - e;
              }
              t.offset -= o;
              const i = new Co(n, t.offset, o);
              return (this.position = t), this._formatReturnValue('text', i, e, t, o);
            }
            return (t = ki._createBefore(n)), (this.position = t), this._formatReturnValue('elementStart', n, e, t, 1);
          }
          _formatReturnValue(t, e, n, o, i) {
            return (
              e instanceof Co &&
                (e.offsetInText + e.data.length == e.textNode.data.length &&
                  ('forward' != this.direction || (this.boundaries && this.boundaries.end.isEqual(this.position))
                    ? (n = ki._createAfter(e.textNode))
                    : ((o = ki._createAfter(e.textNode)), (this.position = o))),
                0 === e.offsetInText &&
                  ('backward' != this.direction || (this.boundaries && this.boundaries.start.isEqual(this.position))
                    ? (n = ki._createBefore(e.textNode))
                    : ((o = ki._createBefore(e.textNode)), (this.position = o)))),
              { done: !1, value: { type: t, item: e, previousPosition: n, nextPosition: o, length: i } }
            );
          }
        }
        class ki {
          constructor(t, e) {
            (this.parent = t), (this.offset = e);
          }
          get nodeAfter() {
            return this.parent.is('$text') ? null : this.parent.getChild(this.offset) || null;
          }
          get nodeBefore() {
            return this.parent.is('$text') ? null : this.parent.getChild(this.offset - 1) || null;
          }
          get isAtStart() {
            return 0 === this.offset;
          }
          get isAtEnd() {
            const t = this.parent.is('$text') ? this.parent.data.length : this.parent.childCount;
            return this.offset === t;
          }
          get root() {
            return this.parent.root;
          }
          get editableElement() {
            let t = this.parent;
            for (; !(t instanceof pi); ) {
              if (!t.parent) return null;
              t = t.parent;
            }
            return t;
          }
          getShiftedBy(t) {
            const e = ki._createAt(this),
              n = e.offset + t;
            return (e.offset = n < 0 ? 0 : n), e;
          }
          getLastMatchingPosition(t, e = {}) {
            e.startPosition = this;
            const n = new fi(e);
            return n.skip(t), n.position;
          }
          getAncestors() {
            return this.parent.is('documentFragment') ? [this.parent] : this.parent.getAncestors({ includeSelf: !0 });
          }
          getCommonAncestor(t) {
            const e = this.getAncestors(),
              n = t.getAncestors();
            let o = 0;
            for (; e[o] == n[o] && e[o]; ) o++;
            return 0 === o ? null : e[o - 1];
          }
          is(t) {
            return 'position' === t || 'view:position' === t;
          }
          isEqual(t) {
            return this.parent == t.parent && this.offset == t.offset;
          }
          isBefore(t) {
            return 'before' == this.compareWith(t);
          }
          isAfter(t) {
            return 'after' == this.compareWith(t);
          }
          compareWith(t) {
            if (this.root !== t.root) return 'different';
            if (this.isEqual(t)) return 'same';
            const e = this.parent.is('node') ? this.parent.getPath() : [],
              n = t.parent.is('node') ? t.parent.getPath() : [];
            e.push(this.offset), n.push(t.offset);
            const o = bo(e, n);
            switch (o) {
              case 'prefix':
                return 'before';
              case 'extension':
                return 'after';
              default:
                return e[o] < n[o] ? 'before' : 'after';
            }
          }
          getWalker(t = {}) {
            return (t.startPosition = this), new fi(t);
          }
          clone() {
            return new ki(this.parent, this.offset);
          }
          static _createAt(t, e) {
            if (t instanceof ki) return new this(t.parent, t.offset);
            {
              const n = t;
              if ('end' == e) e = n.is('$text') ? n.data.length : n.childCount;
              else {
                if ('before' == e) return this._createBefore(n);
                if ('after' == e) return this._createAfter(n);
                if (0 !== e && !e) throw new c.a('view-createpositionat-offset-required', n);
              }
              return new ki(n, e);
            }
          }
          static _createAfter(t) {
            if (t.is('$textProxy')) return new ki(t.textNode, t.offsetInText + t.data.length);
            if (!t.parent) throw new c.a('view-position-after-root', t, { root: t });
            return new ki(t.parent, t.index + 1);
          }
          static _createBefore(t) {
            if (t.is('$textProxy')) return new ki(t.textNode, t.offsetInText);
            if (!t.parent) throw new c.a('view-position-before-root', t, { root: t });
            return new ki(t.parent, t.index);
          }
        }
        class bi {
          constructor(t, e = null) {
            (this.start = t.clone()), (this.end = e ? e.clone() : t.clone());
          }
          *[Symbol.iterator]() {
            yield* new fi({ boundaries: this, ignoreElementEnd: !0 });
          }
          get isCollapsed() {
            return this.start.isEqual(this.end);
          }
          get isFlat() {
            return this.start.parent === this.end.parent;
          }
          get root() {
            return this.start.root;
          }
          getEnlarged() {
            let t = this.start.getLastMatchingPosition(wi, { direction: 'backward' }),
              e = this.end.getLastMatchingPosition(wi);
            return (
              t.parent.is('$text') && t.isAtStart && (t = ki._createBefore(t.parent)),
              e.parent.is('$text') && e.isAtEnd && (e = ki._createAfter(e.parent)),
              new bi(t, e)
            );
          }
          getTrimmed() {
            let t = this.start.getLastMatchingPosition(wi);
            if (t.isAfter(this.end) || t.isEqual(this.end)) return new bi(t, t);
            let e = this.end.getLastMatchingPosition(wi, { direction: 'backward' });
            const n = t.nodeAfter,
              o = e.nodeBefore;
            return (
              n && n.is('$text') && (t = new ki(n, 0)),
              o && o.is('$text') && (e = new ki(o, o.data.length)),
              new bi(t, e)
            );
          }
          isEqual(t) {
            return this == t || (this.start.isEqual(t.start) && this.end.isEqual(t.end));
          }
          containsPosition(t) {
            return t.isAfter(this.start) && t.isBefore(this.end);
          }
          containsRange(t, e = !1) {
            t.isCollapsed && (e = !1);
            const n = this.containsPosition(t.start) || (e && this.start.isEqual(t.start)),
              o = this.containsPosition(t.end) || (e && this.end.isEqual(t.end));
            return n && o;
          }
          getDifference(t) {
            const e = [];
            return (
              this.isIntersecting(t)
                ? (this.containsPosition(t.start) && e.push(new bi(this.start, t.start)),
                  this.containsPosition(t.end) && e.push(new bi(t.end, this.end)))
                : e.push(this.clone()),
              e
            );
          }
          getIntersection(t) {
            if (this.isIntersecting(t)) {
              let e = this.start,
                n = this.end;
              return (
                this.containsPosition(t.start) && (e = t.start),
                this.containsPosition(t.end) && (n = t.end),
                new bi(e, n)
              );
            }
            return null;
          }
          getWalker(t = {}) {
            return (t.boundaries = this), new fi(t);
          }
          getCommonAncestor() {
            return this.start.getCommonAncestor(this.end);
          }
          getContainedElement() {
            if (this.isCollapsed) return null;
            let t = this.start.nodeAfter,
              e = this.end.nodeBefore;
            return (
              this.start.parent.is('$text') &&
                this.start.isAtEnd &&
                this.start.parent.nextSibling &&
                (t = this.start.parent.nextSibling),
              this.end.parent.is('$text') &&
                this.end.isAtStart &&
                this.end.parent.previousSibling &&
                (e = this.end.parent.previousSibling),
              t && t.is('element') && t === e ? t : null
            );
          }
          clone() {
            return new bi(this.start, this.end);
          }
          *getItems(t = {}) {
            (t.boundaries = this), (t.ignoreElementEnd = !0);
            const e = new fi(t);
            for (const t of e) yield t.item;
          }
          *getPositions(t = {}) {
            t.boundaries = this;
            const e = new fi(t);
            yield e.position;
            for (const t of e) yield t.nextPosition;
          }
          is(t) {
            return 'range' === t || 'view:range' === t;
          }
          isIntersecting(t) {
            return this.start.isBefore(t.end) && this.end.isAfter(t.start);
          }
          static _createFromParentsAndOffsets(t, e, n, o) {
            return new this(new ki(t, e), new ki(n, o));
          }
          static _createFromPositionAndShift(t, e) {
            const n = t,
              o = t.getShiftedBy(e);
            return e > 0 ? new this(n, o) : new this(o, n);
          }
          static _createIn(t) {
            return this._createFromParentsAndOffsets(t, 0, t, t.childCount);
          }
          static _createOn(t) {
            const e = t.is('$textProxy') ? t.offsetSize : 1;
            return this._createFromPositionAndShift(ki._createBefore(t), e);
          }
        }
        function wi(t) {
          return !(!t.item.is('attributeElement') && !t.item.is('uiElement'));
        }
        function Ai(t) {
          let e = 0;
          for (const n of t) e++;
          return e;
        }
        class _i {
          constructor(t = null, e, n) {
            (this._ranges = []),
              (this._lastRangeBackward = !1),
              (this._isFake = !1),
              (this._fakeSelectionLabel = ''),
              this.setTo(t, e, n);
          }
          get isFake() {
            return this._isFake;
          }
          get fakeSelectionLabel() {
            return this._fakeSelectionLabel;
          }
          get anchor() {
            if (!this._ranges.length) return null;
            const t = this._ranges[this._ranges.length - 1];
            return (this._lastRangeBackward ? t.end : t.start).clone();
          }
          get focus() {
            if (!this._ranges.length) return null;
            const t = this._ranges[this._ranges.length - 1];
            return (this._lastRangeBackward ? t.start : t.end).clone();
          }
          get isCollapsed() {
            return 1 === this.rangeCount && this._ranges[0].isCollapsed;
          }
          get rangeCount() {
            return this._ranges.length;
          }
          get isBackward() {
            return !this.isCollapsed && this._lastRangeBackward;
          }
          get editableElement() {
            return this.anchor ? this.anchor.editableElement : null;
          }
          *getRanges() {
            for (const t of this._ranges) yield t.clone();
          }
          getFirstRange() {
            let t = null;
            for (const e of this._ranges) (t && !e.start.isBefore(t.start)) || (t = e);
            return t ? t.clone() : null;
          }
          getLastRange() {
            let t = null;
            for (const e of this._ranges) (t && !e.end.isAfter(t.end)) || (t = e);
            return t ? t.clone() : null;
          }
          getFirstPosition() {
            const t = this.getFirstRange();
            return t ? t.start.clone() : null;
          }
          getLastPosition() {
            const t = this.getLastRange();
            return t ? t.end.clone() : null;
          }
          isEqual(t) {
            if (this.isFake != t.isFake) return !1;
            if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel) return !1;
            if (this.rangeCount != t.rangeCount) return !1;
            if (0 === this.rangeCount) return !0;
            if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) return !1;
            for (const e of this._ranges) {
              let n = !1;
              for (const o of t._ranges)
                if (e.isEqual(o)) {
                  n = !0;
                  break;
                }
              if (!n) return !1;
            }
            return !0;
          }
          isSimilar(t) {
            if (this.isBackward != t.isBackward) return !1;
            const e = Ai(this.getRanges());
            if (e != Ai(t.getRanges())) return !1;
            if (0 == e) return !0;
            for (let e of this.getRanges()) {
              e = e.getTrimmed();
              let n = !1;
              for (let o of t.getRanges())
                if (((o = o.getTrimmed()), e.start.isEqual(o.start) && e.end.isEqual(o.end))) {
                  n = !0;
                  break;
                }
              if (!n) return !1;
            }
            return !0;
          }
          getSelectedElement() {
            return 1 !== this.rangeCount ? null : this.getFirstRange().getContainedElement();
          }
          setTo(t, e, n) {
            if (null === t) this._setRanges([]), this._setFakeOptions(e);
            else if (t instanceof _i || t instanceof Ci)
              this._setRanges(t.getRanges(), t.isBackward),
                this._setFakeOptions({ fake: t.isFake, label: t.fakeSelectionLabel });
            else if (t instanceof bi) this._setRanges([t], e && e.backward), this._setFakeOptions(e);
            else if (t instanceof ki) this._setRanges([new bi(t)]), this._setFakeOptions(e);
            else if (t instanceof Ao) {
              const o = !!n && !!n.backward;
              let i;
              if (void 0 === e) throw new c.a('view-selection-setto-required-second-parameter', this);
              (i = 'in' == e ? bi._createIn(t) : 'on' == e ? bi._createOn(t) : new bi(ki._createAt(t, e))),
                this._setRanges([i], o),
                this._setFakeOptions(n);
            } else {
              if (!ao(t)) throw new c.a('view-selection-setto-not-selectable', this);
              this._setRanges(t, e && e.backward), this._setFakeOptions(e);
            }
            this.fire('change');
          }
          setFocus(t, e) {
            if (null === this.anchor) throw new c.a('view-selection-setfocus-no-ranges', this);
            const n = ki._createAt(t, e);
            if ('same' == n.compareWith(this.focus)) return;
            const o = this.anchor;
            this._ranges.pop(),
              'before' == n.compareWith(o) ? this._addRange(new bi(n, o), !0) : this._addRange(new bi(o, n)),
              this.fire('change');
          }
          is(t) {
            return 'selection' === t || 'view:selection' === t;
          }
          _setRanges(t, e = !1) {
            (t = Array.from(t)), (this._ranges = []);
            for (const e of t) this._addRange(e);
            this._lastRangeBackward = !!e;
          }
          _setFakeOptions(t = {}) {
            (this._isFake = !!t.fake), (this._fakeSelectionLabel = (t.fake && t.label) || '');
          }
          _addRange(t, e = !1) {
            if (!(t instanceof bi)) throw new c.a('view-selection-add-range-not-range', this);
            this._pushRange(t), (this._lastRangeBackward = !!e);
          }
          _pushRange(t) {
            for (const e of this._ranges)
              if (t.isIntersecting(e))
                throw new c.a('view-selection-range-intersects', this, { addedRange: t, intersectingRange: e });
            this._ranges.push(new bi(t.start, t.end));
          }
        }
        Yt(_i, h);
        class Ci {
          constructor(t = null, e, n) {
            (this._selection = new _i()), this._selection.delegate('change').to(this), this._selection.setTo(t, e, n);
          }
          get isFake() {
            return this._selection.isFake;
          }
          get fakeSelectionLabel() {
            return this._selection.fakeSelectionLabel;
          }
          get anchor() {
            return this._selection.anchor;
          }
          get focus() {
            return this._selection.focus;
          }
          get isCollapsed() {
            return this._selection.isCollapsed;
          }
          get rangeCount() {
            return this._selection.rangeCount;
          }
          get isBackward() {
            return this._selection.isBackward;
          }
          get editableElement() {
            return this._selection.editableElement;
          }
          get _ranges() {
            return this._selection._ranges;
          }
          *getRanges() {
            yield* this._selection.getRanges();
          }
          getFirstRange() {
            return this._selection.getFirstRange();
          }
          getLastRange() {
            return this._selection.getLastRange();
          }
          getFirstPosition() {
            return this._selection.getFirstPosition();
          }
          getLastPosition() {
            return this._selection.getLastPosition();
          }
          getSelectedElement() {
            return this._selection.getSelectedElement();
          }
          isEqual(t) {
            return this._selection.isEqual(t);
          }
          isSimilar(t) {
            return this._selection.isSimilar(t);
          }
          is(t) {
            return (
              'selection' === t || 'documentSelection' == t || 'view:selection' == t || 'view:documentSelection' == t
            );
          }
          _setTo(t, e, n) {
            this._selection.setTo(t, e, n);
          }
          _setFocus(t, e) {
            this._selection.setFocus(t, e);
          }
        }
        Yt(Ci, h);
        class vi extends i {
          constructor(t, e, n) {
            super(t, e), (this.startRange = n), (this._eventPhase = 'none'), (this._currentTarget = null);
          }
          get eventPhase() {
            return this._eventPhase;
          }
          get currentTarget() {
            return this._currentTarget;
          }
        }
        const yi = Symbol('bubbling contexts');
        var xi = {
          fire(t, ...e) {
            try {
              const n = t instanceof i ? t : new i(this, t),
                o = Bi(this);
              if (!o.size) return;
              if ((Ei(n, 'capturing', this), Di(o, '$capture', n, ...e))) return n.return;
              const r = n.startRange || this.selection.getFirstRange(),
                s = r ? r.getContainedElement() : null,
                a = !!s && Boolean(Si(o, s));
              let c =
                s ||
                (function (t) {
                  if (!t) return null;
                  const e = t.start.parent,
                    n = t.end.parent,
                    o = e.getPath(),
                    i = n.getPath();
                  return o.length > i.length ? e : n;
                })(r);
              if ((Ei(n, 'atTarget', c), !a)) {
                if (Di(o, '$text', n, ...e)) return n.return;
                Ei(n, 'bubbling', c);
              }
              for (; c; ) {
                if (c.is('rootElement')) {
                  if (Di(o, '$root', n, ...e)) return n.return;
                } else if (c.is('element') && Di(o, c.name, n, ...e)) return n.return;
                if (Di(o, c, n, ...e)) return n.return;
                (c = c.parent), Ei(n, 'bubbling', c);
              }
              return Ei(n, 'bubbling', this), Di(o, '$document', n, ...e), n.return;
            } catch (t) {
              c.a.rethrowUnexpectedError(t, this);
            }
          },
          _addEventListener(t, e, n) {
            const o = ho(n.context || '$document'),
              i = Bi(this);
            for (const r of o) {
              let o = i.get(r);
              o || ((o = Object.create(h)), i.set(r, o)), this.listenTo(o, t, e, n);
            }
          },
          _removeEventListener(t, e) {
            const n = Bi(this);
            for (const o of n.values()) this.stopListening(o, t, e);
          },
        };
        function Ei(t, e, n) {
          t instanceof vi && ((t._eventPhase = e), (t._currentTarget = n));
        }
        function Di(t, e, n, ...o) {
          const i = 'string' == typeof e ? t.get(e) : Si(t, e);
          return !!i && (i.fire(n, ...o), n.stop.called);
        }
        function Si(t, e) {
          for (const [n, o] of t) if ('function' == typeof n && n(e)) return o;
          return null;
        }
        function Bi(t) {
          return t[yi] || (t[yi] = new Map()), t[yi];
        }
        class Ti {
          constructor(t) {
            (this.selection = new Ci()),
              (this.roots = new co({ idProperty: 'rootName' })),
              (this.stylesProcessor = t),
              this.set('isReadOnly', !1),
              this.set('isFocused', !1),
              this.set('isComposing', !1),
              (this._postFixers = new Set());
          }
          getRoot(t = 'main') {
            return this.roots.get(t);
          }
          registerPostFixer(t) {
            this._postFixers.add(t);
          }
          destroy() {
            this.roots.map(t => t.destroy()), this.stopListening();
          }
          _callPostFixers(t) {
            let e = !1;
            do {
              for (const n of this._postFixers) if (((e = n(t)), e)) break;
            } while (e);
          }
        }
        Yt(Ti, xi), Yt(Ti, jt);
        class Pi extends li {
          constructor(t, e, n, o) {
            super(t, e, n, o),
              (this.getFillerOffset = Ii),
              (this._priority = 10),
              (this._id = null),
              (this._clonesGroup = null);
          }
          get priority() {
            return this._priority;
          }
          get id() {
            return this._id;
          }
          getElementsWithSameId() {
            if (null === this.id) throw new c.a('attribute-element-get-elements-with-same-id-no-id', this);
            return new Set(this._clonesGroup);
          }
          is(t, e = null) {
            return e
              ? e === this.name &&
                  ('attributeElement' === t || 'view:attributeElement' === t || 'element' === t || 'view:element' === t)
              : 'attributeElement' === t ||
                  'view:attributeElement' === t ||
                  'element' === t ||
                  'view:element' === t ||
                  'node' === t ||
                  'view:node' === t;
          }
          isSimilar(t) {
            return null !== this.id || null !== t.id
              ? this.id === t.id
              : super.isSimilar(t) && this.priority == t.priority;
          }
          _clone(t) {
            const e = super._clone(t);
            return (e._priority = this._priority), (e._id = this._id), e;
          }
        }
        function Ii() {
          if (zi(this)) return null;
          let t = this.parent;
          for (; t && t.is('attributeElement'); ) {
            if (zi(t) > 1) return null;
            t = t.parent;
          }
          return !t || zi(t) > 1 ? null : this.childCount;
        }
        function zi(t) {
          return Array.from(t.getChildren()).filter(t => !t.is('uiElement')).length;
        }
        Pi.DEFAULT_PRIORITY = 10;
        class Fi extends li {
          constructor(t, e, n, o) {
            super(t, e, n, o), (this._isAllowedInsideAttributeElement = !0), (this.getFillerOffset = Ri);
          }
          is(t, e = null) {
            return e
              ? e === this.name &&
                  ('emptyElement' === t || 'view:emptyElement' === t || 'element' === t || 'view:element' === t)
              : 'emptyElement' === t ||
                  'view:emptyElement' === t ||
                  'element' === t ||
                  'view:element' === t ||
                  'node' === t ||
                  'view:node' === t;
          }
          _insertChild(t, e) {
            if (e && (e instanceof Ao || Array.from(e).length > 0))
              throw new c.a('view-emptyelement-cannot-add', [this, e]);
          }
        }
        function Ri() {
          return null;
        }
        const Oi = navigator.userAgent.toLowerCase();
        var Mi = {
          isMac: (function (t) {
            return t.indexOf('macintosh') > -1;
          })(Oi),
          isGecko: (function (t) {
            return !!t.match(/gecko\/\d+/);
          })(Oi),
          isSafari: (function (t) {
            return t.indexOf(' applewebkit/') > -1 && -1 === t.indexOf('chrome');
          })(Oi),
          isAndroid: (function (t) {
            return t.indexOf('android') > -1;
          })(Oi),
          isBlink: (function (t) {
            return t.indexOf('chrome/') > -1 && t.indexOf('edge/') < 0;
          })(Oi),
          features: {
            isRegExpUnicodePropertySupported: (function () {
              let t = !1;
              try {
                t = 0 === 'ć'.search(new RegExp('[\\p{L}]', 'u'));
              } catch (t) {}
              return t;
            })(),
          },
        };
        const Ni = { ctrl: '⌃', cmd: '⌘', alt: '⌥', shift: '⇧' },
          Vi = { ctrl: 'Ctrl+', alt: 'Alt+', shift: 'Shift+' },
          Li = (function () {
            const t = {
              arrowleft: 37,
              arrowup: 38,
              arrowright: 39,
              arrowdown: 40,
              backspace: 8,
              delete: 46,
              enter: 13,
              space: 32,
              esc: 27,
              tab: 9,
              ctrl: 1114112,
              shift: 2228224,
              alt: 4456448,
              cmd: 8912896,
            };
            for (let e = 65; e <= 90; e++) {
              const n = String.fromCharCode(e);
              t[n.toLowerCase()] = e;
            }
            for (let e = 48; e <= 57; e++) t[e - 48] = e;
            for (let e = 112; e <= 123; e++) t['f' + (e - 111)] = e;
            return t;
          })(),
          Ki = Object.fromEntries(Object.entries(Li).map(([t, e]) => [e, t.charAt(0).toUpperCase() + t.slice(1)]));
        function qi(t) {
          let e;
          if ('string' == typeof t) {
            if (((e = Li[t.toLowerCase()]), !e)) throw new c.a('keyboard-unknown-key', null, { key: t });
          } else
            e =
              t.keyCode +
              (t.altKey ? Li.alt : 0) +
              (t.ctrlKey ? Li.ctrl : 0) +
              (t.shiftKey ? Li.shift : 0) +
              (t.metaKey ? Li.cmd : 0);
          return e;
        }
        function Hi(t) {
          return (
            'string' == typeof t &&
              (t = (function (t) {
                return t.split('+').map(t => t.trim());
              })(t)),
            t
              .map(t =>
                'string' == typeof t
                  ? (function (t) {
                      if (t.endsWith('!')) return qi(t.slice(0, -1));
                      const e = qi(t);
                      return Mi.isMac && e == Li.ctrl ? Li.cmd : e;
                    })(t)
                  : t,
              )
              .reduce((t, e) => e + t, 0)
          );
        }
        function ji(t) {
          let e = Hi(t);
          return (
            Object.entries(Mi.isMac ? Ni : Vi).reduce(
              (t, [n, o]) => (0 != (e & Li[n]) && ((e &= ~Li[n]), (t += o)), t),
              '',
            ) + (e ? Ki[e] : '')
          );
        }
        function $i(t, e) {
          const n = 'ltr' === e;
          switch (t) {
            case Li.arrowleft:
              return n ? 'left' : 'right';
            case Li.arrowright:
              return n ? 'right' : 'left';
            case Li.arrowup:
              return 'up';
            case Li.arrowdown:
              return 'down';
          }
        }
        function Gi(t, e) {
          const n = $i(t, e);
          return 'down' === n || 'right' === n;
        }
        class Wi extends li {
          constructor(t, e, n, o) {
            super(t, e, n, o), (this._isAllowedInsideAttributeElement = !0), (this.getFillerOffset = Ji);
          }
          is(t, e = null) {
            return e
              ? e === this.name &&
                  ('uiElement' === t || 'view:uiElement' === t || 'element' === t || 'view:element' === t)
              : 'uiElement' === t ||
                  'view:uiElement' === t ||
                  'element' === t ||
                  'view:element' === t ||
                  'node' === t ||
                  'view:node' === t;
          }
          _insertChild(t, e) {
            if (e && (e instanceof Ao || Array.from(e).length > 0)) throw new c.a('view-uielement-cannot-add', this);
          }
          render(t) {
            return this.toDomElement(t);
          }
          toDomElement(t) {
            const e = t.createElement(this.name);
            for (const t of this.getAttributeKeys()) e.setAttribute(t, this.getAttribute(t));
            return e;
          }
        }
        function Ui(t) {
          t.document.on(
            'arrowKey',
            (e, n) =>
              (function (t, e, n) {
                if (e.keyCode == Li.arrowright) {
                  const t = e.domTarget.ownerDocument.defaultView.getSelection(),
                    o = 1 == t.rangeCount && t.getRangeAt(0).collapsed;
                  if (o || e.shiftKey) {
                    const e = t.focusNode,
                      i = t.focusOffset,
                      r = n.domPositionToView(e, i);
                    if (null === r) return;
                    let s = !1;
                    const a = r.getLastMatchingPosition(
                      t => (
                        t.item.is('uiElement') && (s = !0), !(!t.item.is('uiElement') && !t.item.is('attributeElement'))
                      ),
                    );
                    if (s) {
                      const e = n.viewPositionToDom(a);
                      o ? t.collapse(e.parent, e.offset) : t.extend(e.parent, e.offset);
                    }
                  }
                }
              })(0, n, t.domConverter),
            { priority: 'low' },
          );
        }
        function Ji() {
          return null;
        }
        class Yi extends li {
          constructor(t, e, n, o) {
            super(t, e, n, o), (this._isAllowedInsideAttributeElement = !0), (this.getFillerOffset = Qi);
          }
          is(t, e = null) {
            return e
              ? e === this.name &&
                  ('rawElement' === t || 'view:rawElement' === t || 'element' === t || 'view:element' === t)
              : 'rawElement' === t ||
                  'view:rawElement' === t ||
                  t === this.name ||
                  t === 'view:' + this.name ||
                  'element' === t ||
                  'view:element' === t ||
                  'node' === t ||
                  'view:node' === t;
          }
          _insertChild(t, e) {
            if (e && (e instanceof Ao || Array.from(e).length > 0))
              throw new c.a('view-rawelement-cannot-add', [this, e]);
          }
        }
        function Qi() {
          return null;
        }
        class Xi {
          constructor(t, e) {
            (this.document = t), (this._children = []), e && this._insertChild(0, e);
          }
          [Symbol.iterator]() {
            return this._children[Symbol.iterator]();
          }
          get childCount() {
            return this._children.length;
          }
          get isEmpty() {
            return 0 === this.childCount;
          }
          get root() {
            return this;
          }
          get parent() {
            return null;
          }
          is(t) {
            return 'documentFragment' === t || 'view:documentFragment' === t;
          }
          _appendChild(t) {
            return this._insertChild(this.childCount, t);
          }
          getChild(t) {
            return this._children[t];
          }
          getChildIndex(t) {
            return this._children.indexOf(t);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          _insertChild(t, e) {
            this._fireChange('children', this);
            let n = 0;
            const o = (function (t, e) {
              if ('string' == typeof e) return [new _o(t, e)];
              ao(e) || (e = [e]);
              return Array.from(e).map(e =>
                'string' == typeof e ? new _o(t, e) : e instanceof Co ? new _o(t, e.data) : e,
              );
            })(this.document, e);
            for (const e of o)
              null !== e.parent && e._remove(), (e.parent = this), this._children.splice(t, 0, e), t++, n++;
            return n;
          }
          _removeChildren(t, e = 1) {
            this._fireChange('children', this);
            for (let n = t; n < t + e; n++) this._children[n].parent = null;
            return this._children.splice(t, e);
          }
          _fireChange(t, e) {
            this.fire('change:' + t, e);
          }
        }
        Yt(Xi, h);
        class Zi {
          constructor(t) {
            (this.document = t), (this._cloneGroups = new Map());
          }
          setSelection(t, e, n) {
            this.document.selection._setTo(t, e, n);
          }
          setSelectionFocus(t, e) {
            this.document.selection._setFocus(t, e);
          }
          createDocumentFragment(t) {
            return new Xi(this.document, t);
          }
          createText(t) {
            return new _o(this.document, t);
          }
          createAttributeElement(t, e, n = {}) {
            const o = new Pi(this.document, t, e);
            return 'number' == typeof n.priority && (o._priority = n.priority), n.id && (o._id = n.id), o;
          }
          createContainerElement(t, e, n = {}) {
            const o = new hi(this.document, t, e);
            return (
              void 0 !== n.isAllowedInsideAttributeElement &&
                (o._isAllowedInsideAttributeElement = n.isAllowedInsideAttributeElement),
              o
            );
          }
          createEditableElement(t, e) {
            const n = new pi(this.document, t, e);
            return (n._document = this.document), n;
          }
          createEmptyElement(t, e, n = {}) {
            const o = new Fi(this.document, t, e);
            return (
              void 0 !== n.isAllowedInsideAttributeElement &&
                (o._isAllowedInsideAttributeElement = n.isAllowedInsideAttributeElement),
              o
            );
          }
          createUIElement(t, e, n, o = {}) {
            const i = new Wi(this.document, t, e);
            return (
              n && (i.render = n),
              void 0 !== o.isAllowedInsideAttributeElement &&
                (i._isAllowedInsideAttributeElement = o.isAllowedInsideAttributeElement),
              i
            );
          }
          createRawElement(t, e, n, o = {}) {
            const i = new Yi(this.document, t, e);
            return (
              (i.render = n || (() => {})),
              void 0 !== o.isAllowedInsideAttributeElement &&
                (i._isAllowedInsideAttributeElement = o.isAllowedInsideAttributeElement),
              i
            );
          }
          setAttribute(t, e, n) {
            n._setAttribute(t, e);
          }
          removeAttribute(t, e) {
            e._removeAttribute(t);
          }
          addClass(t, e) {
            e._addClass(t);
          }
          removeClass(t, e) {
            e._removeClass(t);
          }
          setStyle(t, e, n) {
            le(t) && void 0 === n && (n = e), n._setStyle(t, e);
          }
          removeStyle(t, e) {
            e._removeStyle(t);
          }
          setCustomProperty(t, e, n) {
            n._setCustomProperty(t, e);
          }
          removeCustomProperty(t, e) {
            return e._removeCustomProperty(t);
          }
          breakAttributes(t) {
            return t instanceof ki ? this._breakAttributes(t) : this._breakAttributesRange(t);
          }
          breakContainer(t) {
            const e = t.parent;
            if (!e.is('containerElement')) throw new c.a('view-writer-break-non-container-element', this.document);
            if (!e.parent) throw new c.a('view-writer-break-root', this.document);
            if (t.isAtStart) return ki._createBefore(e);
            if (!t.isAtEnd) {
              const n = e._clone(!1);
              this.insert(ki._createAfter(e), n);
              const o = new bi(t, ki._createAt(e, 'end')),
                i = new ki(n, 0);
              this.move(o, i);
            }
            return ki._createAfter(e);
          }
          mergeAttributes(t) {
            const e = t.offset,
              n = t.parent;
            if (n.is('$text')) return t;
            if (n.is('attributeElement') && 0 === n.childCount) {
              const t = n.parent,
                e = n.index;
              return n._remove(), this._removeFromClonedElementsGroup(n), this.mergeAttributes(new ki(t, e));
            }
            const o = n.getChild(e - 1),
              i = n.getChild(e);
            if (!o || !i) return t;
            if (o.is('$text') && i.is('$text')) return ir(o, i);
            if (o.is('attributeElement') && i.is('attributeElement') && o.isSimilar(i)) {
              const t = o.childCount;
              return (
                o._appendChild(i.getChildren()),
                i._remove(),
                this._removeFromClonedElementsGroup(i),
                this.mergeAttributes(new ki(o, t))
              );
            }
            return t;
          }
          mergeContainers(t) {
            const e = t.nodeBefore,
              n = t.nodeAfter;
            if (!(e && n && e.is('containerElement') && n.is('containerElement')))
              throw new c.a('view-writer-merge-containers-invalid-position', this.document);
            const o = e.getChild(e.childCount - 1),
              i = o instanceof _o ? ki._createAt(o, 'end') : ki._createAt(e, 'end');
            return this.move(bi._createIn(n), ki._createAt(e, 'end')), this.remove(bi._createOn(n)), i;
          }
          insert(t, e) {
            rr((e = ao(e) ? [...e] : [e]), this.document);
            const n = e.reduce((t, e) => {
              const n = t[t.length - 1],
                o = !(e.is('uiElement') && e.isAllowedInsideAttributeElement);
              return n && n.breakAttributes == o ? n.nodes.push(e) : t.push({ breakAttributes: o, nodes: [e] }), t;
            }, []);
            let o = null,
              i = t;
            for (const { nodes: t, breakAttributes: e } of n) {
              const n = this._insertNodes(i, t, e);
              o || (o = n.start), (i = n.end);
            }
            return o ? new bi(o, i) : new bi(t);
          }
          remove(t) {
            const e = t instanceof bi ? t : bi._createOn(t);
            if ((cr(e, this.document), e.isCollapsed)) return new Xi(this.document);
            const { start: n, end: o } = this._breakAttributesRange(e, !0),
              i = n.parent,
              r = o.offset - n.offset,
              s = i._removeChildren(n.offset, r);
            for (const t of s) this._removeFromClonedElementsGroup(t);
            const a = this.mergeAttributes(n);
            return (e.start = a), (e.end = a.clone()), new Xi(this.document, s);
          }
          clear(t, e) {
            cr(t, this.document);
            const n = t.getWalker({ direction: 'backward', ignoreElementEnd: !0 });
            for (const o of n) {
              const n = o.item;
              let i;
              if (n.is('element') && e.isSimilar(n)) i = bi._createOn(n);
              else if (!o.nextPosition.isAfter(t.start) && n.is('$textProxy')) {
                const t = n.getAncestors().find(t => t.is('element') && e.isSimilar(t));
                t && (i = bi._createIn(t));
              }
              i &&
                (i.end.isAfter(t.end) && (i.end = t.end),
                i.start.isBefore(t.start) && (i.start = t.start),
                this.remove(i));
            }
          }
          move(t, e) {
            let n;
            if (e.isAfter(t.end)) {
              const o = (e = this._breakAttributes(e, !0)).parent,
                i = o.childCount;
              (t = this._breakAttributesRange(t, !0)), (n = this.remove(t)), (e.offset += o.childCount - i);
            } else n = this.remove(t);
            return this.insert(e, n);
          }
          wrap(t, e) {
            if (!(e instanceof Pi)) throw new c.a('view-writer-wrap-invalid-attribute', this.document);
            if ((cr(t, this.document), t.isCollapsed)) {
              let o = t.start;
              o.parent.is('element') &&
                ((n = o.parent), !Array.from(n.getChildren()).some(t => !t.is('uiElement'))) &&
                (o = o.getLastMatchingPosition(t => t.item.is('uiElement'))),
                (o = this._wrapPosition(o, e));
              const i = this.document.selection;
              return i.isCollapsed && i.getFirstPosition().isEqual(t.start) && this.setSelection(o), new bi(o);
            }
            return this._wrapRange(t, e);
            var n;
          }
          unwrap(t, e) {
            if (!(e instanceof Pi)) throw new c.a('view-writer-unwrap-invalid-attribute', this.document);
            if ((cr(t, this.document), t.isCollapsed)) return t;
            const { start: n, end: o } = this._breakAttributesRange(t, !0),
              i = n.parent,
              r = this._unwrapChildren(i, n.offset, o.offset, e),
              s = this.mergeAttributes(r.start);
            s.isEqual(r.start) || r.end.offset--;
            const a = this.mergeAttributes(r.end);
            return new bi(s, a);
          }
          rename(t, e) {
            const n = new hi(this.document, t, e.getAttributes());
            return (
              this.insert(ki._createAfter(e), n),
              this.move(bi._createIn(e), ki._createAt(n, 0)),
              this.remove(bi._createOn(e)),
              n
            );
          }
          clearClonedElementsGroup(t) {
            this._cloneGroups.delete(t);
          }
          createPositionAt(t, e) {
            return ki._createAt(t, e);
          }
          createPositionAfter(t) {
            return ki._createAfter(t);
          }
          createPositionBefore(t) {
            return ki._createBefore(t);
          }
          createRange(t, e) {
            return new bi(t, e);
          }
          createRangeOn(t) {
            return bi._createOn(t);
          }
          createRangeIn(t) {
            return bi._createIn(t);
          }
          createSelection(t, e, n) {
            return new _i(t, e, n);
          }
          _insertNodes(t, e, n) {
            let o, i;
            if (((o = n ? tr(t) : t.parent.is('$text') ? t.parent.parent : t.parent), !o))
              throw new c.a('view-writer-invalid-position-container', this.document);
            i = n ? this._breakAttributes(t, !0) : t.parent.is('$text') ? or(t) : t;
            const r = o._insertChild(i.offset, e);
            for (const t of e) this._addToClonedElementsGroup(t);
            const s = i.getShiftedBy(r),
              a = this.mergeAttributes(i);
            a.isEqual(i) || s.offset--;
            const l = this.mergeAttributes(s);
            return new bi(a, l);
          }
          _wrapChildren(t, e, n, o) {
            let i = e;
            const r = [];
            for (; i < n; ) {
              const e = t.getChild(i),
                n = e.is('$text'),
                s = e.is('attributeElement'),
                a = e.isAllowedInsideAttributeElement;
              if (s && this._wrapAttributeElement(o, e)) r.push(new ki(t, i));
              else if (n || a || (s && er(o, e))) {
                const n = o._clone();
                e._remove(),
                  n._appendChild(e),
                  t._insertChild(i, n),
                  this._addToClonedElementsGroup(n),
                  r.push(new ki(t, i));
              } else s && this._wrapChildren(e, 0, e.childCount, o);
              i++;
            }
            let s = 0;
            for (const t of r) {
              if (((t.offset -= s), t.offset == e)) continue;
              this.mergeAttributes(t).isEqual(t) || (s++, n--);
            }
            return bi._createFromParentsAndOffsets(t, e, t, n);
          }
          _unwrapChildren(t, e, n, o) {
            let i = e;
            const r = [];
            for (; i < n; ) {
              const e = t.getChild(i);
              if (e.is('attributeElement'))
                if (e.isSimilar(o)) {
                  const o = e.getChildren(),
                    s = e.childCount;
                  e._remove(),
                    t._insertChild(i, o),
                    this._removeFromClonedElementsGroup(e),
                    r.push(new ki(t, i), new ki(t, i + s)),
                    (i += s),
                    (n += s - 1);
                } else
                  this._unwrapAttributeElement(o, e)
                    ? (r.push(new ki(t, i), new ki(t, i + 1)), i++)
                    : (this._unwrapChildren(e, 0, e.childCount, o), i++);
              else i++;
            }
            let s = 0;
            for (const t of r) {
              if (((t.offset -= s), t.offset == e || t.offset == n)) continue;
              this.mergeAttributes(t).isEqual(t) || (s++, n--);
            }
            return bi._createFromParentsAndOffsets(t, e, t, n);
          }
          _wrapRange(t, e) {
            const { start: n, end: o } = this._breakAttributesRange(t, !0),
              i = n.parent,
              r = this._wrapChildren(i, n.offset, o.offset, e),
              s = this.mergeAttributes(r.start);
            s.isEqual(r.start) || r.end.offset--;
            const a = this.mergeAttributes(r.end);
            return new bi(s, a);
          }
          _wrapPosition(t, e) {
            if (e.isSimilar(t.parent)) return nr(t.clone());
            t.parent.is('$text') && (t = or(t));
            const n = this.createAttributeElement();
            (n._priority = Number.POSITIVE_INFINITY), (n.isSimilar = () => !1), t.parent._insertChild(t.offset, n);
            const o = new bi(t, t.getShiftedBy(1));
            this.wrap(o, e);
            const i = new ki(n.parent, n.index);
            n._remove();
            const r = i.nodeBefore,
              s = i.nodeAfter;
            return r instanceof _o && s instanceof _o ? ir(r, s) : nr(i);
          }
          _wrapAttributeElement(t, e) {
            if (!lr(t, e)) return !1;
            if (t.name !== e.name || t.priority !== e.priority) return !1;
            for (const n of t.getAttributeKeys())
              if ('class' !== n && 'style' !== n && e.hasAttribute(n) && e.getAttribute(n) !== t.getAttribute(n))
                return !1;
            for (const n of t.getStyleNames()) if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) return !1;
            for (const n of t.getAttributeKeys())
              'class' !== n && 'style' !== n && (e.hasAttribute(n) || this.setAttribute(n, t.getAttribute(n), e));
            for (const n of t.getStyleNames()) e.hasStyle(n) || this.setStyle(n, t.getStyle(n), e);
            for (const n of t.getClassNames()) e.hasClass(n) || this.addClass(n, e);
            return !0;
          }
          _unwrapAttributeElement(t, e) {
            if (!lr(t, e)) return !1;
            if (t.name !== e.name || t.priority !== e.priority) return !1;
            for (const n of t.getAttributeKeys())
              if ('class' !== n && 'style' !== n && (!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n)))
                return !1;
            if (!e.hasClass(...t.getClassNames())) return !1;
            for (const n of t.getStyleNames()) if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) return !1;
            for (const n of t.getAttributeKeys()) 'class' !== n && 'style' !== n && this.removeAttribute(n, e);
            return (
              this.removeClass(Array.from(t.getClassNames()), e), this.removeStyle(Array.from(t.getStyleNames()), e), !0
            );
          }
          _breakAttributesRange(t, e = !1) {
            const n = t.start,
              o = t.end;
            if ((cr(t, this.document), t.isCollapsed)) {
              const n = this._breakAttributes(t.start, e);
              return new bi(n, n);
            }
            const i = this._breakAttributes(o, e),
              r = i.parent.childCount,
              s = this._breakAttributes(n, e);
            return (i.offset += i.parent.childCount - r), new bi(s, i);
          }
          _breakAttributes(t, e = !1) {
            const n = t.offset,
              o = t.parent;
            if (t.parent.is('emptyElement')) throw new c.a('view-writer-cannot-break-empty-element', this.document);
            if (t.parent.is('uiElement')) throw new c.a('view-writer-cannot-break-ui-element', this.document);
            if (t.parent.is('rawElement')) throw new c.a('view-writer-cannot-break-raw-element', this.document);
            if (!e && o.is('$text') && ar(o.parent)) return t.clone();
            if (ar(o)) return t.clone();
            if (o.is('$text')) return this._breakAttributes(or(t), e);
            if (n == o.childCount) {
              const t = new ki(o.parent, o.index + 1);
              return this._breakAttributes(t, e);
            }
            if (0 === n) {
              const t = new ki(o.parent, o.index);
              return this._breakAttributes(t, e);
            }
            {
              const t = o.index + 1,
                i = o._clone();
              o.parent._insertChild(t, i), this._addToClonedElementsGroup(i);
              const r = o.childCount - n,
                s = o._removeChildren(n, r);
              i._appendChild(s);
              const a = new ki(o.parent, t);
              return this._breakAttributes(a, e);
            }
          }
          _addToClonedElementsGroup(t) {
            if (!t.root.is('rootElement')) return;
            if (t.is('element')) for (const e of t.getChildren()) this._addToClonedElementsGroup(e);
            const e = t.id;
            if (!e) return;
            let n = this._cloneGroups.get(e);
            n || ((n = new Set()), this._cloneGroups.set(e, n)), n.add(t), (t._clonesGroup = n);
          }
          _removeFromClonedElementsGroup(t) {
            if (t.is('element')) for (const e of t.getChildren()) this._removeFromClonedElementsGroup(e);
            const e = t.id;
            if (!e) return;
            const n = this._cloneGroups.get(e);
            n && n.delete(t);
          }
        }
        function tr(t) {
          let e = t.parent;
          for (; !ar(e); ) {
            if (!e) return;
            e = e.parent;
          }
          return e;
        }
        function er(t, e) {
          return t.priority < e.priority || (!(t.priority > e.priority) && t.getIdentity() < e.getIdentity());
        }
        function nr(t) {
          const e = t.nodeBefore;
          if (e && e.is('$text')) return new ki(e, e.data.length);
          const n = t.nodeAfter;
          return n && n.is('$text') ? new ki(n, 0) : t;
        }
        function or(t) {
          if (t.offset == t.parent.data.length) return new ki(t.parent.parent, t.parent.index + 1);
          if (0 === t.offset) return new ki(t.parent.parent, t.parent.index);
          const e = t.parent.data.slice(t.offset);
          return (
            (t.parent._data = t.parent.data.slice(0, t.offset)),
            t.parent.parent._insertChild(t.parent.index + 1, new _o(t.root.document, e)),
            new ki(t.parent.parent, t.parent.index + 1)
          );
        }
        function ir(t, e) {
          const n = t.data.length;
          return (t._data += e.data), e._remove(), new ki(t, n);
        }
        function rr(t, e) {
          for (const n of t) {
            if (!sr.some(t => n instanceof t)) throw new c.a('view-writer-insert-invalid-node-type', e);
            n.is('$text') || rr(n.getChildren(), e);
          }
        }
        const sr = [_o, Pi, hi, Fi, Yi, Wi];
        function ar(t) {
          return t && (t.is('containerElement') || t.is('documentFragment'));
        }
        function cr(t, e) {
          const n = tr(t.start),
            o = tr(t.end);
          if (!n || !o || n !== o) throw new c.a('view-writer-invalid-range-container', e);
        }
        function lr(t, e) {
          return null === t.id && null === e.id;
        }
        function dr(t) {
          return '[object Text]' == Object.prototype.toString.call(t);
        }
        const hr = t => t.createTextNode(' '),
          ur = t => {
            const e = t.createElement('span');
            return (e.dataset.ckeFiller = !0), (e.innerHTML = ' '), e;
          },
          pr = t => {
            const e = t.createElement('br');
            return (e.dataset.ckeFiller = !0), e;
          },
          mr = '⁠'.repeat(7);
        function gr(t) {
          return dr(t) && t.data.substr(0, 7) === mr;
        }
        function fr(t) {
          return 7 == t.data.length && gr(t);
        }
        function kr(t) {
          return gr(t) ? t.data.slice(7) : t.data;
        }
        function br(t, e) {
          if (e.keyCode == Li.arrowleft) {
            const t = e.domTarget.ownerDocument.defaultView.getSelection();
            if (1 == t.rangeCount && t.getRangeAt(0).collapsed) {
              const e = t.getRangeAt(0).startContainer,
                n = t.getRangeAt(0).startOffset;
              gr(e) && n <= 7 && t.collapse(e, 0);
            }
          }
        }
        function wr(t, e, n, o = !1) {
          (n =
            n ||
            function (t, e) {
              return t === e;
            }),
            Array.isArray(t) || (t = Array.prototype.slice.call(t)),
            Array.isArray(e) || (e = Array.prototype.slice.call(e));
          const i = (function (t, e, n) {
            const o = Ar(t, e, n);
            if (-1 === o) return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
            const i = _r(t, o),
              r = _r(e, o),
              s = Ar(i, r, n),
              a = t.length - s,
              c = e.length - s;
            return { firstIndex: o, lastIndexOld: a, lastIndexNew: c };
          })(t, e, n);
          return o
            ? (function (t, e) {
                const { firstIndex: n, lastIndexOld: o, lastIndexNew: i } = t;
                if (-1 === n) return Array(e).fill('equal');
                let r = [];
                n > 0 && (r = r.concat(Array(n).fill('equal')));
                i - n > 0 && (r = r.concat(Array(i - n).fill('insert')));
                o - n > 0 && (r = r.concat(Array(o - n).fill('delete')));
                i < e && (r = r.concat(Array(e - i).fill('equal')));
                return r;
              })(i, e.length)
            : (function (t, e) {
                const n = [],
                  { firstIndex: o, lastIndexOld: i, lastIndexNew: r } = e;
                r - o > 0 && n.push({ index: o, type: 'insert', values: t.slice(o, r) });
                i - o > 0 && n.push({ index: o + (r - o), type: 'delete', howMany: i - o });
                return n;
              })(e, i);
        }
        function Ar(t, e, n) {
          for (let o = 0; o < Math.max(t.length, e.length); o++)
            if (void 0 === t[o] || void 0 === e[o] || !n(t[o], e[o])) return o;
          return -1;
        }
        function _r(t, e) {
          return t.slice(e).reverse();
        }
        function Cr(t, e, n) {
          n =
            n ||
            function (t, e) {
              return t === e;
            };
          const o = t.length,
            i = e.length;
          if (o > 200 || i > 200 || o + i > 300) return Cr.fastDiff(t, e, n, !0);
          let r, s;
          if (i < o) {
            const n = t;
            (t = e), (e = n), (r = 'delete'), (s = 'insert');
          } else (r = 'insert'), (s = 'delete');
          const a = t.length,
            c = e.length,
            l = c - a,
            d = {},
            h = {};
          function u(o) {
            const i = (void 0 !== h[o - 1] ? h[o - 1] : -1) + 1,
              l = void 0 !== h[o + 1] ? h[o + 1] : -1,
              u = i > l ? -1 : 1;
            d[o + u] && (d[o] = d[o + u].slice(0)), d[o] || (d[o] = []), d[o].push(i > l ? r : s);
            let p = Math.max(i, l),
              m = p - o;
            for (; m < a && p < c && n(t[m], e[p]); ) m++, p++, d[o].push('equal');
            return p;
          }
          let p,
            m = 0;
          do {
            for (p = -m; p < l; p++) h[p] = u(p);
            for (p = l + m; p > l; p--) h[p] = u(p);
            (h[l] = u(l)), m++;
          } while (h[l] !== c);
          return d[l].slice(1);
        }
        function vr(t, e, n) {
          t.insertBefore(n, t.childNodes[e] || null);
        }
        function yr(t) {
          const e = t.parentNode;
          e && e.removeChild(t);
        }
        function xr(t) {
          if (t) {
            if (t.defaultView) return t instanceof t.defaultView.Document;
            if (t.ownerDocument && t.ownerDocument.defaultView) return t instanceof t.ownerDocument.defaultView.Node;
          }
          return !1;
        }
        Cr.fastDiff = wr;
        class Er {
          constructor(t, e) {
            (this.domDocuments = new Set()),
              (this.domConverter = t),
              (this.markedAttributes = new Set()),
              (this.markedChildren = new Set()),
              (this.markedTexts = new Set()),
              (this.selection = e),
              (this.isFocused = !1),
              (this._inlineFiller = null),
              (this._fakeSelectionContainer = null);
          }
          markToSync(t, e) {
            if ('text' === t) this.domConverter.mapViewToDom(e.parent) && this.markedTexts.add(e);
            else {
              if (!this.domConverter.mapViewToDom(e)) return;
              if ('attributes' === t) this.markedAttributes.add(e);
              else {
                if ('children' !== t) throw new c.a('view-renderer-unknown-type', this);
                this.markedChildren.add(e);
              }
            }
          }
          render() {
            let t;
            for (const t of this.markedChildren) this._updateChildrenMappings(t);
            this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(),
              this._inlineFiller
                ? (t = this._getInlineFillerPosition())
                : this._needsInlineFillerAtSelection() &&
                  ((t = this.selection.getFirstPosition()), this.markedChildren.add(t.parent));
            for (const t of this.markedAttributes) this._updateAttrs(t);
            for (const e of this.markedChildren) this._updateChildren(e, { inlineFillerPosition: t });
            for (const e of this.markedTexts)
              !this.markedChildren.has(e.parent) &&
                this.domConverter.mapViewToDom(e.parent) &&
                this._updateText(e, { inlineFillerPosition: t });
            if (t) {
              const e = this.domConverter.viewPositionToDom(t),
                n = e.parent.ownerDocument;
              gr(e.parent) ? (this._inlineFiller = e.parent) : (this._inlineFiller = Dr(n, e.parent, e.offset));
            } else this._inlineFiller = null;
            this._updateFocus(),
              this._updateSelection(),
              this.markedTexts.clear(),
              this.markedAttributes.clear(),
              this.markedChildren.clear();
          }
          _updateChildrenMappings(t) {
            const e = this.domConverter.mapViewToDom(t);
            if (!e) return;
            const n = Array.from(this.domConverter.mapViewToDom(t).childNodes),
              o = Array.from(this.domConverter.viewChildrenToDom(t, e.ownerDocument, { withChildren: !1 })),
              i = this._diffNodeLists(n, o),
              r = this._findReplaceActions(i, n, o);
            if (-1 !== r.indexOf('replace')) {
              const e = { equal: 0, insert: 0, delete: 0 };
              for (const i of r)
                if ('replace' === i) {
                  const i = e.equal + e.insert,
                    r = e.equal + e.delete,
                    s = t.getChild(i);
                  !s || s.is('uiElement') || s.is('rawElement') || this._updateElementMappings(s, n[r]),
                    yr(o[i]),
                    e.equal++;
                } else e[i]++;
            }
          }
          _updateElementMappings(t, e) {
            this.domConverter.unbindDomElement(e),
              this.domConverter.bindElements(e, t),
              this.markedChildren.add(t),
              this.markedAttributes.add(t);
          }
          _getInlineFillerPosition() {
            const t = this.selection.getFirstPosition();
            return t.parent.is('$text') ? ki._createBefore(this.selection.getFirstPosition().parent) : t;
          }
          _isSelectionInInlineFiller() {
            if (1 != this.selection.rangeCount || !this.selection.isCollapsed) return !1;
            const t = this.selection.getFirstPosition(),
              e = this.domConverter.viewPositionToDom(t);
            return !!(e && dr(e.parent) && gr(e.parent));
          }
          _removeInlineFiller() {
            const t = this._inlineFiller;
            if (!gr(t)) throw new c.a('view-renderer-filler-was-lost', this);
            fr(t) ? t.parentNode.removeChild(t) : (t.data = t.data.substr(7)), (this._inlineFiller = null);
          }
          _needsInlineFillerAtSelection() {
            if (1 != this.selection.rangeCount || !this.selection.isCollapsed) return !1;
            const t = this.selection.getFirstPosition(),
              e = t.parent,
              n = t.offset;
            if (!this.domConverter.mapViewToDom(e.root)) return !1;
            if (!e.is('element')) return !1;
            if (
              !(function (t) {
                if ('false' == t.getAttribute('contenteditable')) return !1;
                const e = t.findAncestor(t => t.hasAttribute('contenteditable'));
                return !e || 'true' == e.getAttribute('contenteditable');
              })(e)
            )
              return !1;
            if (n === e.getFillerOffset()) return !1;
            const o = t.nodeBefore,
              i = t.nodeAfter;
            return !(o instanceof _o || i instanceof _o);
          }
          _updateText(t, e) {
            const n = this.domConverter.findCorrespondingDomText(t),
              o = this.domConverter.viewToDom(t, n.ownerDocument),
              i = n.data;
            let r = o.data;
            const s = e.inlineFillerPosition;
            if ((s && s.parent == t.parent && s.offset == t.index && (r = mr + r), i != r)) {
              const t = wr(i, r);
              for (const e of t)
                'insert' === e.type ? n.insertData(e.index, e.values.join('')) : n.deleteData(e.index, e.howMany);
            }
          }
          _updateAttrs(t) {
            const e = this.domConverter.mapViewToDom(t);
            if (!e) return;
            const n = Array.from(e.attributes).map(t => t.name),
              o = t.getAttributeKeys();
            for (const n of o) e.setAttribute(n, t.getAttribute(n));
            for (const o of n) t.hasAttribute(o) || e.removeAttribute(o);
          }
          _updateChildren(t, e) {
            const n = this.domConverter.mapViewToDom(t);
            if (!n) return;
            const o = e.inlineFillerPosition,
              i = this.domConverter.mapViewToDom(t).childNodes,
              r = Array.from(
                this.domConverter.viewChildrenToDom(t, n.ownerDocument, { bind: !0, inlineFillerPosition: o }),
              );
            o && o.parent === t && Dr(n.ownerDocument, r, o.offset);
            const s = this._diffNodeLists(i, r);
            let a = 0;
            const c = new Set();
            for (const t of s) 'delete' === t ? (c.add(i[a]), yr(i[a])) : 'equal' === t && a++;
            a = 0;
            for (const t of s)
              'insert' === t
                ? (vr(n, a, r[a]), a++)
                : 'equal' === t && (this._markDescendantTextToSync(this.domConverter.domToView(r[a])), a++);
            for (const t of c) t.parentNode || this.domConverter.unbindDomElement(t);
          }
          _diffNodeLists(t, e) {
            return Cr(
              (t = (function (t, e) {
                const n = Array.from(t);
                if (0 == n.length || !e) return n;
                n[n.length - 1] == e && n.pop();
                return n;
              })(t, this._fakeSelectionContainer)),
              e,
              Br.bind(null, this.domConverter),
            );
          }
          _findReplaceActions(t, e, n) {
            if (-1 === t.indexOf('insert') || -1 === t.indexOf('delete')) return t;
            let o = [],
              i = [],
              r = [];
            const s = { equal: 0, insert: 0, delete: 0 };
            for (const a of t)
              'insert' === a
                ? r.push(n[s.equal + s.insert])
                : 'delete' === a
                ? i.push(e[s.equal + s.delete])
                : ((o = o.concat(Cr(i, r, Sr).map(t => ('equal' === t ? 'replace' : t)))),
                  o.push('equal'),
                  (i = []),
                  (r = [])),
                s[a]++;
            return o.concat(Cr(i, r, Sr).map(t => ('equal' === t ? 'replace' : t)));
          }
          _markDescendantTextToSync(t) {
            if (t)
              if (t.is('$text')) this.markedTexts.add(t);
              else if (t.is('element')) for (const e of t.getChildren()) this._markDescendantTextToSync(e);
          }
          _updateSelection() {
            if (0 === this.selection.rangeCount) return this._removeDomSelection(), void this._removeFakeSelection();
            const t = this.domConverter.mapViewToDom(this.selection.editableElement);
            this.isFocused &&
              t &&
              (this.selection.isFake
                ? this._updateFakeSelection(t)
                : (this._removeFakeSelection(), this._updateDomSelection(t)));
          }
          _updateFakeSelection(t) {
            const e = t.ownerDocument;
            this._fakeSelectionContainer ||
              (this._fakeSelectionContainer = (function (t) {
                const e = t.createElement('div');
                return (
                  (e.className = 'ck-fake-selection-container'),
                  Object.assign(e.style, { position: 'fixed', top: 0, left: '-9999px', width: '42px' }),
                  (e.textContent = ' '),
                  e
                );
              })(e));
            const n = this._fakeSelectionContainer;
            if ((this.domConverter.bindFakeSelection(n, this.selection), !this._fakeSelectionNeedsUpdate(t))) return;
            (n.parentElement && n.parentElement == t) || t.appendChild(n),
              (n.textContent = this.selection.fakeSelectionLabel || ' ');
            const o = e.getSelection(),
              i = e.createRange();
            o.removeAllRanges(), i.selectNodeContents(n), o.addRange(i);
          }
          _updateDomSelection(t) {
            const e = t.ownerDocument.defaultView.getSelection();
            if (!this._domSelectionNeedsUpdate(e)) return;
            const n = this.domConverter.viewPositionToDom(this.selection.anchor),
              o = this.domConverter.viewPositionToDom(this.selection.focus);
            e.collapse(n.parent, n.offset),
              e.extend(o.parent, o.offset),
              Mi.isGecko &&
                (function (t, e) {
                  const n = t.parent;
                  if (n.nodeType != Node.ELEMENT_NODE || t.offset != n.childNodes.length - 1) return;
                  const o = n.childNodes[t.offset];
                  o && 'BR' == o.tagName && e.addRange(e.getRangeAt(0));
                })(o, e);
          }
          _domSelectionNeedsUpdate(t) {
            if (!this.domConverter.isDomSelectionCorrect(t)) return !0;
            const e = t && this.domConverter.domSelectionToView(t);
            return (!e || !this.selection.isEqual(e)) && !(!this.selection.isCollapsed && this.selection.isSimilar(e));
          }
          _fakeSelectionNeedsUpdate(t) {
            const e = this._fakeSelectionContainer,
              n = t.ownerDocument.getSelection();
            return (
              !e ||
              e.parentElement !== t ||
              (n.anchorNode !== e && !e.contains(n.anchorNode)) ||
              e.textContent !== this.selection.fakeSelectionLabel
            );
          }
          _removeDomSelection() {
            for (const t of this.domDocuments) {
              if (t.getSelection().rangeCount) {
                const e = t.activeElement,
                  n = this.domConverter.mapDomToView(e);
                e && n && t.getSelection().removeAllRanges();
              }
            }
          }
          _removeFakeSelection() {
            const t = this._fakeSelectionContainer;
            t && t.remove();
          }
          _updateFocus() {
            if (this.isFocused) {
              const t = this.selection.editableElement;
              t && this.domConverter.focus(t);
            }
          }
        }
        function Dr(t, e, n) {
          const o = e instanceof Array ? e : e.childNodes,
            i = o[n];
          if (dr(i)) return (i.data = mr + i.data), i;
          {
            const i = t.createTextNode(mr);
            return Array.isArray(e) ? o.splice(n, 0, i) : vr(e, n, i), i;
          }
        }
        function Sr(t, e) {
          return (
            xr(t) &&
            xr(e) &&
            !dr(t) &&
            !dr(e) &&
            t.nodeType !== Node.COMMENT_NODE &&
            e.nodeType !== Node.COMMENT_NODE &&
            t.tagName.toLowerCase() === e.tagName.toLowerCase()
          );
        }
        function Br(t, e, n) {
          return e === n || (dr(e) && dr(n) ? e.data === n.data : !(!t.isBlockFiller(e) || !t.isBlockFiller(n)));
        }
        Yt(Er, jt);
        var Tr = { window: window, document: document };
        function Pr(t) {
          let e = 0;
          for (; t.previousSibling; ) (t = t.previousSibling), e++;
          return e;
        }
        function Ir(t) {
          const e = [];
          for (; t && t.nodeType != Node.DOCUMENT_NODE; ) e.unshift(t), (t = t.parentNode);
          return e;
        }
        const zr = pr(document),
          Fr = hr(document),
          Rr = ur(document);
        class Or {
          constructor(t, e = {}) {
            (this.document = t),
              (this.blockFillerMode = e.blockFillerMode || 'br'),
              (this.preElements = ['pre']),
              (this.blockElements = [
                'p',
                'div',
                'h1',
                'h2',
                'h3',
                'h4',
                'h5',
                'h6',
                'li',
                'dd',
                'dt',
                'figcaption',
                'td',
                'th',
              ]),
              (this._domToViewMapping = new WeakMap()),
              (this._viewToDomMapping = new WeakMap()),
              (this._fakeSelectionMapping = new WeakMap()),
              (this._rawContentElementMatcher = new yo()),
              (this._encounteredRawContentDomNodes = new WeakSet());
          }
          bindFakeSelection(t, e) {
            this._fakeSelectionMapping.set(t, new _i(e));
          }
          fakeSelectionToView(t) {
            return this._fakeSelectionMapping.get(t);
          }
          bindElements(t, e) {
            this._domToViewMapping.set(t, e), this._viewToDomMapping.set(e, t);
          }
          unbindDomElement(t) {
            const e = this._domToViewMapping.get(t);
            if (e) {
              this._domToViewMapping.delete(t), this._viewToDomMapping.delete(e);
              for (const e of t.childNodes) this.unbindDomElement(e);
            }
          }
          bindDocumentFragments(t, e) {
            this._domToViewMapping.set(t, e), this._viewToDomMapping.set(e, t);
          }
          viewToDom(t, e, n = {}) {
            if (t.is('$text')) {
              const n = this._processDataFromViewText(t);
              return e.createTextNode(n);
            }
            {
              if (this.mapViewToDom(t)) return this.mapViewToDom(t);
              let o;
              if (t.is('documentFragment'))
                (o = e.createDocumentFragment()), n.bind && this.bindDocumentFragments(o, t);
              else {
                if (t.is('uiElement')) return (o = t.render(e)), n.bind && this.bindElements(o, t), o;
                (o = t.hasAttribute('xmlns')
                  ? e.createElementNS(t.getAttribute('xmlns'), t.name)
                  : e.createElement(t.name)),
                  t.is('rawElement') && t.render(o),
                  n.bind && this.bindElements(o, t);
                for (const e of t.getAttributeKeys()) o.setAttribute(e, t.getAttribute(e));
              }
              if (!1 !== n.withChildren) for (const i of this.viewChildrenToDom(t, e, n)) o.appendChild(i);
              return o;
            }
          }
          *viewChildrenToDom(t, e, n = {}) {
            const o = t.getFillerOffset && t.getFillerOffset();
            let i = 0;
            for (const r of t.getChildren())
              o === i && (yield this._getBlockFiller(e)), yield this.viewToDom(r, e, n), i++;
            o === i && (yield this._getBlockFiller(e));
          }
          viewRangeToDom(t) {
            const e = this.viewPositionToDom(t.start),
              n = this.viewPositionToDom(t.end),
              o = document.createRange();
            return o.setStart(e.parent, e.offset), o.setEnd(n.parent, n.offset), o;
          }
          viewPositionToDom(t) {
            const e = t.parent;
            if (e.is('$text')) {
              const n = this.findCorrespondingDomText(e);
              if (!n) return null;
              let o = t.offset;
              return gr(n) && (o += 7), { parent: n, offset: o };
            }
            {
              let n, o, i;
              if (0 === t.offset) {
                if (((n = this.mapViewToDom(e)), !n)) return null;
                i = n.childNodes[0];
              } else {
                const e = t.nodeBefore;
                if (((o = e.is('$text') ? this.findCorrespondingDomText(e) : this.mapViewToDom(t.nodeBefore)), !o))
                  return null;
                (n = o.parentNode), (i = o.nextSibling);
              }
              if (dr(i) && gr(i)) return { parent: i, offset: 7 };
              return { parent: n, offset: o ? Pr(o) + 1 : 0 };
            }
          }
          domToView(t, e = {}) {
            if (this.isBlockFiller(t)) return null;
            const n = this.getHostViewElement(t);
            if (n) return n;
            if (dr(t)) {
              if (fr(t)) return null;
              {
                const e = this._processDataFromDomText(t);
                return '' === e ? null : new _o(this.document, e);
              }
            }
            if (this.isComment(t)) return null;
            {
              if (this.mapDomToView(t)) return this.mapDomToView(t);
              let n;
              if (this.isDocumentFragment(t)) (n = new Xi(this.document)), e.bind && this.bindDocumentFragments(t, n);
              else {
                const o = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase();
                (n = new li(this.document, o)), e.bind && this.bindElements(t, n);
                const i = t.attributes;
                for (let t = i.length - 1; t >= 0; t--) n._setAttribute(i[t].name, i[t].value);
                if (!1 !== e.withChildren && this._rawContentElementMatcher.match(n))
                  return (
                    n._setCustomProperty('$rawContent', t.innerHTML), this._encounteredRawContentDomNodes.add(t), n
                  );
              }
              if (!1 !== e.withChildren) for (const o of this.domChildrenToView(t, e)) n._appendChild(o);
              return n;
            }
          }
          *domChildrenToView(t, e = {}) {
            for (let n = 0; n < t.childNodes.length; n++) {
              const o = t.childNodes[n],
                i = this.domToView(o, e);
              null !== i && (yield i);
            }
          }
          domSelectionToView(t) {
            if (1 === t.rangeCount) {
              let e = t.getRangeAt(0).startContainer;
              dr(e) && (e = e.parentNode);
              const n = this.fakeSelectionToView(e);
              if (n) return n;
            }
            const e = this.isDomSelectionBackward(t),
              n = [];
            for (let e = 0; e < t.rangeCount; e++) {
              const o = t.getRangeAt(e),
                i = this.domRangeToView(o);
              i && n.push(i);
            }
            return new _i(n, { backward: e });
          }
          domRangeToView(t) {
            const e = this.domPositionToView(t.startContainer, t.startOffset),
              n = this.domPositionToView(t.endContainer, t.endOffset);
            return e && n ? new bi(e, n) : null;
          }
          domPositionToView(t, e) {
            if (this.isBlockFiller(t)) return this.domPositionToView(t.parentNode, Pr(t));
            const n = this.mapDomToView(t);
            if (n && (n.is('uiElement') || n.is('rawElement'))) return ki._createBefore(n);
            if (dr(t)) {
              if (fr(t)) return this.domPositionToView(t.parentNode, Pr(t));
              const n = this.findCorrespondingViewText(t);
              let o = e;
              return n ? (gr(t) && ((o -= 7), (o = o < 0 ? 0 : o)), new ki(n, o)) : null;
            }
            if (0 === e) {
              const e = this.mapDomToView(t);
              if (e) return new ki(e, 0);
            } else {
              const n = t.childNodes[e - 1],
                o = dr(n) ? this.findCorrespondingViewText(n) : this.mapDomToView(n);
              if (o && o.parent) return new ki(o.parent, o.index + 1);
            }
            return null;
          }
          mapDomToView(t) {
            return this.getHostViewElement(t) || this._domToViewMapping.get(t);
          }
          findCorrespondingViewText(t) {
            if (fr(t)) return null;
            const e = this.getHostViewElement(t);
            if (e) return e;
            const n = t.previousSibling;
            if (n) {
              if (!this.isElement(n)) return null;
              const t = this.mapDomToView(n);
              if (t) {
                return t.nextSibling instanceof _o ? t.nextSibling : null;
              }
            } else {
              const e = this.mapDomToView(t.parentNode);
              if (e) {
                const t = e.getChild(0);
                return t instanceof _o ? t : null;
              }
            }
            return null;
          }
          mapViewToDom(t) {
            return this._viewToDomMapping.get(t);
          }
          findCorrespondingDomText(t) {
            const e = t.previousSibling;
            return e && this.mapViewToDom(e)
              ? this.mapViewToDom(e).nextSibling
              : !e && t.parent && this.mapViewToDom(t.parent)
              ? this.mapViewToDom(t.parent).childNodes[0]
              : null;
          }
          focus(t) {
            const e = this.mapViewToDom(t);
            if (e && e.ownerDocument.activeElement !== e) {
              const { scrollX: t, scrollY: n } = Tr.window,
                o = [];
              Nr(e, t => {
                const { scrollLeft: e, scrollTop: n } = t;
                o.push([e, n]);
              }),
                e.focus(),
                Nr(e, t => {
                  const [e, n] = o.shift();
                  (t.scrollLeft = e), (t.scrollTop = n);
                }),
                Tr.window.scrollTo(t, n);
            }
          }
          isElement(t) {
            return t && t.nodeType == Node.ELEMENT_NODE;
          }
          isDocumentFragment(t) {
            return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
          }
          isComment(t) {
            return t && t.nodeType == Node.COMMENT_NODE;
          }
          isBlockFiller(t) {
            return 'br' == this.blockFillerMode
              ? t.isEqualNode(zr)
              : !('BR' !== t.tagName || !Vr(t, this.blockElements) || 1 !== t.parentNode.childNodes.length) ||
                  t.isEqualNode(Rr) ||
                  (function (t, e) {
                    return t.isEqualNode(Fr) && Vr(t, e) && 1 === t.parentNode.childNodes.length;
                  })(t, this.blockElements);
          }
          isDomSelectionBackward(t) {
            if (t.isCollapsed) return !1;
            const e = document.createRange();
            e.setStart(t.anchorNode, t.anchorOffset), e.setEnd(t.focusNode, t.focusOffset);
            const n = e.collapsed;
            return e.detach(), n;
          }
          getHostViewElement(t) {
            const e = Ir(t);
            for (e.pop(); e.length; ) {
              const t = e.pop(),
                n = this._domToViewMapping.get(t);
              if (n && (n.is('uiElement') || n.is('rawElement'))) return n;
            }
            return null;
          }
          isDomSelectionCorrect(t) {
            return (
              this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) &&
              this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
            );
          }
          registerRawContentMatcher(t) {
            this._rawContentElementMatcher.add(t);
          }
          _getBlockFiller(t) {
            switch (this.blockFillerMode) {
              case 'nbsp':
                return hr(t);
              case 'markedNbsp':
                return ur(t);
              case 'br':
                return pr(t);
            }
          }
          _isDomSelectionPositionCorrect(t, e) {
            if (dr(t) && gr(t) && e < 7) return !1;
            if (this.isElement(t) && gr(t.childNodes[e])) return !1;
            const n = this.mapDomToView(t);
            return !n || (!n.is('uiElement') && !n.is('rawElement'));
          }
          _processDataFromViewText(t) {
            let e = t.data;
            if (t.getAncestors().some(t => this.preElements.includes(t.name))) return e;
            if (' ' == e.charAt(0)) {
              const n = this._getTouchingViewTextNode(t, !1);
              (!(n && this._nodeEndsWithSpace(n)) && n) || (e = ' ' + e.substr(1));
            }
            if (' ' == e.charAt(e.length - 1)) {
              const n = this._getTouchingViewTextNode(t, !0);
              (' ' != e.charAt(e.length - 2) && n && ' ' != n.data.charAt(0)) || (e = e.substr(0, e.length - 1) + ' ');
            }
            return e.replace(/ {2}/g, '  ');
          }
          _nodeEndsWithSpace(t) {
            if (t.getAncestors().some(t => this.preElements.includes(t.name))) return !1;
            const e = this._processDataFromViewText(t);
            return ' ' == e.charAt(e.length - 1);
          }
          _processDataFromDomText(t) {
            let e = t.data;
            if (Mr(t, this.preElements)) return kr(t);
            e = e.replace(/[ \n\t\r]{1,}/g, ' ');
            const n = this._getTouchingInlineDomNode(t, !1),
              o = this._getTouchingInlineDomNode(t, !0),
              i = this._checkShouldLeftTrimDomText(t, n),
              r = this._checkShouldRightTrimDomText(t, o);
            return (
              i && (e = e.replace(/^ /, '')),
              r && (e = e.replace(/ $/, '')),
              (e = kr(new Text(e))),
              (e = e.replace(/ \u00A0/g, '  ')),
              (/( |\u00A0)\u00A0$/.test(e) || !o || (o.data && ' ' == o.data.charAt(0))) &&
                (e = e.replace(/\u00A0$/, ' ')),
              i && (e = e.replace(/^\u00A0/, ' ')),
              e
            );
          }
          _checkShouldLeftTrimDomText(t, e) {
            return (
              !e ||
              !!oo(e) ||
              (!this._encounteredRawContentDomNodes.has(t.previousSibling) &&
                /[^\S\u00A0]/.test(e.data.charAt(e.data.length - 1)))
            );
          }
          _checkShouldRightTrimDomText(t, e) {
            return !e && !gr(t);
          }
          _getTouchingViewTextNode(t, e) {
            const n = new fi({
              startPosition: e ? ki._createAfter(t) : ki._createBefore(t),
              direction: e ? 'forward' : 'backward',
            });
            for (const t of n) {
              if (t.item.is('containerElement')) return null;
              if (t.item.is('element', 'br')) return null;
              if (t.item.is('$textProxy')) return t.item;
            }
            return null;
          }
          _getTouchingInlineDomNode(t, e) {
            if (!t.parentNode) return null;
            const n = e ? 'nextNode' : 'previousNode',
              o = t.ownerDocument,
              i = Ir(t)[0],
              r = o.createTreeWalker(i, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {
                acceptNode: t => (dr(t) || 'BR' == t.tagName ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP),
              });
            r.currentNode = t;
            const s = r[n]();
            if (null !== s) {
              const e = (function (t, e) {
                const n = Ir(t),
                  o = Ir(e);
                let i = 0;
                for (; n[i] == o[i] && n[i]; ) i++;
                return 0 === i ? null : n[i - 1];
              })(t, s);
              if (e && !Mr(t, this.blockElements, e) && !Mr(s, this.blockElements, e)) return s;
            }
            return null;
          }
        }
        function Mr(t, e, n) {
          let o = Ir(t);
          return n && (o = o.slice(o.indexOf(n) + 1)), o.some(t => t.tagName && e.includes(t.tagName.toLowerCase()));
        }
        function Nr(t, e) {
          for (; t && t != Tr.document; ) e(t), (t = t.parentNode);
        }
        function Vr(t, e) {
          const n = t.parentNode;
          return n && n.tagName && e.includes(n.tagName.toLowerCase());
        }
        function Lr(t) {
          const e = Object.prototype.toString.apply(t);
          return '[object Window]' == e || '[object global]' == e;
        }
        var Kr = Mt({}, h, {
          listenTo(t, ...e) {
            if (xr(t) || Lr(t)) {
              const n = this._getProxyEmitter(t) || new qr(t);
              n.attach(...e), (t = n);
            }
            h.listenTo.call(this, t, ...e);
          },
          stopListening(t, e, n) {
            if (xr(t) || Lr(t)) {
              const e = this._getProxyEmitter(t);
              if (!e) return;
              t = e;
            }
            h.stopListening.call(this, t, e, n), t instanceof qr && t.detach(e);
          },
          _getProxyEmitter(t) {
            return (e = this), (n = Hr(t)), e[l] && e[l][n] ? e[l][n].emitter : null;
            var e, n;
          },
        });
        class qr {
          constructor(t) {
            u(this, Hr(t)), (this._domNode = t);
          }
        }
        function Hr(t) {
          return t['data-ck-expando'] || (t['data-ck-expando'] = s());
        }
        Mt(qr.prototype, h, {
          attach(t, e, n = {}) {
            if (this._domListeners && this._domListeners[t]) return;
            const o = { capture: !!n.useCapture, passive: !!n.usePassive },
              i = this._createDomListener(t, o);
            this._domNode.addEventListener(t, i, o),
              this._domListeners || (this._domListeners = {}),
              (this._domListeners[t] = i);
          },
          detach(t) {
            let e;
            !this._domListeners[t] ||
              ((e = this._events[t]) && e.callbacks.length) ||
              this._domListeners[t].removeListener();
          },
          _createDomListener(t, e) {
            const n = e => {
              this.fire(t, e);
            };
            return (
              (n.removeListener = () => {
                this._domNode.removeEventListener(t, n, e), delete this._domListeners[t];
              }),
              n
            );
          },
        });
        class jr {
          constructor(t) {
            (this.view = t), (this.document = t.document), (this.isEnabled = !1);
          }
          enable() {
            this.isEnabled = !0;
          }
          disable() {
            this.isEnabled = !1;
          }
          destroy() {
            this.disable(), this.stopListening();
          }
          checkShouldIgnoreEventFromTarget(t) {
            return (
              t && 3 === t.nodeType && (t = t.parentNode),
              !(!t || 1 !== t.nodeType) && t.matches('[data-cke-ignore-events], [data-cke-ignore-events] *')
            );
          }
        }
        Yt(jr, Kr);
        var $r = function (t) {
          return this.__data__.set(t, '__lodash_hash_undefined__'), this;
        };
        var Gr = function (t) {
          return this.__data__.has(t);
        };
        function Wr(t) {
          var e = -1,
            n = null == t ? 0 : t.length;
          for (this.__data__ = new qe(); ++e < n; ) this.add(t[e]);
        }
        (Wr.prototype.add = Wr.prototype.push = $r), (Wr.prototype.has = Gr);
        var Ur = Wr;
        var Jr = function (t, e) {
          for (var n = -1, o = null == t ? 0 : t.length; ++n < o; ) if (e(t[n], n, t)) return !0;
          return !1;
        };
        var Yr = function (t, e) {
          return t.has(e);
        };
        var Qr = function (t, e, n, o, i, r) {
          var s = 1 & n,
            a = t.length,
            c = e.length;
          if (a != c && !(s && c > a)) return !1;
          var l = r.get(t),
            d = r.get(e);
          if (l && d) return l == e && d == t;
          var h = -1,
            u = !0,
            p = 2 & n ? new Ur() : void 0;
          for (r.set(t, e), r.set(e, t); ++h < a; ) {
            var m = t[h],
              g = e[h];
            if (o) var f = s ? o(g, m, h, e, t, r) : o(m, g, h, t, e, r);
            if (void 0 !== f) {
              if (f) continue;
              u = !1;
              break;
            }
            if (p) {
              if (
                !Jr(e, function (t, e) {
                  if (!Yr(p, e) && (m === t || i(m, t, n, o, r))) return p.push(e);
                })
              ) {
                u = !1;
                break;
              }
            } else if (m !== g && !i(m, g, n, o, r)) {
              u = !1;
              break;
            }
          }
          return r.delete(t), r.delete(e), u;
        };
        var Xr = function (t) {
          var e = -1,
            n = Array(t.size);
          return (
            t.forEach(function (t, o) {
              n[++e] = [o, t];
            }),
            n
          );
        };
        var Zr = function (t) {
            var e = -1,
              n = Array(t.size);
            return (
              t.forEach(function (t) {
                n[++e] = t;
              }),
              n
            );
          },
          ts = _ ? _.prototype : void 0,
          es = ts ? ts.valueOf : void 0;
        var ns = function (t, e, n, o, i, r, s) {
            switch (n) {
              case '[object DataView]':
                if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
                (t = t.buffer), (e = e.buffer);
              case '[object ArrayBuffer]':
                return !(t.byteLength != e.byteLength || !r(new In(t), new In(e)));
              case '[object Boolean]':
              case '[object Date]':
              case '[object Number]':
                return J(+t, +e);
              case '[object Error]':
                return t.name == e.name && t.message == e.message;
              case '[object RegExp]':
              case '[object String]':
                return t == e + '';
              case '[object Map]':
                var a = Xr;
              case '[object Set]':
                var c = 1 & o;
                if ((a || (a = Zr), t.size != e.size && !c)) return !1;
                var l = s.get(t);
                if (l) return l == e;
                (o |= 2), s.set(t, e);
                var d = Qr(a(t), a(e), o, i, r, s);
                return s.delete(t), d;
              case '[object Symbol]':
                if (es) return es.call(t) == es.call(e);
            }
            return !1;
          },
          os = Object.prototype.hasOwnProperty;
        var is = function (t, e, n, o, i, r) {
            var s = 1 & n,
              a = un(t),
              c = a.length;
            if (c != un(e).length && !s) return !1;
            for (var l = c; l--; ) {
              var d = a[l];
              if (!(s ? d in e : os.call(e, d))) return !1;
            }
            var h = r.get(t),
              u = r.get(e);
            if (h && u) return h == e && u == t;
            var p = !0;
            r.set(t, e), r.set(e, t);
            for (var m = s; ++l < c; ) {
              var g = t[(d = a[l])],
                f = e[d];
              if (o) var k = s ? o(f, g, d, e, t, r) : o(g, f, d, t, e, r);
              if (!(void 0 === k ? g === f || i(g, f, n, o, r) : k)) {
                p = !1;
                break;
              }
              m || (m = 'constructor' == d);
            }
            if (p && !m) {
              var b = t.constructor,
                w = e.constructor;
              b == w ||
                !('constructor' in t) ||
                !('constructor' in e) ||
                ('function' == typeof b && b instanceof b && 'function' == typeof w && w instanceof w) ||
                (p = !1);
            }
            return r.delete(t), r.delete(e), p;
          },
          rs = '[object Arguments]',
          ss = '[object Array]',
          as = '[object Object]',
          cs = Object.prototype.hasOwnProperty;
        var ls = function (t, e, n, o, i, r) {
          var s = _t(t),
            a = _t(e),
            c = s ? ss : Bn(t),
            l = a ? ss : Bn(e),
            d = (c = c == rs ? as : c) == as,
            h = (l = l == rs ? as : l) == as,
            u = c == l;
          if (u && Object(Ct.a)(t)) {
            if (!Object(Ct.a)(e)) return !1;
            (s = !0), (d = !1);
          }
          if (u && !d) return r || (r = new $e()), s || St(t) ? Qr(t, e, n, o, i, r) : ns(t, e, c, n, o, i, r);
          if (!(1 & n)) {
            var p = d && cs.call(t, '__wrapped__'),
              m = h && cs.call(e, '__wrapped__');
            if (p || m) {
              var g = p ? t.value() : t,
                f = m ? e.value() : e;
              return r || (r = new $e()), i(g, f, n, o, r);
            }
          }
          return !!u && (r || (r = new $e()), is(t, e, n, o, i, r));
        };
        var ds = function t(e, n, o, i, r) {
          return e === n || (null == e || null == n || (!gt(e) && !gt(n)) ? e != e && n != n : ls(e, n, o, i, t, r));
        };
        var hs = function (t, e, n) {
          var o = (n = 'function' == typeof n ? n : void 0) ? n(t, e) : void 0;
          return void 0 === o ? ds(t, e, void 0, n) : !!o;
        };
        class us extends jr {
          constructor(t) {
            super(t),
              (this._config = { childList: !0, characterData: !0, characterDataOldValue: !0, subtree: !0 }),
              (this.domConverter = t.domConverter),
              (this.renderer = t._renderer),
              (this._domElements = []),
              (this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this)));
          }
          flush() {
            this._onMutations(this._mutationObserver.takeRecords());
          }
          observe(t) {
            this._domElements.push(t), this.isEnabled && this._mutationObserver.observe(t, this._config);
          }
          enable() {
            super.enable();
            for (const t of this._domElements) this._mutationObserver.observe(t, this._config);
          }
          disable() {
            super.disable(), this._mutationObserver.disconnect();
          }
          destroy() {
            super.destroy(), this._mutationObserver.disconnect();
          }
          _onMutations(t) {
            if (0 === t.length) return;
            const e = this.domConverter,
              n = new Map(),
              o = new Set();
            for (const n of t)
              if ('childList' === n.type) {
                const t = e.mapDomToView(n.target);
                if (t && (t.is('uiElement') || t.is('rawElement'))) continue;
                t && !this._isBogusBrMutation(n) && o.add(t);
              }
            for (const i of t) {
              const t = e.mapDomToView(i.target);
              if ((!t || (!t.is('uiElement') && !t.is('rawElement'))) && 'characterData' === i.type) {
                const t = e.findCorrespondingViewText(i.target);
                t && !o.has(t.parent)
                  ? n.set(t, { type: 'text', oldText: t.data, newText: kr(i.target), node: t })
                  : !t && gr(i.target) && o.add(e.mapDomToView(i.target.parentNode));
              }
            }
            const i = [];
            for (const t of n.values()) this.renderer.markToSync('text', t.node), i.push(t);
            for (const t of o) {
              const n = e.mapViewToDom(t),
                o = Array.from(t.getChildren()),
                r = Array.from(e.domChildrenToView(n, { withChildren: !1 }));
              hs(o, r, a) ||
                (this.renderer.markToSync('children', t),
                i.push({ type: 'children', oldChildren: o, newChildren: r, node: t }));
            }
            const r = t[0].target.ownerDocument.getSelection();
            let s = null;
            if (r && r.anchorNode) {
              const t = e.domPositionToView(r.anchorNode, r.anchorOffset),
                n = e.domPositionToView(r.focusNode, r.focusOffset);
              t && n && ((s = new _i(t)), s.setFocus(n));
            }
            function a(t, e) {
              if (!Array.isArray(t)) return t === e || (!(!t.is('$text') || !e.is('$text')) && t.data === e.data);
            }
            i.length && (this.document.fire('mutations', i, s), this.view.forceRender());
          }
          _isBogusBrMutation(t) {
            let e = null;
            return (
              null === t.nextSibling &&
                0 === t.removedNodes.length &&
                1 == t.addedNodes.length &&
                (e = this.domConverter.domToView(t.addedNodes[0], { withChildren: !1 })),
              e && e.is('element', 'br')
            );
          }
        }
        class ps {
          constructor(t, e, n) {
            (this.view = t),
              (this.document = t.document),
              (this.domEvent = e),
              (this.domTarget = e.target),
              Mt(this, n);
          }
          get target() {
            return this.view.domConverter.mapDomToView(this.domTarget);
          }
          preventDefault() {
            this.domEvent.preventDefault();
          }
          stopPropagation() {
            this.domEvent.stopPropagation();
          }
        }
        class ms extends jr {
          constructor(t) {
            super(t), (this.useCapture = !1);
          }
          observe(t) {
            ('string' == typeof this.domEventType ? [this.domEventType] : this.domEventType).forEach(e => {
              this.listenTo(
                t,
                e,
                (t, e) => {
                  this.isEnabled && !this.checkShouldIgnoreEventFromTarget(e.target) && this.onDomEvent(e);
                },
                { useCapture: this.useCapture },
              );
            });
          }
          fire(t, e, n) {
            this.isEnabled && this.document.fire(t, new ps(this.view, e, n));
          }
        }
        class gs extends ms {
          constructor(t) {
            super(t), (this.domEventType = ['keydown', 'keyup']);
          }
          onDomEvent(t) {
            this.fire(t.type, t, {
              keyCode: t.keyCode,
              altKey: t.altKey,
              ctrlKey: t.ctrlKey,
              shiftKey: t.shiftKey,
              metaKey: t.metaKey,
              get keystroke() {
                return qi(this);
              },
            });
          }
        }
        var fs = function () {
            return A.a.Date.now();
          },
          ks = /\s/;
        var bs = function (t) {
            for (var e = t.length; e-- && ks.test(t.charAt(e)); );
            return e;
          },
          ws = /^\s+/;
        var As = function (t) {
            return t ? t.slice(0, bs(t) + 1).replace(ws, '') : t;
          },
          _s = /^[-+]0x[0-9a-f]+$/i,
          Cs = /^0b[01]+$/i,
          vs = /^0o[0-7]+$/i,
          ys = parseInt;
        var xs = function (t) {
            if ('number' == typeof t) return t;
            if (Eo(t)) return NaN;
            if (w(t)) {
              var e = 'function' == typeof t.valueOf ? t.valueOf() : t;
              t = w(e) ? e + '' : e;
            }
            if ('string' != typeof t) return 0 === t ? t : +t;
            t = As(t);
            var n = Cs.test(t);
            return n || vs.test(t) ? ys(t.slice(2), n ? 2 : 8) : _s.test(t) ? NaN : +t;
          },
          Es = Math.max,
          Ds = Math.min;
        var Ss = function (t, e, n) {
          var o,
            i,
            r,
            s,
            a,
            c,
            l = 0,
            d = !1,
            h = !1,
            u = !0;
          if ('function' != typeof t) throw new TypeError('Expected a function');
          function p(e) {
            var n = o,
              r = i;
            return (o = i = void 0), (l = e), (s = t.apply(r, n));
          }
          function m(t) {
            return (l = t), (a = setTimeout(f, e)), d ? p(t) : s;
          }
          function g(t) {
            var n = t - c;
            return void 0 === c || n >= e || n < 0 || (h && t - l >= r);
          }
          function f() {
            var t = fs();
            if (g(t)) return k(t);
            a = setTimeout(
              f,
              (function (t) {
                var n = e - (t - c);
                return h ? Ds(n, r - (t - l)) : n;
              })(t),
            );
          }
          function k(t) {
            return (a = void 0), u && o ? p(t) : ((o = i = void 0), s);
          }
          function b() {
            var t = fs(),
              n = g(t);
            if (((o = arguments), (i = this), (c = t), n)) {
              if (void 0 === a) return m(c);
              if (h) return clearTimeout(a), (a = setTimeout(f, e)), p(c);
            }
            return void 0 === a && (a = setTimeout(f, e)), s;
          }
          return (
            (e = xs(e) || 0),
            w(n) &&
              ((d = !!n.leading),
              (r = (h = 'maxWait' in n) ? Es(xs(n.maxWait) || 0, e) : r),
              (u = 'trailing' in n ? !!n.trailing : u)),
            (b.cancel = function () {
              void 0 !== a && clearTimeout(a), (l = 0), (o = c = i = a = void 0);
            }),
            (b.flush = function () {
              return void 0 === a ? s : k(fs());
            }),
            b
          );
        };
        class Bs extends jr {
          constructor(t) {
            super(t),
              (this._fireSelectionChangeDoneDebounced = Ss(t => this.document.fire('selectionChangeDone', t), 200));
          }
          observe() {
            const t = this.document;
            t.on(
              'arrowKey',
              (e, n) => {
                t.selection.isFake && this.isEnabled && n.preventDefault();
              },
              { context: '$capture' },
            ),
              t.on(
                'arrowKey',
                (e, n) => {
                  t.selection.isFake && this.isEnabled && this._handleSelectionMove(n.keyCode);
                },
                { priority: 'lowest' },
              );
          }
          destroy() {
            super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
          }
          _handleSelectionMove(t) {
            const e = this.document.selection,
              n = new _i(e.getRanges(), { backward: e.isBackward, fake: !1 });
            (t != Li.arrowleft && t != Li.arrowup) || n.setTo(n.getFirstPosition()),
              (t != Li.arrowright && t != Li.arrowdown) || n.setTo(n.getLastPosition());
            const o = { oldSelection: e, newSelection: n, domSelection: null };
            this.document.fire('selectionChange', o), this._fireSelectionChangeDoneDebounced(o);
          }
        }
        class Ts extends jr {
          constructor(t) {
            super(t),
              (this.mutationObserver = t.getObserver(us)),
              (this.selection = this.document.selection),
              (this.domConverter = t.domConverter),
              (this._documents = new WeakSet()),
              (this._fireSelectionChangeDoneDebounced = Ss(t => this.document.fire('selectionChangeDone', t), 200)),
              (this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3)),
              (this._loopbackCounter = 0);
          }
          observe(t) {
            const e = t.ownerDocument;
            this._documents.has(e) ||
              (this.listenTo(e, 'selectionchange', (t, n) => {
                this._handleSelectionChange(n, e);
              }),
              this._documents.add(e));
          }
          destroy() {
            super.destroy(),
              clearInterval(this._clearInfiniteLoopInterval),
              this._fireSelectionChangeDoneDebounced.cancel();
          }
          _handleSelectionChange(t, e) {
            if (!this.isEnabled) return;
            const n = e.defaultView.getSelection();
            if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) return;
            this.mutationObserver.flush();
            const o = this.domConverter.domSelectionToView(n);
            if (0 != o.rangeCount) {
              if (
                ((this.view.hasDomSelection = !0),
                !(
                  (this.selection.isEqual(o) && this.domConverter.isDomSelectionCorrect(n)) ||
                  ++this._loopbackCounter > 60
                ))
              )
                if (this.selection.isSimilar(o)) this.view.forceRender();
                else {
                  const t = { oldSelection: this.selection, newSelection: o, domSelection: n };
                  this.document.fire('selectionChange', t), this._fireSelectionChangeDoneDebounced(t);
                }
            } else this.view.hasDomSelection = !1;
          }
          _clearInfiniteLoop() {
            this._loopbackCounter = 0;
          }
        }
        class Ps extends ms {
          constructor(t) {
            super(t), (this.domEventType = ['focus', 'blur']), (this.useCapture = !0);
            const e = this.document;
            e.on('focus', () => {
              (e.isFocused = !0), (this._renderTimeoutId = setTimeout(() => t.forceRender(), 50));
            }),
              e.on('blur', (n, o) => {
                const i = e.selection.editableElement;
                (null !== i && i !== o.target) || ((e.isFocused = !1), t.forceRender());
              });
          }
          onDomEvent(t) {
            this.fire(t.type, t);
          }
          destroy() {
            this._renderTimeoutId && clearTimeout(this._renderTimeoutId), super.destroy();
          }
        }
        class Is extends ms {
          constructor(t) {
            super(t), (this.domEventType = ['compositionstart', 'compositionupdate', 'compositionend']);
            const e = this.document;
            e.on('compositionstart', () => {
              e.isComposing = !0;
            }),
              e.on('compositionend', () => {
                e.isComposing = !1;
              });
          }
          onDomEvent(t) {
            this.fire(t.type, t);
          }
        }
        class zs extends ms {
          constructor(t) {
            super(t), (this.domEventType = ['beforeinput']);
          }
          onDomEvent(t) {
            this.fire(t.type, t);
          }
        }
        var Fs = function (t) {
          return 'string' == typeof t || (!_t(t) && gt(t) && '[object String]' == T(t));
        };
        function Rs(t, e, n = {}, o = []) {
          const i = n && n.xmlns,
            r = i ? t.createElementNS(i, e) : t.createElement(e);
          for (const t in n) r.setAttribute(t, n[t]);
          (!Fs(o) && ao(o)) || (o = [o]);
          for (let e of o) Fs(e) && (e = t.createTextNode(e)), r.appendChild(e);
          return r;
        }
        function Os(t) {
          return '[object Range]' == Object.prototype.toString.apply(t);
        }
        function Ms(t) {
          const e = t.ownerDocument.defaultView.getComputedStyle(t);
          return {
            top: parseInt(e.borderTopWidth, 10),
            right: parseInt(e.borderRightWidth, 10),
            bottom: parseInt(e.borderBottomWidth, 10),
            left: parseInt(e.borderLeftWidth, 10),
          };
        }
        const Ns = ['top', 'right', 'bottom', 'left', 'width', 'height'];
        class Vs {
          constructor(t) {
            const e = Os(t);
            if (
              (Object.defineProperty(this, '_source', { value: t._source || t, writable: !0, enumerable: !1 }),
              oo(t) || e)
            )
              if (e) {
                const e = Vs.getDomRangeRects(t);
                Ls(this, Vs.getBoundingRect(e));
              } else Ls(this, t.getBoundingClientRect());
            else if (Lr(t)) {
              const { innerWidth: e, innerHeight: n } = t;
              Ls(this, { top: 0, right: e, bottom: n, left: 0, width: e, height: n });
            } else Ls(this, t);
          }
          clone() {
            return new Vs(this);
          }
          moveTo(t, e) {
            return (
              (this.top = e), (this.right = t + this.width), (this.bottom = e + this.height), (this.left = t), this
            );
          }
          moveBy(t, e) {
            return (this.top += e), (this.right += t), (this.left += t), (this.bottom += e), this;
          }
          getIntersection(t) {
            const e = {
              top: Math.max(this.top, t.top),
              right: Math.min(this.right, t.right),
              bottom: Math.min(this.bottom, t.bottom),
              left: Math.max(this.left, t.left),
            };
            return (
              (e.width = e.right - e.left),
              (e.height = e.bottom - e.top),
              e.width < 0 || e.height < 0 ? null : new Vs(e)
            );
          }
          getIntersectionArea(t) {
            const e = this.getIntersection(t);
            return e ? e.getArea() : 0;
          }
          getArea() {
            return this.width * this.height;
          }
          getVisible() {
            const t = this._source;
            let e = this.clone();
            if (!Ks(t)) {
              let n = t.parentNode || t.commonAncestorContainer;
              for (; n && !Ks(n); ) {
                const t = new Vs(n),
                  o = e.getIntersection(t);
                if (!o) return null;
                o.getArea() < e.getArea() && (e = o), (n = n.parentNode);
              }
            }
            return e;
          }
          isEqual(t) {
            for (const e of Ns) if (this[e] !== t[e]) return !1;
            return !0;
          }
          contains(t) {
            const e = this.getIntersection(t);
            return !(!e || !e.isEqual(t));
          }
          excludeScrollbarsAndBorders() {
            const t = this._source;
            let e, n, o;
            if (Lr(t))
              (e = t.innerWidth - t.document.documentElement.clientWidth),
                (n = t.innerHeight - t.document.documentElement.clientHeight),
                (o = t.getComputedStyle(t.document.documentElement).direction);
            else {
              const i = Ms(this._source);
              (e = t.offsetWidth - t.clientWidth - i.left - i.right),
                (n = t.offsetHeight - t.clientHeight - i.top - i.bottom),
                (o = t.ownerDocument.defaultView.getComputedStyle(t).direction),
                (this.left += i.left),
                (this.top += i.top),
                (this.right -= i.right),
                (this.bottom -= i.bottom),
                (this.width = this.right - this.left),
                (this.height = this.bottom - this.top);
            }
            return (
              (this.width -= e),
              'ltr' === o ? (this.right -= e) : (this.left += e),
              (this.height -= n),
              (this.bottom -= n),
              this
            );
          }
          static getDomRangeRects(t) {
            const e = [],
              n = Array.from(t.getClientRects());
            if (n.length) for (const t of n) e.push(new Vs(t));
            else {
              let n = t.startContainer;
              dr(n) && (n = n.parentNode);
              const o = new Vs(n.getBoundingClientRect());
              (o.right = o.left), (o.width = 0), e.push(o);
            }
            return e;
          }
          static getBoundingRect(t) {
            const e = {
              left: Number.POSITIVE_INFINITY,
              top: Number.POSITIVE_INFINITY,
              right: Number.NEGATIVE_INFINITY,
              bottom: Number.NEGATIVE_INFINITY,
            };
            let n = 0;
            for (const o of t)
              n++,
                (e.left = Math.min(e.left, o.left)),
                (e.top = Math.min(e.top, o.top)),
                (e.right = Math.max(e.right, o.right)),
                (e.bottom = Math.max(e.bottom, o.bottom));
            return 0 == n ? null : ((e.width = e.right - e.left), (e.height = e.bottom - e.top), new Vs(e));
          }
        }
        function Ls(t, e) {
          for (const n of Ns) t[n] = e[n];
        }
        function Ks(t) {
          return !!oo(t) && t === t.ownerDocument.body;
        }
        class qs {
          constructor(t, e) {
            qs._observerInstance || qs._createObserver(),
              (this._element = t),
              (this._callback = e),
              qs._addElementCallback(t, e),
              qs._observerInstance.observe(t);
          }
          destroy() {
            qs._deleteElementCallback(this._element, this._callback);
          }
          static _addElementCallback(t, e) {
            qs._elementCallbacks || (qs._elementCallbacks = new Map());
            let n = qs._elementCallbacks.get(t);
            n || ((n = new Set()), qs._elementCallbacks.set(t, n)), n.add(e);
          }
          static _deleteElementCallback(t, e) {
            const n = qs._getElementCallbacks(t);
            n && (n.delete(e), n.size || (qs._elementCallbacks.delete(t), qs._observerInstance.unobserve(t))),
              qs._elementCallbacks &&
                !qs._elementCallbacks.size &&
                ((qs._observerInstance = null), (qs._elementCallbacks = null));
          }
          static _getElementCallbacks(t) {
            return qs._elementCallbacks ? qs._elementCallbacks.get(t) : null;
          }
          static _createObserver() {
            let t;
            (t = 'function' == typeof Tr.window.ResizeObserver ? Tr.window.ResizeObserver : Hs),
              (qs._observerInstance = new t(t => {
                for (const e of t) {
                  const t = qs._getElementCallbacks(e.target);
                  if (t) for (const n of t) n(e);
                }
              }));
          }
        }
        (qs._observerInstance = null), (qs._elementCallbacks = null);
        class Hs {
          constructor(t) {
            (this._callback = t),
              (this._elements = new Set()),
              (this._previousRects = new Map()),
              (this._periodicCheckTimeout = null);
          }
          observe(t) {
            this._elements.add(t),
              this._checkElementRectsAndExecuteCallback(),
              1 === this._elements.size && this._startPeriodicCheck();
          }
          unobserve(t) {
            this._elements.delete(t), this._previousRects.delete(t), this._elements.size || this._stopPeriodicCheck();
          }
          _startPeriodicCheck() {
            const t = () => {
              this._checkElementRectsAndExecuteCallback(), (this._periodicCheckTimeout = setTimeout(t, 100));
            };
            this.listenTo(Tr.window, 'resize', () => {
              this._checkElementRectsAndExecuteCallback();
            }),
              (this._periodicCheckTimeout = setTimeout(t, 100));
          }
          _stopPeriodicCheck() {
            clearTimeout(this._periodicCheckTimeout), this.stopListening(), this._previousRects.clear();
          }
          _checkElementRectsAndExecuteCallback() {
            const t = [];
            for (const e of this._elements)
              this._hasRectChanged(e) && t.push({ target: e, contentRect: this._previousRects.get(e) });
            t.length && this._callback(t);
          }
          _hasRectChanged(t) {
            if (!t.ownerDocument.body.contains(t)) return !1;
            const e = new Vs(t),
              n = this._previousRects.get(t),
              o = !n || !n.isEqual(e);
            return this._previousRects.set(t, e), o;
          }
        }
        function js(t, e) {
          t instanceof HTMLTextAreaElement && (t.value = e), (t.innerHTML = e);
        }
        function $s(t) {
          return e => e + t;
        }
        function Gs(t) {
          const e = t.next();
          return e.done ? null : e.value;
        }
        Yt(Hs, Kr);
        class Ws {
          constructor() {
            this.set('isFocused', !1),
              this.set('focusedElement', null),
              (this._elements = new Set()),
              (this._nextEventLoopTimeout = null);
          }
          add(t) {
            if (this._elements.has(t)) throw new c.a('focustracker-add-element-already-exist', this);
            this.listenTo(t, 'focus', () => this._focus(t), { useCapture: !0 }),
              this.listenTo(t, 'blur', () => this._blur(), { useCapture: !0 }),
              this._elements.add(t);
          }
          remove(t) {
            t === this.focusedElement && this._blur(t),
              this._elements.has(t) && (this.stopListening(t), this._elements.delete(t));
          }
          destroy() {
            this.stopListening();
          }
          _focus(t) {
            clearTimeout(this._nextEventLoopTimeout), (this.focusedElement = t), (this.isFocused = !0);
          }
          _blur() {
            clearTimeout(this._nextEventLoopTimeout),
              (this._nextEventLoopTimeout = setTimeout(() => {
                (this.focusedElement = null), (this.isFocused = !1);
              }, 0));
          }
        }
        Yt(Ws, Kr), Yt(Ws, jt);
        class Us {
          constructor() {
            this._listener = Object.create(Kr);
          }
          listenTo(t) {
            this._listener.listenTo(t, 'keydown', (t, e) => {
              this._listener.fire('_keydown:' + qi(e), e);
            });
          }
          set(t, e, n = {}) {
            const o = Hi(t),
              i = n.priority;
            this._listener.listenTo(
              this._listener,
              '_keydown:' + o,
              (t, n) => {
                e(n, () => {
                  n.preventDefault(), n.stopPropagation(), t.stop();
                }),
                  (t.return = !0);
              },
              { priority: i },
            );
          }
          press(t) {
            return !!this._listener.fire('_keydown:' + qi(t), t);
          }
          destroy() {
            this._listener.stopListening();
          }
        }
        class Js extends jr {
          constructor(t) {
            super(t),
              this.document.on('keydown', (t, e) => {
                if (
                  this.isEnabled &&
                  ((n = e.keyCode) == Li.arrowright || n == Li.arrowleft || n == Li.arrowup || n == Li.arrowdown)
                ) {
                  const n = new vi(this.document, 'arrowKey', this.document.selection.getFirstRange());
                  this.document.fire(n, e), n.stop.called && t.stop();
                }
                var n;
              });
          }
          observe() {}
        }
        function Ys({ target: t, viewportOffset: e = 0 }) {
          const n = oa(t);
          let o = n,
            i = null;
          for (; o; ) {
            let r;
            (r = ia(o == n ? t : i)), Xs(r, () => ra(t, o));
            const s = ra(t, o);
            if ((Qs(o, s, e), o.parent != o)) {
              if (((i = o.frameElement), (o = o.parent), !i)) return;
            } else o = null;
          }
        }
        function Qs(t, e, n) {
          const o = e.clone().moveBy(0, n),
            i = e.clone().moveBy(0, -n),
            r = new Vs(t).excludeScrollbarsAndBorders();
          if (![i, o].every(t => r.contains(t))) {
            let { scrollX: s, scrollY: a } = t;
            ta(i, r) ? (a -= r.top - e.top + n) : Zs(o, r) && (a += e.bottom - r.bottom + n),
              ea(e, r) ? (s -= r.left - e.left + n) : na(e, r) && (s += e.right - r.right + n),
              t.scrollTo(s, a);
          }
        }
        function Xs(t, e) {
          const n = oa(t);
          let o, i;
          for (; t != n.document.body; )
            (i = e()),
              (o = new Vs(t).excludeScrollbarsAndBorders()),
              o.contains(i) ||
                (ta(i, o) ? (t.scrollTop -= o.top - i.top) : Zs(i, o) && (t.scrollTop += i.bottom - o.bottom),
                ea(i, o) ? (t.scrollLeft -= o.left - i.left) : na(i, o) && (t.scrollLeft += i.right - o.right)),
              (t = t.parentNode);
        }
        function Zs(t, e) {
          return t.bottom > e.bottom;
        }
        function ta(t, e) {
          return t.top < e.top;
        }
        function ea(t, e) {
          return t.left < e.left;
        }
        function na(t, e) {
          return t.right > e.right;
        }
        function oa(t) {
          return Os(t) ? t.startContainer.ownerDocument.defaultView : t.ownerDocument.defaultView;
        }
        function ia(t) {
          if (Os(t)) {
            let e = t.commonAncestorContainer;
            return dr(e) && (e = e.parentNode), e;
          }
          return t.parentNode;
        }
        function ra(t, e) {
          const n = oa(t),
            o = new Vs(t);
          if (n === e) return o;
          {
            let t = n;
            for (; t != e; ) {
              const e = t.frameElement,
                n = new Vs(e).excludeScrollbarsAndBorders();
              o.moveBy(n.left, n.top), (t = t.parent);
            }
          }
          return o;
        }
        Object.assign(
          {},
          {
            scrollViewportToShowTarget: Ys,
            scrollAncestorsToShowTarget: function (t) {
              Xs(ia(t), () => new Vs(t));
            },
          },
        );
        class sa {
          constructor(t) {
            (this.document = new Ti(t)),
              (this.domConverter = new Or(this.document)),
              (this.domRoots = new Map()),
              this.set('isRenderingInProgress', !1),
              this.set('hasDomSelection', !1),
              (this._renderer = new Er(this.domConverter, this.document.selection)),
              this._renderer.bind('isFocused').to(this.document),
              (this._initialDomRootAttributes = new WeakMap()),
              (this._observers = new Map()),
              (this._ongoingChange = !1),
              (this._postFixersInProgress = !1),
              (this._renderingDisabled = !1),
              (this._hasChangedSinceTheLastRendering = !1),
              (this._writer = new Zi(this.document)),
              this.addObserver(us),
              this.addObserver(Ts),
              this.addObserver(Ps),
              this.addObserver(gs),
              this.addObserver(Bs),
              this.addObserver(Is),
              this.addObserver(Js),
              Mi.isAndroid && this.addObserver(zs),
              this.document.on('arrowKey', br, { priority: 'low' }),
              Ui(this),
              this.on('render', () => {
                this._render(), this.document.fire('layoutChanged'), (this._hasChangedSinceTheLastRendering = !1);
              }),
              this.listenTo(this.document.selection, 'change', () => {
                this._hasChangedSinceTheLastRendering = !0;
              });
          }
          attachDomRoot(t, e = 'main') {
            const n = this.document.getRoot(e);
            n._name = t.tagName.toLowerCase();
            const o = {};
            for (const { name: e, value: i } of Array.from(t.attributes))
              (o[e] = i), 'class' === e ? this._writer.addClass(i.split(' '), n) : this._writer.setAttribute(e, i, n);
            this._initialDomRootAttributes.set(t, o);
            const i = () => {
              this._writer.setAttribute('contenteditable', !n.isReadOnly, n),
                n.isReadOnly ? this._writer.addClass('ck-read-only', n) : this._writer.removeClass('ck-read-only', n);
            };
            i(),
              this.domRoots.set(e, t),
              this.domConverter.bindElements(t, n),
              this._renderer.markToSync('children', n),
              this._renderer.markToSync('attributes', n),
              this._renderer.domDocuments.add(t.ownerDocument),
              n.on('change:children', (t, e) => this._renderer.markToSync('children', e)),
              n.on('change:attributes', (t, e) => this._renderer.markToSync('attributes', e)),
              n.on('change:text', (t, e) => this._renderer.markToSync('text', e)),
              n.on('change:isReadOnly', () => this.change(i)),
              n.on('change', () => {
                this._hasChangedSinceTheLastRendering = !0;
              });
            for (const n of this._observers.values()) n.observe(t, e);
          }
          detachDomRoot(t) {
            const e = this.domRoots.get(t);
            Array.from(e.attributes).forEach(({ name: t }) => e.removeAttribute(t));
            const n = this._initialDomRootAttributes.get(e);
            for (const t in n) e.setAttribute(t, n[t]);
            this.domRoots.delete(t), this.domConverter.unbindDomElement(e);
          }
          getDomRoot(t = 'main') {
            return this.domRoots.get(t);
          }
          addObserver(t) {
            let e = this._observers.get(t);
            if (e) return e;
            (e = new t(this)), this._observers.set(t, e);
            for (const [t, n] of this.domRoots) e.observe(n, t);
            return e.enable(), e;
          }
          getObserver(t) {
            return this._observers.get(t);
          }
          disableObservers() {
            for (const t of this._observers.values()) t.disable();
          }
          enableObservers() {
            for (const t of this._observers.values()) t.enable();
          }
          scrollToTheSelection() {
            const t = this.document.selection.getFirstRange();
            t && Ys({ target: this.domConverter.viewRangeToDom(t), viewportOffset: 20 });
          }
          focus() {
            if (!this.document.isFocused) {
              const t = this.document.selection.editableElement;
              t && (this.domConverter.focus(t), this.forceRender());
            }
          }
          change(t) {
            if (this.isRenderingInProgress || this._postFixersInProgress)
              throw new c.a('cannot-change-view-tree', this);
            try {
              if (this._ongoingChange) return t(this._writer);
              this._ongoingChange = !0;
              const e = t(this._writer);
              return (
                (this._ongoingChange = !1),
                !this._renderingDisabled &&
                  this._hasChangedSinceTheLastRendering &&
                  ((this._postFixersInProgress = !0),
                  this.document._callPostFixers(this._writer),
                  (this._postFixersInProgress = !1),
                  this.fire('render')),
                e
              );
            } catch (t) {
              c.a.rethrowUnexpectedError(t, this);
            }
          }
          forceRender() {
            (this._hasChangedSinceTheLastRendering = !0), this.change(() => {});
          }
          destroy() {
            for (const t of this._observers.values()) t.destroy();
            this.document.destroy(), this.stopListening();
          }
          createPositionAt(t, e) {
            return ki._createAt(t, e);
          }
          createPositionAfter(t) {
            return ki._createAfter(t);
          }
          createPositionBefore(t) {
            return ki._createBefore(t);
          }
          createRange(t, e) {
            return new bi(t, e);
          }
          createRangeOn(t) {
            return bi._createOn(t);
          }
          createRangeIn(t) {
            return bi._createIn(t);
          }
          createSelection(t, e, n) {
            return new _i(t, e, n);
          }
          _disableRendering(t) {
            (this._renderingDisabled = t), 0 == t && this.change(() => {});
          }
          _render() {
            (this.isRenderingInProgress = !0),
              this.disableObservers(),
              this._renderer.render(),
              this.enableObservers(),
              (this.isRenderingInProgress = !1);
          }
        }
        Yt(sa, jt);
        class aa {
          constructor(t) {
            (this.parent = null), (this._attrs = vo(t));
          }
          get index() {
            let t;
            if (!this.parent) return null;
            if (null === (t = this.parent.getChildIndex(this))) throw new c.a('model-node-not-found-in-parent', this);
            return t;
          }
          get startOffset() {
            let t;
            if (!this.parent) return null;
            if (null === (t = this.parent.getChildStartOffset(this)))
              throw new c.a('model-node-not-found-in-parent', this);
            return t;
          }
          get offsetSize() {
            return 1;
          }
          get endOffset() {
            return this.parent ? this.startOffset + this.offsetSize : null;
          }
          get nextSibling() {
            const t = this.index;
            return (null !== t && this.parent.getChild(t + 1)) || null;
          }
          get previousSibling() {
            const t = this.index;
            return (null !== t && this.parent.getChild(t - 1)) || null;
          }
          get root() {
            let t = this;
            for (; t.parent; ) t = t.parent;
            return t;
          }
          isAttached() {
            return this.root.is('rootElement');
          }
          getPath() {
            const t = [];
            let e = this;
            for (; e.parent; ) t.unshift(e.startOffset), (e = e.parent);
            return t;
          }
          getAncestors(t = { includeSelf: !1, parentFirst: !1 }) {
            const e = [];
            let n = t.includeSelf ? this : this.parent;
            for (; n; ) e[t.parentFirst ? 'push' : 'unshift'](n), (n = n.parent);
            return e;
          }
          getCommonAncestor(t, e = {}) {
            const n = this.getAncestors(e),
              o = t.getAncestors(e);
            let i = 0;
            for (; n[i] == o[i] && n[i]; ) i++;
            return 0 === i ? null : n[i - 1];
          }
          isBefore(t) {
            if (this == t) return !1;
            if (this.root !== t.root) return !1;
            const e = this.getPath(),
              n = t.getPath(),
              o = bo(e, n);
            switch (o) {
              case 'prefix':
                return !0;
              case 'extension':
                return !1;
              default:
                return e[o] < n[o];
            }
          }
          isAfter(t) {
            return this != t && this.root === t.root && !this.isBefore(t);
          }
          hasAttribute(t) {
            return this._attrs.has(t);
          }
          getAttribute(t) {
            return this._attrs.get(t);
          }
          getAttributes() {
            return this._attrs.entries();
          }
          getAttributeKeys() {
            return this._attrs.keys();
          }
          toJSON() {
            const t = {};
            return (
              this._attrs.size && (t.attributes = Array.from(this._attrs).reduce((t, e) => ((t[e[0]] = e[1]), t), {})),
              t
            );
          }
          is(t) {
            return 'node' === t || 'model:node' === t;
          }
          _clone() {
            return new aa(this._attrs);
          }
          _remove() {
            this.parent._removeChildren(this.index);
          }
          _setAttribute(t, e) {
            this._attrs.set(t, e);
          }
          _setAttributesTo(t) {
            this._attrs = vo(t);
          }
          _removeAttribute(t) {
            return this._attrs.delete(t);
          }
          _clearAttributes() {
            this._attrs.clear();
          }
        }
        class ca extends aa {
          constructor(t, e) {
            super(e), (this._data = t || '');
          }
          get offsetSize() {
            return this.data.length;
          }
          get data() {
            return this._data;
          }
          is(t) {
            return (
              '$text' === t ||
              'model:$text' === t ||
              'text' === t ||
              'model:text' === t ||
              'node' === t ||
              'model:node' === t
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (t.data = this.data), t;
          }
          _clone() {
            return new ca(this.data, this.getAttributes());
          }
          static fromJSON(t) {
            return new ca(t.data, t.attributes);
          }
        }
        class la {
          constructor(t, e, n) {
            if (((this.textNode = t), e < 0 || e > t.offsetSize))
              throw new c.a('model-textproxy-wrong-offsetintext', this);
            if (n < 0 || e + n > t.offsetSize) throw new c.a('model-textproxy-wrong-length', this);
            (this.data = t.data.substring(e, e + n)), (this.offsetInText = e);
          }
          get startOffset() {
            return null !== this.textNode.startOffset ? this.textNode.startOffset + this.offsetInText : null;
          }
          get offsetSize() {
            return this.data.length;
          }
          get endOffset() {
            return null !== this.startOffset ? this.startOffset + this.offsetSize : null;
          }
          get isPartial() {
            return this.offsetSize !== this.textNode.offsetSize;
          }
          get parent() {
            return this.textNode.parent;
          }
          get root() {
            return this.textNode.root;
          }
          is(t) {
            return '$textProxy' === t || 'model:$textProxy' === t || 'textProxy' === t || 'model:textProxy' === t;
          }
          getPath() {
            const t = this.textNode.getPath();
            return t.length > 0 && (t[t.length - 1] += this.offsetInText), t;
          }
          getAncestors(t = { includeSelf: !1, parentFirst: !1 }) {
            const e = [];
            let n = t.includeSelf ? this : this.parent;
            for (; n; ) e[t.parentFirst ? 'push' : 'unshift'](n), (n = n.parent);
            return e;
          }
          hasAttribute(t) {
            return this.textNode.hasAttribute(t);
          }
          getAttribute(t) {
            return this.textNode.getAttribute(t);
          }
          getAttributes() {
            return this.textNode.getAttributes();
          }
          getAttributeKeys() {
            return this.textNode.getAttributeKeys();
          }
        }
        class da {
          constructor(t) {
            (this._nodes = []), t && this._insertNodes(0, t);
          }
          [Symbol.iterator]() {
            return this._nodes[Symbol.iterator]();
          }
          get length() {
            return this._nodes.length;
          }
          get maxOffset() {
            return this._nodes.reduce((t, e) => t + e.offsetSize, 0);
          }
          getNode(t) {
            return this._nodes[t] || null;
          }
          getNodeIndex(t) {
            const e = this._nodes.indexOf(t);
            return -1 == e ? null : e;
          }
          getNodeStartOffset(t) {
            const e = this.getNodeIndex(t);
            return null === e ? null : this._nodes.slice(0, e).reduce((t, e) => t + e.offsetSize, 0);
          }
          indexToOffset(t) {
            if (t == this._nodes.length) return this.maxOffset;
            const e = this._nodes[t];
            if (!e) throw new c.a('model-nodelist-index-out-of-bounds', this);
            return this.getNodeStartOffset(e);
          }
          offsetToIndex(t) {
            let e = 0;
            for (const n of this._nodes) {
              if (t >= e && t < e + n.offsetSize) return this.getNodeIndex(n);
              e += n.offsetSize;
            }
            if (e != t) throw new c.a('model-nodelist-offset-out-of-bounds', this, { offset: t, nodeList: this });
            return this.length;
          }
          _insertNodes(t, e) {
            for (const t of e) if (!(t instanceof aa)) throw new c.a('model-nodelist-insertnodes-not-node', this);
            this._nodes.splice(t, 0, ...e);
          }
          _removeNodes(t, e = 1) {
            return this._nodes.splice(t, e);
          }
          toJSON() {
            return this._nodes.map(t => t.toJSON());
          }
        }
        class ha extends aa {
          constructor(t, e, n) {
            super(e), (this.name = t), (this._children = new da()), n && this._insertChild(0, n);
          }
          get childCount() {
            return this._children.length;
          }
          get maxOffset() {
            return this._children.maxOffset;
          }
          get isEmpty() {
            return 0 === this.childCount;
          }
          is(t, e = null) {
            return e
              ? e === this.name && ('element' === t || 'model:element' === t)
              : 'element' === t || 'model:element' === t || 'node' === t || 'model:node' === t;
          }
          getChild(t) {
            return this._children.getNode(t);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          getChildIndex(t) {
            return this._children.getNodeIndex(t);
          }
          getChildStartOffset(t) {
            return this._children.getNodeStartOffset(t);
          }
          offsetToIndex(t) {
            return this._children.offsetToIndex(t);
          }
          getNodeByPath(t) {
            let e = this;
            for (const n of t) e = e.getChild(e.offsetToIndex(n));
            return e;
          }
          findAncestor(t, e = { includeSelf: !1 }) {
            let n = e.includeSelf ? this : this.parent;
            for (; n; ) {
              if (n.name === t) return n;
              n = n.parent;
            }
            return null;
          }
          toJSON() {
            const t = super.toJSON();
            if (((t.name = this.name), this._children.length > 0)) {
              t.children = [];
              for (const e of this._children) t.children.push(e.toJSON());
            }
            return t;
          }
          _clone(t = !1) {
            const e = t ? Array.from(this._children).map(t => t._clone(!0)) : null;
            return new ha(this.name, this.getAttributes(), e);
          }
          _appendChild(t) {
            this._insertChild(this.childCount, t);
          }
          _insertChild(t, e) {
            const n = (function (t) {
              if ('string' == typeof t) return [new ca(t)];
              ao(t) || (t = [t]);
              return Array.from(t).map(t =>
                'string' == typeof t ? new ca(t) : t instanceof la ? new ca(t.data, t.getAttributes()) : t,
              );
            })(e);
            for (const t of n) null !== t.parent && t._remove(), (t.parent = this);
            this._children._insertNodes(t, n);
          }
          _removeChildren(t, e = 1) {
            const n = this._children._removeNodes(t, e);
            for (const t of n) t.parent = null;
            return n;
          }
          static fromJSON(t) {
            let e = null;
            if (t.children) {
              e = [];
              for (const n of t.children) n.name ? e.push(ha.fromJSON(n)) : e.push(ca.fromJSON(n));
            }
            return new ha(t.name, t.attributes, e);
          }
        }
        class ua {
          constructor(t = {}) {
            if (!t.boundaries && !t.startPosition) throw new c.a('model-tree-walker-no-start-position', null);
            const e = t.direction || 'forward';
            if ('forward' != e && 'backward' != e)
              throw new c.a('model-tree-walker-unknown-direction', t, { direction: e });
            (this.direction = e),
              (this.boundaries = t.boundaries || null),
              t.startPosition
                ? (this.position = t.startPosition.clone())
                : (this.position = ma._createAt(this.boundaries['backward' == this.direction ? 'end' : 'start'])),
              (this.position.stickiness = 'toNone'),
              (this.singleCharacters = !!t.singleCharacters),
              (this.shallow = !!t.shallow),
              (this.ignoreElementEnd = !!t.ignoreElementEnd),
              (this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null),
              (this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null),
              (this._visitedParent = this.position.parent);
          }
          [Symbol.iterator]() {
            return this;
          }
          skip(t) {
            let e, n, o, i;
            do {
              (o = this.position), (i = this._visitedParent), ({ done: e, value: n } = this.next());
            } while (!e && t(n));
            e || ((this.position = o), (this._visitedParent = i));
          }
          next() {
            return 'forward' == this.direction ? this._next() : this._previous();
          }
          _next() {
            const t = this.position,
              e = this.position.clone(),
              n = this._visitedParent;
            if (null === n.parent && e.offset === n.maxOffset) return { done: !0 };
            if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset) return { done: !0 };
            const o = e.parent,
              i = ga(e, o),
              r = i || fa(e, o, i);
            if (r instanceof ha)
              return (
                this.shallow ? e.offset++ : (e.path.push(0), (this._visitedParent = r)),
                (this.position = e),
                pa('elementStart', r, t, e, 1)
              );
            if (r instanceof ca) {
              let o;
              if (this.singleCharacters) o = 1;
              else {
                let t = r.endOffset;
                this._boundaryEndParent == n && this.boundaries.end.offset < t && (t = this.boundaries.end.offset),
                  (o = t - e.offset);
              }
              const i = e.offset - r.startOffset,
                s = new la(r, i, o);
              return (e.offset += o), (this.position = e), pa('text', s, t, e, o);
            }
            return (
              e.path.pop(),
              e.offset++,
              (this.position = e),
              (this._visitedParent = n.parent),
              this.ignoreElementEnd ? this._next() : pa('elementEnd', n, t, e)
            );
          }
          _previous() {
            const t = this.position,
              e = this.position.clone(),
              n = this._visitedParent;
            if (null === n.parent && 0 === e.offset) return { done: !0 };
            if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset) return { done: !0 };
            const o = e.parent,
              i = ga(e, o),
              r = i || ka(e, o, i);
            if (r instanceof ha)
              return (
                e.offset--,
                this.shallow
                  ? ((this.position = e), pa('elementStart', r, t, e, 1))
                  : (e.path.push(r.maxOffset),
                    (this.position = e),
                    (this._visitedParent = r),
                    this.ignoreElementEnd ? this._previous() : pa('elementEnd', r, t, e))
              );
            if (r instanceof ca) {
              let o;
              if (this.singleCharacters) o = 1;
              else {
                let t = r.startOffset;
                this._boundaryStartParent == n &&
                  this.boundaries.start.offset > t &&
                  (t = this.boundaries.start.offset),
                  (o = e.offset - t);
              }
              const i = e.offset - r.startOffset,
                s = new la(r, i - o, o);
              return (e.offset -= o), (this.position = e), pa('text', s, t, e, o);
            }
            return e.path.pop(), (this.position = e), (this._visitedParent = n.parent), pa('elementStart', n, t, e, 1);
          }
        }
        function pa(t, e, n, o, i) {
          return { done: !1, value: { type: t, item: e, previousPosition: n, nextPosition: o, length: i } };
        }
        class ma {
          constructor(t, e, n = 'toNone') {
            if (!t.is('element') && !t.is('documentFragment')) throw new c.a('model-position-root-invalid', t);
            if (!(e instanceof Array) || 0 === e.length)
              throw new c.a('model-position-path-incorrect-format', t, { path: e });
            t.is('rootElement') ? (e = e.slice()) : ((e = [...t.getPath(), ...e]), (t = t.root)),
              (this.root = t),
              (this.path = e),
              (this.stickiness = n);
          }
          get offset() {
            return this.path[this.path.length - 1];
          }
          set offset(t) {
            this.path[this.path.length - 1] = t;
          }
          get parent() {
            let t = this.root;
            for (let e = 0; e < this.path.length - 1; e++)
              if (((t = t.getChild(t.offsetToIndex(this.path[e]))), !t))
                throw new c.a('model-position-path-incorrect', this, { position: this });
            if (t.is('$text')) throw new c.a('model-position-path-incorrect', this, { position: this });
            return t;
          }
          get index() {
            return this.parent.offsetToIndex(this.offset);
          }
          get textNode() {
            return ga(this, this.parent);
          }
          get nodeAfter() {
            const t = this.parent;
            return fa(this, t, ga(this, t));
          }
          get nodeBefore() {
            const t = this.parent;
            return ka(this, t, ga(this, t));
          }
          get isAtStart() {
            return 0 === this.offset;
          }
          get isAtEnd() {
            return this.offset == this.parent.maxOffset;
          }
          compareWith(t) {
            if (this.root != t.root) return 'different';
            const e = bo(this.path, t.path);
            switch (e) {
              case 'same':
                return 'same';
              case 'prefix':
                return 'before';
              case 'extension':
                return 'after';
              default:
                return this.path[e] < t.path[e] ? 'before' : 'after';
            }
          }
          getLastMatchingPosition(t, e = {}) {
            e.startPosition = this;
            const n = new ua(e);
            return n.skip(t), n.position;
          }
          getParentPath() {
            return this.path.slice(0, -1);
          }
          getAncestors() {
            const t = this.parent;
            return t.is('documentFragment') ? [t] : t.getAncestors({ includeSelf: !0 });
          }
          findAncestor(t) {
            const e = this.parent;
            return e.is('element') ? e.findAncestor(t, { includeSelf: !0 }) : null;
          }
          getCommonPath(t) {
            if (this.root != t.root) return [];
            const e = bo(this.path, t.path),
              n = 'string' == typeof e ? Math.min(this.path.length, t.path.length) : e;
            return this.path.slice(0, n);
          }
          getCommonAncestor(t) {
            const e = this.getAncestors(),
              n = t.getAncestors();
            let o = 0;
            for (; e[o] == n[o] && e[o]; ) o++;
            return 0 === o ? null : e[o - 1];
          }
          getShiftedBy(t) {
            const e = this.clone(),
              n = e.offset + t;
            return (e.offset = n < 0 ? 0 : n), e;
          }
          isAfter(t) {
            return 'after' == this.compareWith(t);
          }
          isBefore(t) {
            return 'before' == this.compareWith(t);
          }
          isEqual(t) {
            return 'same' == this.compareWith(t);
          }
          isTouching(t) {
            let e = null,
              n = null;
            switch (this.compareWith(t)) {
              case 'same':
                return !0;
              case 'before':
                (e = ma._createAt(this)), (n = ma._createAt(t));
                break;
              case 'after':
                (e = ma._createAt(t)), (n = ma._createAt(this));
                break;
              default:
                return !1;
            }
            let o = e.parent;
            for (; e.path.length + n.path.length; ) {
              if (e.isEqual(n)) return !0;
              if (e.path.length > n.path.length) {
                if (e.offset !== o.maxOffset) return !1;
                (e.path = e.path.slice(0, -1)), (o = o.parent), e.offset++;
              } else {
                if (0 !== n.offset) return !1;
                n.path = n.path.slice(0, -1);
              }
            }
          }
          is(t) {
            return 'position' === t || 'model:position' === t;
          }
          hasSameParentAs(t) {
            if (this.root !== t.root) return !1;
            return 'same' == bo(this.getParentPath(), t.getParentPath());
          }
          getTransformedByOperation(t) {
            let e;
            switch (t.type) {
              case 'insert':
                e = this._getTransformedByInsertOperation(t);
                break;
              case 'move':
              case 'remove':
              case 'reinsert':
                e = this._getTransformedByMoveOperation(t);
                break;
              case 'split':
                e = this._getTransformedBySplitOperation(t);
                break;
              case 'merge':
                e = this._getTransformedByMergeOperation(t);
                break;
              default:
                e = ma._createAt(this);
            }
            return e;
          }
          _getTransformedByInsertOperation(t) {
            return this._getTransformedByInsertion(t.position, t.howMany);
          }
          _getTransformedByMoveOperation(t) {
            return this._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany);
          }
          _getTransformedBySplitOperation(t) {
            const e = t.movedRange;
            return e.containsPosition(this) || (e.start.isEqual(this) && 'toNext' == this.stickiness)
              ? this._getCombined(t.splitPosition, t.moveTargetPosition)
              : t.graveyardPosition
              ? this._getTransformedByMove(t.graveyardPosition, t.insertionPosition, 1)
              : this._getTransformedByInsertion(t.insertionPosition, 1);
          }
          _getTransformedByMergeOperation(t) {
            const e = t.movedRange;
            let n;
            return (
              e.containsPosition(this) || e.start.isEqual(this)
                ? ((n = this._getCombined(t.sourcePosition, t.targetPosition)),
                  t.sourcePosition.isBefore(t.targetPosition) &&
                    (n = n._getTransformedByDeletion(t.deletionPosition, 1)))
                : (n = this.isEqual(t.deletionPosition)
                    ? ma._createAt(t.deletionPosition)
                    : this._getTransformedByMove(t.deletionPosition, t.graveyardPosition, 1)),
              n
            );
          }
          _getTransformedByDeletion(t, e) {
            const n = ma._createAt(this);
            if (this.root != t.root) return n;
            if ('same' == bo(t.getParentPath(), this.getParentPath())) {
              if (t.offset < this.offset) {
                if (t.offset + e > this.offset) return null;
                n.offset -= e;
              }
            } else if ('prefix' == bo(t.getParentPath(), this.getParentPath())) {
              const o = t.path.length - 1;
              if (t.offset <= this.path[o]) {
                if (t.offset + e > this.path[o]) return null;
                n.path[o] -= e;
              }
            }
            return n;
          }
          _getTransformedByInsertion(t, e) {
            const n = ma._createAt(this);
            if (this.root != t.root) return n;
            if ('same' == bo(t.getParentPath(), this.getParentPath()))
              (t.offset < this.offset || (t.offset == this.offset && 'toPrevious' != this.stickiness)) &&
                (n.offset += e);
            else if ('prefix' == bo(t.getParentPath(), this.getParentPath())) {
              const o = t.path.length - 1;
              t.offset <= this.path[o] && (n.path[o] += e);
            }
            return n;
          }
          _getTransformedByMove(t, e, n) {
            if (((e = e._getTransformedByDeletion(t, n)), t.isEqual(e))) return ma._createAt(this);
            const o = this._getTransformedByDeletion(t, n);
            return null === o ||
              (t.isEqual(this) && 'toNext' == this.stickiness) ||
              (t.getShiftedBy(n).isEqual(this) && 'toPrevious' == this.stickiness)
              ? this._getCombined(t, e)
              : o._getTransformedByInsertion(e, n);
          }
          _getCombined(t, e) {
            const n = t.path.length - 1,
              o = ma._createAt(e);
            return (
              (o.stickiness = this.stickiness),
              (o.offset = o.offset + this.path[n] - t.offset),
              (o.path = [...o.path, ...this.path.slice(n + 1)]),
              o
            );
          }
          toJSON() {
            return { root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness };
          }
          clone() {
            return new this.constructor(this.root, this.path, this.stickiness);
          }
          static _createAt(t, e, n = 'toNone') {
            if (t instanceof ma) return new ma(t.root, t.path, t.stickiness);
            {
              const o = t;
              if ('end' == e) e = o.maxOffset;
              else {
                if ('before' == e) return this._createBefore(o, n);
                if ('after' == e) return this._createAfter(o, n);
                if (0 !== e && !e) throw new c.a('model-createpositionat-offset-required', [this, t]);
              }
              if (!o.is('element') && !o.is('documentFragment'))
                throw new c.a('model-position-parent-incorrect', [this, t]);
              const i = o.getPath();
              return i.push(e), new this(o.root, i, n);
            }
          }
          static _createAfter(t, e) {
            if (!t.parent) throw new c.a('model-position-after-root', [this, t], { root: t });
            return this._createAt(t.parent, t.endOffset, e);
          }
          static _createBefore(t, e) {
            if (!t.parent) throw new c.a('model-position-before-root', t, { root: t });
            return this._createAt(t.parent, t.startOffset, e);
          }
          static fromJSON(t, e) {
            if ('$graveyard' === t.root) {
              const n = new ma(e.graveyard, t.path);
              return (n.stickiness = t.stickiness), n;
            }
            if (!e.getRoot(t.root)) throw new c.a('model-position-fromjson-no-root', e, { rootName: t.root });
            return new ma(e.getRoot(t.root), t.path, t.stickiness);
          }
        }
        function ga(t, e) {
          const n = e.getChild(e.offsetToIndex(t.offset));
          return n && n.is('$text') && n.startOffset < t.offset ? n : null;
        }
        function fa(t, e, n) {
          return null !== n ? null : e.getChild(e.offsetToIndex(t.offset));
        }
        function ka(t, e, n) {
          return null !== n ? null : e.getChild(e.offsetToIndex(t.offset) - 1);
        }
        class ba {
          constructor(t, e = null) {
            (this.start = ma._createAt(t)),
              (this.end = e ? ma._createAt(e) : ma._createAt(t)),
              (this.start.stickiness = this.isCollapsed ? 'toNone' : 'toNext'),
              (this.end.stickiness = this.isCollapsed ? 'toNone' : 'toPrevious');
          }
          *[Symbol.iterator]() {
            yield* new ua({ boundaries: this, ignoreElementEnd: !0 });
          }
          get isCollapsed() {
            return this.start.isEqual(this.end);
          }
          get isFlat() {
            return 'same' == bo(this.start.getParentPath(), this.end.getParentPath());
          }
          get root() {
            return this.start.root;
          }
          containsPosition(t) {
            return t.isAfter(this.start) && t.isBefore(this.end);
          }
          containsRange(t, e = !1) {
            t.isCollapsed && (e = !1);
            const n = this.containsPosition(t.start) || (e && this.start.isEqual(t.start)),
              o = this.containsPosition(t.end) || (e && this.end.isEqual(t.end));
            return n && o;
          }
          containsItem(t) {
            const e = ma._createBefore(t);
            return this.containsPosition(e) || this.start.isEqual(e);
          }
          is(t) {
            return 'range' === t || 'model:range' === t;
          }
          isEqual(t) {
            return this.start.isEqual(t.start) && this.end.isEqual(t.end);
          }
          isIntersecting(t) {
            return this.start.isBefore(t.end) && this.end.isAfter(t.start);
          }
          getDifference(t) {
            const e = [];
            return (
              this.isIntersecting(t)
                ? (this.containsPosition(t.start) && e.push(new ba(this.start, t.start)),
                  this.containsPosition(t.end) && e.push(new ba(t.end, this.end)))
                : e.push(new ba(this.start, this.end)),
              e
            );
          }
          getIntersection(t) {
            if (this.isIntersecting(t)) {
              let e = this.start,
                n = this.end;
              return (
                this.containsPosition(t.start) && (e = t.start),
                this.containsPosition(t.end) && (n = t.end),
                new ba(e, n)
              );
            }
            return null;
          }
          getJoined(t, e = !1) {
            let n = this.isIntersecting(t);
            if (
              (n ||
                (n = this.start.isBefore(t.start)
                  ? e
                    ? this.end.isTouching(t.start)
                    : this.end.isEqual(t.start)
                  : e
                  ? t.end.isTouching(this.start)
                  : t.end.isEqual(this.start)),
              !n)
            )
              return null;
            let o = this.start,
              i = this.end;
            return t.start.isBefore(o) && (o = t.start), t.end.isAfter(i) && (i = t.end), new ba(o, i);
          }
          getMinimalFlatRanges() {
            const t = [],
              e = this.start.getCommonPath(this.end).length,
              n = ma._createAt(this.start);
            let o = n.parent;
            for (; n.path.length > e + 1; ) {
              const e = o.maxOffset - n.offset;
              0 !== e && t.push(new ba(n, n.getShiftedBy(e))),
                (n.path = n.path.slice(0, -1)),
                n.offset++,
                (o = o.parent);
            }
            for (; n.path.length <= this.end.path.length; ) {
              const e = this.end.path[n.path.length - 1],
                o = e - n.offset;
              0 !== o && t.push(new ba(n, n.getShiftedBy(o))), (n.offset = e), n.path.push(0);
            }
            return t;
          }
          getWalker(t = {}) {
            return (t.boundaries = this), new ua(t);
          }
          *getItems(t = {}) {
            (t.boundaries = this), (t.ignoreElementEnd = !0);
            const e = new ua(t);
            for (const t of e) yield t.item;
          }
          *getPositions(t = {}) {
            t.boundaries = this;
            const e = new ua(t);
            yield e.position;
            for (const t of e) yield t.nextPosition;
          }
          getTransformedByOperation(t) {
            switch (t.type) {
              case 'insert':
                return this._getTransformedByInsertOperation(t);
              case 'move':
              case 'remove':
              case 'reinsert':
                return this._getTransformedByMoveOperation(t);
              case 'split':
                return [this._getTransformedBySplitOperation(t)];
              case 'merge':
                return [this._getTransformedByMergeOperation(t)];
            }
            return [new ba(this.start, this.end)];
          }
          getTransformedByOperations(t) {
            const e = [new ba(this.start, this.end)];
            for (const n of t)
              for (let t = 0; t < e.length; t++) {
                const o = e[t].getTransformedByOperation(n);
                e.splice(t, 1, ...o), (t += o.length - 1);
              }
            for (let t = 0; t < e.length; t++) {
              const n = e[t];
              for (let o = t + 1; o < e.length; o++) {
                const t = e[o];
                (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) && e.splice(o, 1);
              }
            }
            return e;
          }
          getCommonAncestor() {
            return this.start.getCommonAncestor(this.end);
          }
          getContainedElement() {
            if (this.isCollapsed) return null;
            const t = this.start.nodeAfter,
              e = this.end.nodeBefore;
            return t && t.is('element') && t === e ? t : null;
          }
          toJSON() {
            return { start: this.start.toJSON(), end: this.end.toJSON() };
          }
          clone() {
            return new this.constructor(this.start, this.end);
          }
          _getTransformedByInsertOperation(t, e = !1) {
            return this._getTransformedByInsertion(t.position, t.howMany, e);
          }
          _getTransformedByMoveOperation(t, e = !1) {
            const n = t.sourcePosition,
              o = t.howMany,
              i = t.targetPosition;
            return this._getTransformedByMove(n, i, o, e);
          }
          _getTransformedBySplitOperation(t) {
            const e = this.start._getTransformedBySplitOperation(t);
            let n = this.end._getTransformedBySplitOperation(t);
            return (
              this.end.isEqual(t.insertionPosition) && (n = this.end.getShiftedBy(1)),
              e.root != n.root && (n = this.end.getShiftedBy(-1)),
              new ba(e, n)
            );
          }
          _getTransformedByMergeOperation(t) {
            if (this.start.isEqual(t.targetPosition) && this.end.isEqual(t.deletionPosition)) return new ba(this.start);
            let e = this.start._getTransformedByMergeOperation(t),
              n = this.end._getTransformedByMergeOperation(t);
            return (
              e.root != n.root && (n = this.end.getShiftedBy(-1)),
              e.isAfter(n)
                ? (t.sourcePosition.isBefore(t.targetPosition)
                    ? ((e = ma._createAt(n)), (e.offset = 0))
                    : (t.deletionPosition.isEqual(e) || (n = t.deletionPosition), (e = t.targetPosition)),
                  new ba(e, n))
                : new ba(e, n)
            );
          }
          _getTransformedByInsertion(t, e, n = !1) {
            if (n && this.containsPosition(t))
              return [new ba(this.start, t), new ba(t.getShiftedBy(e), this.end._getTransformedByInsertion(t, e))];
            {
              const n = new ba(this.start, this.end);
              return (
                (n.start = n.start._getTransformedByInsertion(t, e)),
                (n.end = n.end._getTransformedByInsertion(t, e)),
                [n]
              );
            }
          }
          _getTransformedByMove(t, e, n, o = !1) {
            if (this.isCollapsed) {
              const o = this.start._getTransformedByMove(t, e, n);
              return [new ba(o)];
            }
            const i = ba._createFromPositionAndShift(t, n),
              r = e._getTransformedByDeletion(t, n);
            if (this.containsPosition(e) && !o && (i.containsPosition(this.start) || i.containsPosition(this.end))) {
              const o = this.start._getTransformedByMove(t, e, n),
                i = this.end._getTransformedByMove(t, e, n);
              return [new ba(o, i)];
            }
            let s;
            const a = this.getDifference(i);
            let c = null;
            const l = this.getIntersection(i);
            if (
              (1 == a.length
                ? (c = new ba(a[0].start._getTransformedByDeletion(t, n), a[0].end._getTransformedByDeletion(t, n)))
                : 2 == a.length && (c = new ba(this.start, this.end._getTransformedByDeletion(t, n))),
              (s = c ? c._getTransformedByInsertion(r, n, null !== l || o) : []),
              l)
            ) {
              const t = new ba(l.start._getCombined(i.start, r), l.end._getCombined(i.start, r));
              2 == s.length ? s.splice(1, 0, t) : s.push(t);
            }
            return s;
          }
          _getTransformedByDeletion(t, e) {
            let n = this.start._getTransformedByDeletion(t, e),
              o = this.end._getTransformedByDeletion(t, e);
            return null == n && null == o ? null : (null == n && (n = t), null == o && (o = t), new ba(n, o));
          }
          static _createFromPositionAndShift(t, e) {
            const n = t,
              o = t.getShiftedBy(e);
            return e > 0 ? new this(n, o) : new this(o, n);
          }
          static _createIn(t) {
            return new this(ma._createAt(t, 0), ma._createAt(t, t.maxOffset));
          }
          static _createOn(t) {
            return this._createFromPositionAndShift(ma._createBefore(t), t.offsetSize);
          }
          static _createFromRanges(t) {
            if (0 === t.length) throw new c.a('range-create-from-ranges-empty-array', null);
            if (1 == t.length) return t[0].clone();
            const e = t[0];
            t.sort((t, e) => (t.start.isAfter(e.start) ? 1 : -1));
            const n = t.indexOf(e),
              o = new this(e.start, e.end);
            if (n > 0) for (let e = n - 1; t[e].end.isEqual(o.start); e++) o.start = ma._createAt(t[e].start);
            for (let e = n + 1; e < t.length && t[e].start.isEqual(o.end); e++) o.end = ma._createAt(t[e].end);
            return o;
          }
          static fromJSON(t, e) {
            return new this(ma.fromJSON(t.start, e), ma.fromJSON(t.end, e));
          }
        }
        class wa {
          constructor() {
            (this._modelToViewMapping = new WeakMap()),
              (this._viewToModelMapping = new WeakMap()),
              (this._viewToModelLengthCallbacks = new Map()),
              (this._markerNameToElements = new Map()),
              (this._elementToMarkerNames = new Map()),
              (this._unboundMarkerNames = new Set()),
              this.on(
                'modelToViewPosition',
                (t, e) => {
                  if (e.viewPosition) return;
                  const n = this._modelToViewMapping.get(e.modelPosition.parent);
                  e.viewPosition = this.findPositionIn(n, e.modelPosition.offset);
                },
                { priority: 'low' },
              ),
              this.on(
                'viewToModelPosition',
                (t, e) => {
                  if (e.modelPosition) return;
                  const n = this.findMappedViewAncestor(e.viewPosition),
                    o = this._viewToModelMapping.get(n),
                    i = this._toModelOffset(e.viewPosition.parent, e.viewPosition.offset, n);
                  e.modelPosition = ma._createAt(o, i);
                },
                { priority: 'low' },
              );
          }
          bindElements(t, e) {
            this._modelToViewMapping.set(t, e), this._viewToModelMapping.set(e, t);
          }
          unbindViewElement(t) {
            const e = this.toModelElement(t);
            if ((this._viewToModelMapping.delete(t), this._elementToMarkerNames.has(t)))
              for (const e of this._elementToMarkerNames.get(t)) this._unboundMarkerNames.add(e);
            this._modelToViewMapping.get(e) == t && this._modelToViewMapping.delete(e);
          }
          unbindModelElement(t) {
            const e = this.toViewElement(t);
            this._modelToViewMapping.delete(t),
              this._viewToModelMapping.get(e) == t && this._viewToModelMapping.delete(e);
          }
          bindElementToMarker(t, e) {
            const n = this._markerNameToElements.get(e) || new Set();
            n.add(t);
            const o = this._elementToMarkerNames.get(t) || new Set();
            o.add(e), this._markerNameToElements.set(e, n), this._elementToMarkerNames.set(t, o);
          }
          unbindElementFromMarkerName(t, e) {
            const n = this._markerNameToElements.get(e);
            n && (n.delete(t), 0 == n.size && this._markerNameToElements.delete(e));
            const o = this._elementToMarkerNames.get(t);
            o && (o.delete(e), 0 == o.size && this._elementToMarkerNames.delete(t));
          }
          flushUnboundMarkerNames() {
            const t = Array.from(this._unboundMarkerNames);
            return this._unboundMarkerNames.clear(), t;
          }
          clearBindings() {
            (this._modelToViewMapping = new WeakMap()),
              (this._viewToModelMapping = new WeakMap()),
              (this._markerNameToElements = new Map()),
              (this._elementToMarkerNames = new Map()),
              (this._unboundMarkerNames = new Set());
          }
          toModelElement(t) {
            return this._viewToModelMapping.get(t);
          }
          toViewElement(t) {
            return this._modelToViewMapping.get(t);
          }
          toModelRange(t) {
            return new ba(this.toModelPosition(t.start), this.toModelPosition(t.end));
          }
          toViewRange(t) {
            return new bi(this.toViewPosition(t.start), this.toViewPosition(t.end));
          }
          toModelPosition(t) {
            const e = { viewPosition: t, mapper: this };
            return this.fire('viewToModelPosition', e), e.modelPosition;
          }
          toViewPosition(t, e = { isPhantom: !1 }) {
            const n = { modelPosition: t, mapper: this, isPhantom: e.isPhantom };
            return this.fire('modelToViewPosition', n), n.viewPosition;
          }
          markerNameToElements(t) {
            const e = this._markerNameToElements.get(t);
            if (!e) return null;
            const n = new Set();
            for (const t of e)
              if (t.is('attributeElement')) for (const e of t.getElementsWithSameId()) n.add(e);
              else n.add(t);
            return n;
          }
          registerViewToModelLength(t, e) {
            this._viewToModelLengthCallbacks.set(t, e);
          }
          findMappedViewAncestor(t) {
            let e = t.parent;
            for (; !this._viewToModelMapping.has(e); ) e = e.parent;
            return e;
          }
          _toModelOffset(t, e, n) {
            if (n != t) {
              return this._toModelOffset(t.parent, t.index, n) + this._toModelOffset(t, e, t);
            }
            if (t.is('$text')) return e;
            let o = 0;
            for (let n = 0; n < e; n++) o += this.getModelLength(t.getChild(n));
            return o;
          }
          getModelLength(t) {
            if (this._viewToModelLengthCallbacks.get(t.name)) {
              return this._viewToModelLengthCallbacks.get(t.name)(t);
            }
            if (this._viewToModelMapping.has(t)) return 1;
            if (t.is('$text')) return t.data.length;
            if (t.is('uiElement')) return 0;
            {
              let e = 0;
              for (const n of t.getChildren()) e += this.getModelLength(n);
              return e;
            }
          }
          findPositionIn(t, e) {
            let n,
              o = 0,
              i = 0,
              r = 0;
            if (t.is('$text')) return new ki(t, e);
            for (; i < e; ) (n = t.getChild(r)), (o = this.getModelLength(n)), (i += o), r++;
            return i == e ? this._moveViewPositionToTextNode(new ki(t, r)) : this.findPositionIn(n, e - (i - o));
          }
          _moveViewPositionToTextNode(t) {
            const e = t.nodeBefore,
              n = t.nodeAfter;
            return e instanceof _o ? new ki(e, e.data.length) : n instanceof _o ? new ki(n, 0) : t;
          }
        }
        Yt(wa, h);
        class Aa {
          constructor() {
            (this._consumable = new Map()), (this._textProxyRegistry = new Map());
          }
          add(t, e) {
            (e = _a(e)),
              t instanceof la && (t = this._getSymbolForTextProxy(t)),
              this._consumable.has(t) || this._consumable.set(t, new Map()),
              this._consumable.get(t).set(e, !0);
          }
          consume(t, e) {
            return (
              (e = _a(e)),
              t instanceof la && (t = this._getSymbolForTextProxy(t)),
              !!this.test(t, e) && (this._consumable.get(t).set(e, !1), !0)
            );
          }
          test(t, e) {
            (e = _a(e)), t instanceof la && (t = this._getSymbolForTextProxy(t));
            const n = this._consumable.get(t);
            if (void 0 === n) return null;
            const o = n.get(e);
            return void 0 === o ? null : o;
          }
          revert(t, e) {
            (e = _a(e)), t instanceof la && (t = this._getSymbolForTextProxy(t));
            const n = this.test(t, e);
            return !1 === n ? (this._consumable.get(t).set(e, !0), !0) : !0 !== n && null;
          }
          _getSymbolForTextProxy(t) {
            let e = null;
            const n = this._textProxyRegistry.get(t.startOffset);
            if (n) {
              const o = n.get(t.endOffset);
              o && (e = o.get(t.parent));
            }
            return e || (e = this._addSymbolForTextProxy(t.startOffset, t.endOffset, t.parent)), e;
          }
          _addSymbolForTextProxy(t, e, n) {
            const o = Symbol('textProxySymbol');
            let i, r;
            return (
              (i = this._textProxyRegistry.get(t)),
              i || ((i = new Map()), this._textProxyRegistry.set(t, i)),
              (r = i.get(e)),
              r || ((r = new Map()), i.set(e, r)),
              r.set(n, o),
              o
            );
          }
        }
        function _a(t) {
          const e = t.split(':');
          return e.length > 1 ? e[0] + ':' + e[1] : e[0];
        }
        class Ca {
          constructor(t) {
            (this.conversionApi = Object.assign({ dispatcher: this }, t)),
              (this._reconversionEventsMapping = new Map());
          }
          convertChanges(t, e, n) {
            for (const e of t.getMarkersToRemove()) this.convertMarkerRemove(e.name, e.range, n);
            const o = this._mapChangesWithAutomaticReconversion(t);
            for (const t of o)
              'insert' === t.type
                ? this.convertInsert(ba._createFromPositionAndShift(t.position, t.length), n)
                : 'remove' === t.type
                ? this.convertRemove(t.position, t.length, t.name, n)
                : 'reconvert' === t.type
                ? this.reconvertElement(t.element, n)
                : this.convertAttribute(t.range, t.attributeKey, t.attributeOldValue, t.attributeNewValue, n);
            for (const t of this.conversionApi.mapper.flushUnboundMarkerNames()) {
              const o = e.get(t).getRange();
              this.convertMarkerRemove(t, o, n), this.convertMarkerAdd(t, o, n);
            }
            for (const e of t.getMarkersToAdd()) this.convertMarkerAdd(e.name, e.range, n);
          }
          convertInsert(t, e) {
            (this.conversionApi.writer = e), (this.conversionApi.consumable = this._createInsertConsumable(t));
            for (const e of Array.from(t).map(ya)) this._convertInsertWithAttributes(e);
            this._clearConversionApi();
          }
          convertRemove(t, e, n, o) {
            (this.conversionApi.writer = o),
              this.fire('remove:' + n, { position: t, length: e }, this.conversionApi),
              this._clearConversionApi();
          }
          convertAttribute(t, e, n, o, i) {
            (this.conversionApi.writer = i),
              (this.conversionApi.consumable = this._createConsumableForRange(t, `attribute:${e}`));
            for (const i of t) {
              const t = {
                item: i.item,
                range: ba._createFromPositionAndShift(i.previousPosition, i.length),
                attributeKey: e,
                attributeOldValue: n,
                attributeNewValue: o,
              };
              this._testAndFire(`attribute:${e}`, t);
            }
            this._clearConversionApi();
          }
          reconvertElement(t, e) {
            const n = ba._createOn(t);
            (this.conversionApi.writer = e), (this.conversionApi.consumable = this._createInsertConsumable(n));
            const o = this.conversionApi.mapper,
              i = o.toViewElement(t);
            e.remove(i), this._convertInsertWithAttributes({ item: t, range: n });
            const r = o.toViewElement(t);
            for (const n of ba._createIn(t)) {
              const { item: t } = n,
                i = xa(t, o);
              i
                ? i.root !== r.root && e.move(e.createRangeOn(i), o.toViewPosition(ma._createBefore(t)))
                : this._convertInsertWithAttributes(ya(n));
            }
            o.unbindViewElement(i), this._clearConversionApi();
          }
          convertSelection(t, e, n) {
            const o = Array.from(e.getMarkersAtPosition(t.getFirstPosition()));
            if (
              ((this.conversionApi.writer = n),
              (this.conversionApi.consumable = this._createSelectionConsumable(t, o)),
              this.fire('selection', { selection: t }, this.conversionApi),
              t.isCollapsed)
            ) {
              for (const e of o) {
                const n = e.getRange();
                if (!va(t.getFirstPosition(), e, this.conversionApi.mapper)) continue;
                const o = { item: t, markerName: e.name, markerRange: n };
                this.conversionApi.consumable.test(t, 'addMarker:' + e.name) &&
                  this.fire('addMarker:' + e.name, o, this.conversionApi);
              }
              for (const e of t.getAttributeKeys()) {
                const n = {
                  item: t,
                  range: t.getFirstRange(),
                  attributeKey: e,
                  attributeOldValue: null,
                  attributeNewValue: t.getAttribute(e),
                };
                this.conversionApi.consumable.test(t, 'attribute:' + n.attributeKey) &&
                  this.fire('attribute:' + n.attributeKey + ':$text', n, this.conversionApi);
              }
              this._clearConversionApi();
            }
          }
          convertMarkerAdd(t, e, n) {
            if ('$graveyard' == e.root.rootName) return;
            this.conversionApi.writer = n;
            const o = 'addMarker:' + t,
              i = new Aa();
            if (
              (i.add(e, o),
              (this.conversionApi.consumable = i),
              this.fire(o, { markerName: t, markerRange: e }, this.conversionApi),
              i.test(e, o))
            ) {
              this.conversionApi.consumable = this._createConsumableForRange(e, o);
              for (const n of e.getItems()) {
                if (!this.conversionApi.consumable.test(n, o)) continue;
                const i = { item: n, range: ba._createOn(n), markerName: t, markerRange: e };
                this.fire(o, i, this.conversionApi);
              }
              this._clearConversionApi();
            }
          }
          convertMarkerRemove(t, e, n) {
            '$graveyard' != e.root.rootName &&
              ((this.conversionApi.writer = n),
              this.fire('removeMarker:' + t, { markerName: t, markerRange: e }, this.conversionApi),
              this._clearConversionApi());
          }
          _mapReconversionTriggerEvent(t, e) {
            this._reconversionEventsMapping.set(e, t);
          }
          _createInsertConsumable(t) {
            const e = new Aa();
            for (const n of t) {
              const t = n.item;
              e.add(t, 'insert');
              for (const n of t.getAttributeKeys()) e.add(t, 'attribute:' + n);
            }
            return e;
          }
          _createConsumableForRange(t, e) {
            const n = new Aa();
            for (const o of t.getItems()) n.add(o, e);
            return n;
          }
          _createSelectionConsumable(t, e) {
            const n = new Aa();
            n.add(t, 'selection');
            for (const o of e) n.add(t, 'addMarker:' + o.name);
            for (const e of t.getAttributeKeys()) n.add(t, 'attribute:' + e);
            return n;
          }
          _testAndFire(t, e) {
            this.conversionApi.consumable.test(e.item, t) &&
              this.fire(
                (function (t, e) {
                  const n = e.item.name || '$text';
                  return `${t}:${n}`;
                })(t, e),
                e,
                this.conversionApi,
              );
          }
          _clearConversionApi() {
            delete this.conversionApi.writer, delete this.conversionApi.consumable;
          }
          _convertInsertWithAttributes(t) {
            this._testAndFire('insert', t);
            for (const e of t.item.getAttributeKeys())
              (t.attributeKey = e),
                (t.attributeOldValue = null),
                (t.attributeNewValue = t.item.getAttribute(e)),
                this._testAndFire(`attribute:${e}`, t);
          }
          _mapChangesWithAutomaticReconversion(t) {
            const e = new Set(),
              n = [];
            for (const o of t.getChanges()) {
              const t = o.position || o.range.start,
                i = t.parent;
              if (ga(t, i)) {
                n.push(o);
                continue;
              }
              const r = 'attribute' === o.type ? fa(t, i, null) : i;
              if (r.is('$text')) {
                n.push(o);
                continue;
              }
              let s;
              if (
                ((s = 'attribute' === o.type ? `attribute:${o.attributeKey}:${r.name}` : `${o.type}:${o.name}`),
                this._isReconvertTriggerEvent(s, r.name))
              ) {
                if (e.has(r)) continue;
                e.add(r), n.push({ type: 'reconvert', element: r });
              } else n.push(o);
            }
            return n;
          }
          _isReconvertTriggerEvent(t, e) {
            return this._reconversionEventsMapping.get(t) === e;
          }
        }
        function va(t, e, n) {
          const o = e.getRange(),
            i = Array.from(t.getAncestors());
          i.shift(), i.reverse();
          return !i.some(t => {
            if (o.containsItem(t)) {
              return !!n.toViewElement(t).getCustomProperty('addHighlight');
            }
          });
        }
        function ya(t) {
          return { item: t.item, range: ba._createFromPositionAndShift(t.previousPosition, t.length) };
        }
        function xa(t, e) {
          if (t.is('textProxy')) {
            const n = e.toViewPosition(ma._createBefore(t)).parent;
            return n.is('$text') ? n : null;
          }
          return e.toViewElement(t);
        }
        Yt(Ca, h);
        class Ea {
          constructor(t, e, n) {
            (this._lastRangeBackward = !1), (this._ranges = []), (this._attrs = new Map()), t && this.setTo(t, e, n);
          }
          get anchor() {
            if (this._ranges.length > 0) {
              const t = this._ranges[this._ranges.length - 1];
              return this._lastRangeBackward ? t.end : t.start;
            }
            return null;
          }
          get focus() {
            if (this._ranges.length > 0) {
              const t = this._ranges[this._ranges.length - 1];
              return this._lastRangeBackward ? t.start : t.end;
            }
            return null;
          }
          get isCollapsed() {
            return 1 === this._ranges.length && this._ranges[0].isCollapsed;
          }
          get rangeCount() {
            return this._ranges.length;
          }
          get isBackward() {
            return !this.isCollapsed && this._lastRangeBackward;
          }
          isEqual(t) {
            if (this.rangeCount != t.rangeCount) return !1;
            if (0 === this.rangeCount) return !0;
            if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) return !1;
            for (const e of this._ranges) {
              let n = !1;
              for (const o of t._ranges)
                if (e.isEqual(o)) {
                  n = !0;
                  break;
                }
              if (!n) return !1;
            }
            return !0;
          }
          *getRanges() {
            for (const t of this._ranges) yield new ba(t.start, t.end);
          }
          getFirstRange() {
            let t = null;
            for (const e of this._ranges) (t && !e.start.isBefore(t.start)) || (t = e);
            return t ? new ba(t.start, t.end) : null;
          }
          getLastRange() {
            let t = null;
            for (const e of this._ranges) (t && !e.end.isAfter(t.end)) || (t = e);
            return t ? new ba(t.start, t.end) : null;
          }
          getFirstPosition() {
            const t = this.getFirstRange();
            return t ? t.start.clone() : null;
          }
          getLastPosition() {
            const t = this.getLastRange();
            return t ? t.end.clone() : null;
          }
          setTo(t, e, n) {
            if (null === t) this._setRanges([]);
            else if (t instanceof Ea) this._setRanges(t.getRanges(), t.isBackward);
            else if (t && 'function' == typeof t.getRanges) this._setRanges(t.getRanges(), t.isBackward);
            else if (t instanceof ba) this._setRanges([t], !!e && !!e.backward);
            else if (t instanceof ma) this._setRanges([new ba(t)]);
            else if (t instanceof aa) {
              const o = !!n && !!n.backward;
              let i;
              if ('in' == e) i = ba._createIn(t);
              else if ('on' == e) i = ba._createOn(t);
              else {
                if (void 0 === e) throw new c.a('model-selection-setto-required-second-parameter', [this, t]);
                i = new ba(ma._createAt(t, e));
              }
              this._setRanges([i], o);
            } else {
              if (!ao(t)) throw new c.a('model-selection-setto-not-selectable', [this, t]);
              this._setRanges(t, e && !!e.backward);
            }
          }
          _setRanges(t, e = !1) {
            const n = (t = Array.from(t)).some(e => {
              if (!(e instanceof ba)) throw new c.a('model-selection-set-ranges-not-range', [this, t]);
              return this._ranges.every(t => !t.isEqual(e));
            });
            if (t.length !== this._ranges.length || n) {
              this._removeAllRanges();
              for (const e of t) this._pushRange(e);
              (this._lastRangeBackward = !!e), this.fire('change:range', { directChange: !0 });
            }
          }
          setFocus(t, e) {
            if (null === this.anchor) throw new c.a('model-selection-setfocus-no-ranges', [this, t]);
            const n = ma._createAt(t, e);
            if ('same' == n.compareWith(this.focus)) return;
            const o = this.anchor;
            this._ranges.length && this._popRange(),
              'before' == n.compareWith(o)
                ? (this._pushRange(new ba(n, o)), (this._lastRangeBackward = !0))
                : (this._pushRange(new ba(o, n)), (this._lastRangeBackward = !1)),
              this.fire('change:range', { directChange: !0 });
          }
          getAttribute(t) {
            return this._attrs.get(t);
          }
          getAttributes() {
            return this._attrs.entries();
          }
          getAttributeKeys() {
            return this._attrs.keys();
          }
          hasAttribute(t) {
            return this._attrs.has(t);
          }
          removeAttribute(t) {
            this.hasAttribute(t) &&
              (this._attrs.delete(t), this.fire('change:attribute', { attributeKeys: [t], directChange: !0 }));
          }
          setAttribute(t, e) {
            this.getAttribute(t) !== e &&
              (this._attrs.set(t, e), this.fire('change:attribute', { attributeKeys: [t], directChange: !0 }));
          }
          getSelectedElement() {
            return 1 !== this.rangeCount ? null : this.getFirstRange().getContainedElement();
          }
          is(t) {
            return 'selection' === t || 'model:selection' === t;
          }
          *getSelectedBlocks() {
            const t = new WeakSet();
            for (const e of this.getRanges()) {
              const n = Ba(e.start, t);
              n && Ta(n, e) && (yield n);
              for (const n of e.getWalker()) {
                const o = n.item;
                'elementEnd' == n.type && Sa(o, t, e) && (yield o);
              }
              const o = Ba(e.end, t);
              o && !e.end.isTouching(ma._createAt(o, 0)) && Ta(o, e) && (yield o);
            }
          }
          containsEntireContent(t = this.anchor.root) {
            const e = ma._createAt(t, 0),
              n = ma._createAt(t, 'end');
            return e.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition());
          }
          _pushRange(t) {
            this._checkRange(t), this._ranges.push(new ba(t.start, t.end));
          }
          _checkRange(t) {
            for (let e = 0; e < this._ranges.length; e++)
              if (t.isIntersecting(this._ranges[e]))
                throw new c.a('model-selection-range-intersects', [this, t], {
                  addedRange: t,
                  intersectingRange: this._ranges[e],
                });
          }
          _removeAllRanges() {
            for (; this._ranges.length > 0; ) this._popRange();
          }
          _popRange() {
            this._ranges.pop();
          }
        }
        function Da(t, e) {
          return !e.has(t) && (e.add(t), t.root.document.model.schema.isBlock(t) && t.parent);
        }
        function Sa(t, e, n) {
          return Da(t, e) && Ta(t, n);
        }
        function Ba(t, e) {
          const n = t.parent.root.document.model.schema,
            o = t.parent.getAncestors({ parentFirst: !0, includeSelf: !0 });
          let i = !1;
          const r = o.find(t => !i && ((i = n.isLimit(t)), !i && Da(t, e)));
          return o.forEach(t => e.add(t)), r;
        }
        function Ta(t, e) {
          const n = (function (t) {
            const e = t.root.document.model.schema;
            let n = t.parent;
            for (; n; ) {
              if (e.isBlock(n)) return n;
              n = n.parent;
            }
          })(t);
          if (!n) return !0;
          return !e.containsRange(ba._createOn(n), !0);
        }
        Yt(Ea, h);
        class Pa extends ba {
          constructor(t, e) {
            super(t, e), Ia.call(this);
          }
          detach() {
            this.stopListening();
          }
          is(t) {
            return 'liveRange' === t || 'model:liveRange' === t || 'range' == t || 'model:range' === t;
          }
          toRange() {
            return new ba(this.start, this.end);
          }
          static fromRange(t) {
            return new Pa(t.start, t.end);
          }
        }
        function Ia() {
          this.listenTo(
            this.root.document.model,
            'applyOperation',
            (t, e) => {
              const n = e[0];
              n.isDocumentOperation && za.call(this, n);
            },
            { priority: 'low' },
          );
        }
        function za(t) {
          const e = this.getTransformedByOperation(t),
            n = ba._createFromRanges(e),
            o = !n.isEqual(this),
            i = (function (t, e) {
              switch (e.type) {
                case 'insert':
                  return t.containsPosition(e.position);
                case 'move':
                case 'remove':
                case 'reinsert':
                case 'merge':
                  return (
                    t.containsPosition(e.sourcePosition) ||
                    t.start.isEqual(e.sourcePosition) ||
                    t.containsPosition(e.targetPosition)
                  );
                case 'split':
                  return t.containsPosition(e.splitPosition) || t.containsPosition(e.insertionPosition);
              }
              return !1;
            })(this, t);
          let r = null;
          if (o) {
            '$graveyard' == n.root.rootName && (r = 'remove' == t.type ? t.sourcePosition : t.deletionPosition);
            const e = this.toRange();
            (this.start = n.start), (this.end = n.end), this.fire('change:range', e, { deletionPosition: r });
          } else i && this.fire('change:content', this.toRange(), { deletionPosition: r });
        }
        Yt(Pa, h);
        const Fa = 'selection:';
        class Ra {
          constructor(t) {
            (this._selection = new Oa(t)),
              this._selection.delegate('change:range').to(this),
              this._selection.delegate('change:attribute').to(this),
              this._selection.delegate('change:marker').to(this);
          }
          get isCollapsed() {
            return this._selection.isCollapsed;
          }
          get anchor() {
            return this._selection.anchor;
          }
          get focus() {
            return this._selection.focus;
          }
          get rangeCount() {
            return this._selection.rangeCount;
          }
          get hasOwnRange() {
            return this._selection.hasOwnRange;
          }
          get isBackward() {
            return this._selection.isBackward;
          }
          get isGravityOverridden() {
            return this._selection.isGravityOverridden;
          }
          get markers() {
            return this._selection.markers;
          }
          get _ranges() {
            return this._selection._ranges;
          }
          getRanges() {
            return this._selection.getRanges();
          }
          getFirstPosition() {
            return this._selection.getFirstPosition();
          }
          getLastPosition() {
            return this._selection.getLastPosition();
          }
          getFirstRange() {
            return this._selection.getFirstRange();
          }
          getLastRange() {
            return this._selection.getLastRange();
          }
          getSelectedBlocks() {
            return this._selection.getSelectedBlocks();
          }
          getSelectedElement() {
            return this._selection.getSelectedElement();
          }
          containsEntireContent(t) {
            return this._selection.containsEntireContent(t);
          }
          destroy() {
            this._selection.destroy();
          }
          getAttributeKeys() {
            return this._selection.getAttributeKeys();
          }
          getAttributes() {
            return this._selection.getAttributes();
          }
          getAttribute(t) {
            return this._selection.getAttribute(t);
          }
          hasAttribute(t) {
            return this._selection.hasAttribute(t);
          }
          refresh() {
            this._selection._updateMarkers(), this._selection._updateAttributes(!1);
          }
          observeMarkers(t) {
            this._selection.observeMarkers(t);
          }
          is(t) {
            return (
              'selection' === t || 'model:selection' == t || 'documentSelection' == t || 'model:documentSelection' == t
            );
          }
          _setFocus(t, e) {
            this._selection.setFocus(t, e);
          }
          _setTo(t, e, n) {
            this._selection.setTo(t, e, n);
          }
          _setAttribute(t, e) {
            this._selection.setAttribute(t, e);
          }
          _removeAttribute(t) {
            this._selection.removeAttribute(t);
          }
          _getStoredAttributes() {
            return this._selection._getStoredAttributes();
          }
          _overrideGravity() {
            return this._selection.overrideGravity();
          }
          _restoreGravity(t) {
            this._selection.restoreGravity(t);
          }
          static _getStoreAttributeKey(t) {
            return Fa + t;
          }
          static _isStoreAttributeKey(t) {
            return t.startsWith(Fa);
          }
        }
        Yt(Ra, h);
        class Oa extends Ea {
          constructor(t) {
            super(),
              (this.markers = new co({ idProperty: 'name' })),
              (this._model = t.model),
              (this._document = t),
              (this._attributePriority = new Map()),
              (this._selectionRestorePosition = null),
              (this._hasChangedRange = !1),
              (this._overriddenGravityRegister = new Set()),
              (this._observedMarkers = new Set()),
              this.listenTo(
                this._model,
                'applyOperation',
                (t, e) => {
                  const n = e[0];
                  n.isDocumentOperation &&
                    'marker' != n.type &&
                    'rename' != n.type &&
                    'noop' != n.type &&
                    (0 == this._ranges.length &&
                      this._selectionRestorePosition &&
                      this._fixGraveyardSelection(this._selectionRestorePosition),
                    (this._selectionRestorePosition = null),
                    this._hasChangedRange &&
                      ((this._hasChangedRange = !1), this.fire('change:range', { directChange: !1 })));
                },
                { priority: 'lowest' },
              ),
              this.on('change:range', () => {
                for (const t of this.getRanges())
                  if (!this._document._validateSelectionRange(t))
                    throw new c.a('document-selection-wrong-position', this, { range: t });
              }),
              this.listenTo(this._model.markers, 'update', (t, e, n, o) => {
                this._updateMarker(e, o);
              }),
              this.listenTo(this._document, 'change', (t, e) => {
                !(function (t, e) {
                  const n = t.document.differ;
                  for (const o of n.getChanges()) {
                    if ('insert' != o.type) continue;
                    const n = o.position.parent;
                    o.length === n.maxOffset &&
                      t.enqueueChange(e, t => {
                        const e = Array.from(n.getAttributeKeys()).filter(t => t.startsWith(Fa));
                        for (const o of e) t.removeAttribute(o, n);
                      });
                  }
                })(this._model, e);
              });
          }
          get isCollapsed() {
            return 0 === this._ranges.length ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
          }
          get anchor() {
            return super.anchor || this._document._getDefaultRange().start;
          }
          get focus() {
            return super.focus || this._document._getDefaultRange().end;
          }
          get rangeCount() {
            return this._ranges.length ? this._ranges.length : 1;
          }
          get hasOwnRange() {
            return this._ranges.length > 0;
          }
          get isGravityOverridden() {
            return !!this._overriddenGravityRegister.size;
          }
          destroy() {
            for (let t = 0; t < this._ranges.length; t++) this._ranges[t].detach();
            this.stopListening();
          }
          *getRanges() {
            this._ranges.length ? yield* super.getRanges() : yield this._document._getDefaultRange();
          }
          getFirstRange() {
            return super.getFirstRange() || this._document._getDefaultRange();
          }
          getLastRange() {
            return super.getLastRange() || this._document._getDefaultRange();
          }
          setTo(t, e, n) {
            super.setTo(t, e, n), this._updateAttributes(!0), this._updateMarkers();
          }
          setFocus(t, e) {
            super.setFocus(t, e), this._updateAttributes(!0), this._updateMarkers();
          }
          setAttribute(t, e) {
            if (this._setAttribute(t, e)) {
              const e = [t];
              this.fire('change:attribute', { attributeKeys: e, directChange: !0 });
            }
          }
          removeAttribute(t) {
            if (this._removeAttribute(t)) {
              const e = [t];
              this.fire('change:attribute', { attributeKeys: e, directChange: !0 });
            }
          }
          overrideGravity() {
            const t = s();
            return (
              this._overriddenGravityRegister.add(t),
              1 === this._overriddenGravityRegister.size && this._updateAttributes(!0),
              t
            );
          }
          restoreGravity(t) {
            if (!this._overriddenGravityRegister.has(t))
              throw new c.a('document-selection-gravity-wrong-restore', this, { uid: t });
            this._overriddenGravityRegister.delete(t), this.isGravityOverridden || this._updateAttributes(!0);
          }
          observeMarkers(t) {
            this._observedMarkers.add(t), this._updateMarkers();
          }
          _popRange() {
            this._ranges.pop().detach();
          }
          _pushRange(t) {
            const e = this._prepareRange(t);
            e && this._ranges.push(e);
          }
          _prepareRange(t) {
            if ((this._checkRange(t), t.root == this._document.graveyard)) return;
            const e = Pa.fromRange(t);
            return (
              e.on('change:range', (t, n, o) => {
                if (((this._hasChangedRange = !0), e.root == this._document.graveyard)) {
                  this._selectionRestorePosition = o.deletionPosition;
                  const t = this._ranges.indexOf(e);
                  this._ranges.splice(t, 1), e.detach();
                }
              }),
              e
            );
          }
          _updateMarkers() {
            if (!this._observedMarkers.size) return;
            const t = [];
            let e = !1;
            for (const e of this._model.markers) {
              const n = e.name.split(':', 1)[0];
              if (!this._observedMarkers.has(n)) continue;
              const o = e.getRange();
              for (const n of this.getRanges()) o.containsRange(n, !n.isCollapsed) && t.push(e);
            }
            const n = Array.from(this.markers);
            for (const n of t) this.markers.has(n) || (this.markers.add(n), (e = !0));
            for (const n of Array.from(this.markers)) t.includes(n) || (this.markers.remove(n), (e = !0));
            e && this.fire('change:marker', { oldMarkers: n, directChange: !1 });
          }
          _updateMarker(t, e) {
            const n = t.name.split(':', 1)[0];
            if (!this._observedMarkers.has(n)) return;
            let o = !1;
            const i = Array.from(this.markers),
              r = this.markers.has(t);
            if (e) {
              let n = !1;
              for (const t of this.getRanges())
                if (e.containsRange(t, !t.isCollapsed)) {
                  n = !0;
                  break;
                }
              n && !r ? (this.markers.add(t), (o = !0)) : !n && r && (this.markers.remove(t), (o = !0));
            } else r && (this.markers.remove(t), (o = !0));
            o && this.fire('change:marker', { oldMarkers: i, directChange: !1 });
          }
          _updateAttributes(t) {
            const e = vo(this._getSurroundingAttributes()),
              n = vo(this.getAttributes());
            if (t) (this._attributePriority = new Map()), (this._attrs = new Map());
            else
              for (const [t, e] of this._attributePriority)
                'low' == e && (this._attrs.delete(t), this._attributePriority.delete(t));
            this._setAttributesTo(e);
            const o = [];
            for (const [t, e] of this.getAttributes()) (n.has(t) && n.get(t) === e) || o.push(t);
            for (const [t] of n) this.hasAttribute(t) || o.push(t);
            o.length > 0 && this.fire('change:attribute', { attributeKeys: o, directChange: !1 });
          }
          _setAttribute(t, e, n = !0) {
            const o = n ? 'normal' : 'low';
            if ('low' == o && 'normal' == this._attributePriority.get(t)) return !1;
            return super.getAttribute(t) !== e && (this._attrs.set(t, e), this._attributePriority.set(t, o), !0);
          }
          _removeAttribute(t, e = !0) {
            const n = e ? 'normal' : 'low';
            return (
              ('low' != n || 'normal' != this._attributePriority.get(t)) &&
              (this._attributePriority.set(t, n), !!super.hasAttribute(t) && (this._attrs.delete(t), !0))
            );
          }
          _setAttributesTo(t) {
            const e = new Set();
            for (const [e, n] of this.getAttributes()) t.get(e) !== n && this._removeAttribute(e, !1);
            for (const [n, o] of t) {
              this._setAttribute(n, o, !1) && e.add(n);
            }
            return e;
          }
          *_getStoredAttributes() {
            const t = this.getFirstPosition().parent;
            if (this.isCollapsed && t.isEmpty)
              for (const e of t.getAttributeKeys())
                if (e.startsWith(Fa)) {
                  const n = e.substr(Fa.length);
                  yield [n, t.getAttribute(e)];
                }
          }
          _getSurroundingAttributes() {
            const t = this.getFirstPosition(),
              e = this._model.schema;
            let n = null;
            if (this.isCollapsed) {
              const o = t.textNode ? t.textNode : t.nodeBefore,
                i = t.textNode ? t.textNode : t.nodeAfter;
              if ((this.isGravityOverridden || (n = Ma(o)), n || (n = Ma(i)), !this.isGravityOverridden && !n)) {
                let t = o;
                for (; t && !e.isInline(t) && !n; ) (t = t.previousSibling), (n = Ma(t));
              }
              if (!n) {
                let t = i;
                for (; t && !e.isInline(t) && !n; ) (t = t.nextSibling), (n = Ma(t));
              }
              n || (n = this._getStoredAttributes());
            } else {
              const t = this.getFirstRange();
              for (const o of t) {
                if (o.item.is('element') && e.isObject(o.item)) break;
                if ('text' == o.type) {
                  n = o.item.getAttributes();
                  break;
                }
              }
            }
            return n;
          }
          _fixGraveyardSelection(t) {
            const e = this._model.schema.getNearestSelectionRange(t);
            e && this._pushRange(e);
          }
        }
        function Ma(t) {
          return t instanceof la || t instanceof ca ? t.getAttributes() : null;
        }
        class Na {
          constructor(t) {
            this._dispatchers = t;
          }
          add(t) {
            for (const e of this._dispatchers) t(e);
            return this;
          }
        }
        var Va = function (t) {
          return eo(t, 5);
        };
        class La extends Na {
          elementToElement(t) {
            return this.add(
              (function (t) {
                return (
                  ((t = Va(t)).view = Ha(t.view, 'container')),
                  e => {
                    var n;
                    if (
                      (e.on(
                        'insert:' + t.model,
                        ((n = t.view),
                        (t, e, o) => {
                          const i = n(e.item, o);
                          if (!i) return;
                          if (!o.consumable.consume(e.item, 'insert')) return;
                          const r = o.mapper.toViewPosition(e.range.start);
                          o.mapper.bindElements(e.item, i), o.writer.insert(r, i);
                        }),
                        { priority: t.converterPriority || 'normal' },
                      ),
                      t.triggerBy)
                    ) {
                      if (t.triggerBy.attributes)
                        for (const n of t.triggerBy.attributes)
                          e._mapReconversionTriggerEvent(t.model, `attribute:${n}:${t.model}`);
                      if (t.triggerBy.children)
                        for (const n of t.triggerBy.children)
                          e._mapReconversionTriggerEvent(t.model, `insert:${n}`),
                            e._mapReconversionTriggerEvent(t.model, `remove:${n}`);
                    }
                  }
                );
              })(t),
            );
          }
          attributeToElement(t) {
            return this.add(
              (function (t) {
                t = Va(t);
                let e = 'attribute:' + (t.model.key ? t.model.key : t.model);
                t.model.name && (e += ':' + t.model.name);
                if (t.model.values) for (const e of t.model.values) t.view[e] = Ha(t.view[e], 'attribute');
                else t.view = Ha(t.view, 'attribute');
                const n = ja(t);
                return o => {
                  o.on(
                    e,
                    (function (t) {
                      return (e, n, o) => {
                        const i = t(n.attributeOldValue, o),
                          r = t(n.attributeNewValue, o);
                        if (!i && !r) return;
                        if (!o.consumable.consume(n.item, e.name)) return;
                        const s = o.writer,
                          a = s.document.selection;
                        if (n.item instanceof Ea || n.item instanceof Ra) s.wrap(a.getFirstRange(), r);
                        else {
                          let t = o.mapper.toViewRange(n.range);
                          null !== n.attributeOldValue && i && (t = s.unwrap(t, i)),
                            null !== n.attributeNewValue && r && s.wrap(t, r);
                        }
                      };
                    })(n),
                    { priority: t.converterPriority || 'normal' },
                  );
                };
              })(t),
            );
          }
          attributeToAttribute(t) {
            return this.add(
              (function (t) {
                t = Va(t);
                let e = 'attribute:' + (t.model.key ? t.model.key : t.model);
                t.model.name && (e += ':' + t.model.name);
                if (t.model.values) for (const e of t.model.values) t.view[e] = $a(t.view[e]);
                else t.view = $a(t.view);
                const n = ja(t);
                return o => {
                  var i;
                  o.on(
                    e,
                    ((i = n),
                    (t, e, n) => {
                      const o = i(e.attributeOldValue, n),
                        r = i(e.attributeNewValue, n);
                      if (!o && !r) return;
                      if (!n.consumable.consume(e.item, t.name)) return;
                      const s = n.mapper.toViewElement(e.item),
                        a = n.writer;
                      if (!s) throw new c.a('conversion-attribute-to-attribute-on-text', [e, n]);
                      if (null !== e.attributeOldValue && o)
                        if ('class' == o.key) {
                          const t = ho(o.value);
                          for (const e of t) a.removeClass(e, s);
                        } else if ('style' == o.key) {
                          const t = Object.keys(o.value);
                          for (const e of t) a.removeStyle(e, s);
                        } else a.removeAttribute(o.key, s);
                      if (null !== e.attributeNewValue && r)
                        if ('class' == r.key) {
                          const t = ho(r.value);
                          for (const e of t) a.addClass(e, s);
                        } else if ('style' == r.key) {
                          const t = Object.keys(r.value);
                          for (const e of t) a.setStyle(e, r.value[e], s);
                        } else a.setAttribute(r.key, r.value, s);
                    }),
                    { priority: t.converterPriority || 'normal' },
                  );
                };
              })(t),
            );
          }
          markerToElement(t) {
            return this.add(
              (function (t) {
                return (
                  ((t = Va(t)).view = Ha(t.view, 'ui')),
                  e => {
                    var n;
                    e.on(
                      'addMarker:' + t.model,
                      ((n = t.view),
                      (t, e, o) => {
                        e.isOpening = !0;
                        const i = n(e, o);
                        e.isOpening = !1;
                        const r = n(e, o);
                        if (!i || !r) return;
                        const s = e.markerRange;
                        if (s.isCollapsed && !o.consumable.consume(s, t.name)) return;
                        for (const e of s) if (!o.consumable.consume(e.item, t.name)) return;
                        const a = o.mapper,
                          c = o.writer;
                        c.insert(a.toViewPosition(s.start), i),
                          o.mapper.bindElementToMarker(i, e.markerName),
                          s.isCollapsed ||
                            (c.insert(a.toViewPosition(s.end), r), o.mapper.bindElementToMarker(r, e.markerName)),
                          t.stop();
                      }),
                      { priority: t.converterPriority || 'normal' },
                    ),
                      e.on(
                        'removeMarker:' + t.model,
                        (t.view,
                        (t, e, n) => {
                          const o = n.mapper.markerNameToElements(e.markerName);
                          if (o) {
                            for (const t of o)
                              n.mapper.unbindElementFromMarkerName(t, e.markerName),
                                n.writer.clear(n.writer.createRangeOn(t), t);
                            n.writer.clearClonedElementsGroup(e.markerName), t.stop();
                          }
                        }),
                        { priority: t.converterPriority || 'normal' },
                      );
                  }
                );
              })(t),
            );
          }
          markerToHighlight(t) {
            return this.add(
              (function (t) {
                return e => {
                  var n;
                  e.on(
                    'addMarker:' + t.model,
                    ((n = t.view),
                    (t, e, o) => {
                      if (!e.item) return;
                      if (!(e.item instanceof Ea || e.item instanceof Ra || e.item.is('$textProxy'))) return;
                      const i = Ga(n, e, o);
                      if (!i) return;
                      if (!o.consumable.consume(e.item, t.name)) return;
                      const r = o.writer,
                        s = Ka(r, i),
                        a = r.document.selection;
                      if (e.item instanceof Ea || e.item instanceof Ra) r.wrap(a.getFirstRange(), s, a);
                      else {
                        const t = o.mapper.toViewRange(e.range),
                          n = r.wrap(t, s);
                        for (const t of n.getItems())
                          if (t.is('attributeElement') && t.isSimilar(s)) {
                            o.mapper.bindElementToMarker(t, e.markerName);
                            break;
                          }
                      }
                    }),
                    { priority: t.converterPriority || 'normal' },
                  ),
                    e.on(
                      'addMarker:' + t.model,
                      (function (t) {
                        return (e, n, o) => {
                          if (!n.item) return;
                          if (!(n.item instanceof ha)) return;
                          const i = Ga(t, n, o);
                          if (!i) return;
                          if (!o.consumable.test(n.item, e.name)) return;
                          const r = o.mapper.toViewElement(n.item);
                          if (r && r.getCustomProperty('addHighlight')) {
                            o.consumable.consume(n.item, e.name);
                            for (const t of ba._createIn(n.item)) o.consumable.consume(t.item, e.name);
                            r.getCustomProperty('addHighlight')(r, i, o.writer),
                              o.mapper.bindElementToMarker(r, n.markerName);
                          }
                        };
                      })(t.view),
                      { priority: t.converterPriority || 'normal' },
                    ),
                    e.on(
                      'removeMarker:' + t.model,
                      (function (t) {
                        return (e, n, o) => {
                          if (n.markerRange.isCollapsed) return;
                          const i = Ga(t, n, o);
                          if (!i) return;
                          const r = Ka(o.writer, i),
                            s = o.mapper.markerNameToElements(n.markerName);
                          if (s) {
                            for (const t of s)
                              o.mapper.unbindElementFromMarkerName(t, n.markerName),
                                t.is('attributeElement')
                                  ? o.writer.unwrap(o.writer.createRangeOn(t), r)
                                  : t.getCustomProperty('removeHighlight')(t, i.id, o.writer);
                            o.writer.clearClonedElementsGroup(n.markerName), e.stop();
                          }
                        };
                      })(t.view),
                      { priority: t.converterPriority || 'normal' },
                    );
                };
              })(t),
            );
          }
          markerToData(t) {
            return this.add(
              (function (t) {
                const e = (t = Va(t)).model;
                t.view || (t.view = n => ({ group: e, name: n.substr(t.model.length + 1) }));
                return n => {
                  var o;
                  n.on(
                    'addMarker:' + e,
                    ((o = t.view),
                    (t, e, n) => {
                      const i = o(e.markerName, n);
                      if (!i) return;
                      const r = e.markerRange;
                      n.consumable.consume(r, t.name) && (qa(r, !1, n, e, i), qa(r, !0, n, e, i), t.stop());
                    }),
                    { priority: t.converterPriority || 'normal' },
                  ),
                    n.on(
                      'removeMarker:' + e,
                      (function (t) {
                        return (e, n, o) => {
                          const i = t(n.markerName, o);
                          if (!i) return;
                          const r = o.mapper.markerNameToElements(n.markerName);
                          if (r) {
                            for (const t of r)
                              o.mapper.unbindElementFromMarkerName(t, n.markerName),
                                t.is('containerElement')
                                  ? (s(`data-${i.group}-start-before`, t),
                                    s(`data-${i.group}-start-after`, t),
                                    s(`data-${i.group}-end-before`, t),
                                    s(`data-${i.group}-end-after`, t))
                                  : o.writer.clear(o.writer.createRangeOn(t), t);
                            o.writer.clearClonedElementsGroup(n.markerName), e.stop();
                          }
                          function s(t, e) {
                            if (e.hasAttribute(t)) {
                              const n = new Set(e.getAttribute(t).split(','));
                              n.delete(i.name),
                                0 == n.size
                                  ? o.writer.removeAttribute(t, e)
                                  : o.writer.setAttribute(t, Array.from(n).join(','), e);
                            }
                          }
                        };
                      })(t.view),
                      { priority: t.converterPriority || 'normal' },
                    );
                };
              })(t),
            );
          }
        }
        function Ka(t, e) {
          const n = t.createAttributeElement('span', e.attributes);
          return (
            e.classes && n._addClass(e.classes),
            'number' == typeof e.priority && (n._priority = e.priority),
            (n._id = e.id),
            n
          );
        }
        function qa(t, e, n, o, i) {
          const r = e ? t.start : t.end,
            s = r.nodeAfter && r.nodeAfter.is('element') ? r.nodeAfter : null,
            a = r.nodeBefore && r.nodeBefore.is('element') ? r.nodeBefore : null;
          if (s || a) {
            let t, r;
            (e && s) || (!e && !a) ? ((t = s), (r = !0)) : ((t = a), (r = !1));
            const c = n.mapper.toViewElement(t);
            if (c)
              return void (function (t, e, n, o, i, r) {
                const s = `data-${r.group}-${e ? 'start' : 'end'}-${n ? 'before' : 'after'}`,
                  a = t.hasAttribute(s) ? t.getAttribute(s).split(',') : [];
                a.unshift(r.name),
                  o.writer.setAttribute(s, a.join(','), t),
                  o.mapper.bindElementToMarker(t, i.markerName);
              })(c, e, r, n, o, i);
          }
          !(function (t, e, n, o, i) {
            const r = `${i.group}-${e ? 'start' : 'end'}`,
              s = i.name ? { name: i.name } : null,
              a = n.writer.createUIElement(r, s);
            n.writer.insert(t, a), n.mapper.bindElementToMarker(a, o.markerName);
          })(n.mapper.toViewPosition(r), e, n, o, i);
        }
        function Ha(t, e) {
          return 'function' == typeof t
            ? t
            : (n, o) =>
                (function (t, e, n) {
                  'string' == typeof t && (t = { name: t });
                  let o;
                  const i = e.writer,
                    r = Object.assign({}, t.attributes);
                  if ('container' == n) o = i.createContainerElement(t.name, r);
                  else if ('attribute' == n) {
                    const e = { priority: t.priority || Pi.DEFAULT_PRIORITY };
                    o = i.createAttributeElement(t.name, r, e);
                  } else o = i.createUIElement(t.name, r);
                  if (t.styles) {
                    const e = Object.keys(t.styles);
                    for (const n of e) i.setStyle(n, t.styles[n], o);
                  }
                  if (t.classes) {
                    const e = t.classes;
                    if ('string' == typeof e) i.addClass(e, o);
                    else for (const t of e) i.addClass(t, o);
                  }
                  return o;
                })(t, o, e);
        }
        function ja(t) {
          return t.model.values
            ? (e, n) => {
                const o = t.view[e];
                return o ? o(e, n) : null;
              }
            : t.view;
        }
        function $a(t) {
          return 'string' == typeof t
            ? e => ({ key: t, value: e })
            : 'object' == typeof t
            ? t.value
              ? () => t
              : e => ({ key: t.key, value: e })
            : t;
        }
        function Ga(t, e, n) {
          const o = 'function' == typeof t ? t(e, n) : t;
          return o ? (o.priority || (o.priority = 10), o.id || (o.id = e.markerName), o) : null;
        }
        function Wa(t) {
          const { schema: e, document: n } = t.model;
          for (const o of n.getRootNames()) {
            const i = n.getRoot(o);
            if (i.isEmpty && !e.checkChild(i, '$text') && e.checkChild(i, 'paragraph'))
              return t.insertElement('paragraph', i), !0;
          }
          return !1;
        }
        function Ua(t, e, n) {
          const o = n.createContext(t);
          return !!n.checkChild(o, 'paragraph') && !!n.checkChild(o.push('paragraph'), e);
        }
        function Ja(t, e) {
          const n = e.createElement('paragraph');
          return e.insert(n, t), e.createPositionAt(n, 0);
        }
        class Ya extends Na {
          elementToElement(t) {
            return this.add(Qa(t));
          }
          elementToAttribute(t) {
            return this.add(
              (function (t) {
                tc((t = Va(t)));
                const e = ec(t, !1),
                  n = Xa(t.view),
                  o = n ? 'element:' + n : 'element';
                return n => {
                  n.on(o, e, { priority: t.converterPriority || 'low' });
                };
              })(t),
            );
          }
          attributeToAttribute(t) {
            return this.add(
              (function (t) {
                t = Va(t);
                let e = null;
                ('string' == typeof t.view || t.view.key) &&
                  (e = (function (t) {
                    'string' == typeof t.view && (t.view = { key: t.view });
                    const e = t.view.key;
                    let n;
                    if ('class' == e || 'style' == e) {
                      n = { ['class' == e ? 'classes' : 'styles']: t.view.value };
                    } else {
                      n = { attributes: { [e]: void 0 === t.view.value ? /[\s\S]*/ : t.view.value } };
                    }
                    t.view.name && (n.name = t.view.name);
                    return (t.view = n), e;
                  })(t));
                tc(t, e);
                const n = ec(t, !0);
                return e => {
                  e.on('element', n, { priority: t.converterPriority || 'low' });
                };
              })(t),
            );
          }
          elementToMarker(t) {
            return (
              Object(c.b)('upcast-helpers-element-to-marker-deprecated'),
              this.add(
                (function (t) {
                  return (
                    (function (t) {
                      const e = t.model;
                      t.model = (t, n) => {
                        const o = 'string' == typeof e ? e : e(t, n);
                        return n.writer.createElement('$marker', { 'data-name': o });
                      };
                    })((t = Va(t))),
                    Qa(t)
                  );
                })(t),
              )
            );
          }
          dataToMarker(t) {
            return this.add(
              (function (t) {
                (t = Va(t)).model || (t.model = e => (e ? t.view + ':' + e : t.view));
                const e = Za(nc(t, 'start')),
                  n = Za(nc(t, 'end'));
                return o => {
                  o.on('element:' + t.view + '-start', e, { priority: t.converterPriority || 'normal' }),
                    o.on('element:' + t.view + '-end', n, { priority: t.converterPriority || 'normal' });
                  const i = a.get('low'),
                    r = a.get('highest'),
                    s = a.get(t.converterPriority) / r;
                  o.on(
                    'element',
                    (function (t) {
                      return (e, n, o) => {
                        const i = `data-${t.view}`;
                        function r(e, i) {
                          for (const r of i) {
                            const i = t.model(r, o),
                              s = o.writer.createElement('$marker', { 'data-name': i });
                            o.writer.insert(s, e),
                              n.modelCursor.isEqual(e)
                                ? (n.modelCursor = n.modelCursor.getShiftedBy(1))
                                : (n.modelCursor = n.modelCursor._getTransformedByInsertion(e, 1)),
                              (n.modelRange = n.modelRange._getTransformedByInsertion(e, 1)[0]);
                          }
                        }
                        (o.consumable.test(n.viewItem, { attributes: i + '-end-after' }) ||
                          o.consumable.test(n.viewItem, { attributes: i + '-start-after' }) ||
                          o.consumable.test(n.viewItem, { attributes: i + '-end-before' }) ||
                          o.consumable.test(n.viewItem, { attributes: i + '-start-before' })) &&
                          (n.modelRange || Object.assign(n, o.convertChildren(n.viewItem, n.modelCursor)),
                          o.consumable.consume(n.viewItem, { attributes: i + '-end-after' }) &&
                            r(n.modelRange.end, n.viewItem.getAttribute(i + '-end-after').split(',')),
                          o.consumable.consume(n.viewItem, { attributes: i + '-start-after' }) &&
                            r(n.modelRange.end, n.viewItem.getAttribute(i + '-start-after').split(',')),
                          o.consumable.consume(n.viewItem, { attributes: i + '-end-before' }) &&
                            r(n.modelRange.start, n.viewItem.getAttribute(i + '-end-before').split(',')),
                          o.consumable.consume(n.viewItem, { attributes: i + '-start-before' }) &&
                            r(n.modelRange.start, n.viewItem.getAttribute(i + '-start-before').split(',')));
                      };
                    })(t),
                    { priority: i + s },
                  );
                };
              })(t),
            );
          }
        }
        function Qa(t) {
          const e = Za((t = Va(t))),
            n = Xa(t.view),
            o = n ? 'element:' + n : 'element';
          return n => {
            n.on(o, e, { priority: t.converterPriority || 'normal' });
          };
        }
        function Xa(t) {
          return 'string' == typeof t ? t : 'object' == typeof t && 'string' == typeof t.name ? t.name : null;
        }
        function Za(t) {
          const e = new yo(t.view);
          return (n, o, i) => {
            const r = e.match(o.viewItem);
            if (!r) return;
            const s = r.match;
            if (((s.name = !0), !i.consumable.test(o.viewItem, s))) return;
            const a = (function (t, e, n) {
              return t instanceof Function ? t(e, n) : n.writer.createElement(t);
            })(t.model, o.viewItem, i);
            a &&
              i.safeInsert(a, o.modelCursor) &&
              (i.consumable.consume(o.viewItem, s), i.convertChildren(o.viewItem, a), i.updateConversionResult(a, o));
          };
        }
        function tc(t, e = null) {
          const n = null === e || (t => t.getAttribute(e)),
            o = 'object' != typeof t.model ? t.model : t.model.key,
            i = 'object' != typeof t.model || void 0 === t.model.value ? n : t.model.value;
          t.model = { key: o, value: i };
        }
        function ec(t, e) {
          const n = new yo(t.view);
          return (o, i, r) => {
            const s = n.match(i.viewItem);
            if (!s) return;
            if (
              (!(function (t, e) {
                const n = 'function' == typeof t ? t(e) : t;
                if ('object' == typeof n && !Xa(n)) return !1;
                return !n.classes && !n.attributes && !n.styles;
              })(t.view, i.viewItem)
                ? delete s.match.name
                : (s.match.name = !0),
              !r.consumable.test(i.viewItem, s.match))
            )
              return;
            const a = t.model.key,
              c = 'function' == typeof t.model.value ? t.model.value(i.viewItem, r) : t.model.value;
            if (null === c) return;
            i.modelRange || Object.assign(i, r.convertChildren(i.viewItem, i.modelCursor));
            (function (t, e, n, o) {
              let i = !1;
              for (const r of Array.from(t.getItems({ shallow: n })))
                o.schema.checkAttribute(r, e.key) &&
                  ((i = !0), r.hasAttribute(e.key) || o.writer.setAttribute(e.key, e.value, r));
              return i;
            })(i.modelRange, { key: a, value: c }, e, r) && r.consumable.consume(i.viewItem, s.match);
          };
        }
        function nc(t, e) {
          const n = {};
          return (
            (n.view = t.view + '-' + e),
            (n.model = (e, n) => {
              const o = e.getAttribute('name'),
                i = t.model(o, n);
              return n.writer.createElement('$marker', { 'data-name': i });
            }),
            n
          );
        }
        class oc {
          constructor(t, e) {
            (this.model = t),
              (this.view = new sa(e)),
              (this.mapper = new wa()),
              (this.downcastDispatcher = new Ca({ mapper: this.mapper, schema: t.schema }));
            const n = this.model.document,
              o = n.selection,
              i = this.model.markers;
            this.listenTo(
              this.model,
              '_beforeChanges',
              () => {
                this.view._disableRendering(!0);
              },
              { priority: 'highest' },
            ),
              this.listenTo(
                this.model,
                '_afterChanges',
                () => {
                  this.view._disableRendering(!1);
                },
                { priority: 'lowest' },
              ),
              this.listenTo(
                n,
                'change',
                () => {
                  this.view.change(t => {
                    this.downcastDispatcher.convertChanges(n.differ, i, t),
                      this.downcastDispatcher.convertSelection(o, i, t);
                  });
                },
                { priority: 'low' },
              ),
              this.listenTo(
                this.view.document,
                'selectionChange',
                (function (t, e) {
                  return (n, o) => {
                    const i = o.newSelection,
                      r = [];
                    for (const t of i.getRanges()) r.push(e.toModelRange(t));
                    const s = t.createSelection(r, { backward: i.isBackward });
                    s.isEqual(t.document.selection) ||
                      t.change(t => {
                        t.setSelection(s);
                      });
                  };
                })(this.model, this.mapper),
              ),
              this.downcastDispatcher.on(
                'insert:$text',
                (t, e, n) => {
                  if (!n.consumable.consume(e.item, 'insert')) return;
                  const o = n.writer,
                    i = n.mapper.toViewPosition(e.range.start),
                    r = o.createText(e.item.data);
                  o.insert(i, r);
                },
                { priority: 'lowest' },
              ),
              this.downcastDispatcher.on(
                'remove',
                (t, e, n) => {
                  const o = n.mapper.toViewPosition(e.position),
                    i = e.position.getShiftedBy(e.length),
                    r = n.mapper.toViewPosition(i, { isPhantom: !0 }),
                    s = n.writer.createRange(o, r),
                    a = n.writer.remove(s.getTrimmed());
                  for (const t of n.writer.createRangeIn(a).getItems()) n.mapper.unbindViewElement(t);
                },
                { priority: 'low' },
              ),
              this.downcastDispatcher.on(
                'selection',
                (t, e, n) => {
                  const o = n.writer,
                    i = o.document.selection;
                  for (const t of i.getRanges())
                    t.isCollapsed && t.end.parent.isAttached() && n.writer.mergeAttributes(t.start);
                  o.setSelection(null);
                },
                { priority: 'low' },
              ),
              this.downcastDispatcher.on(
                'selection',
                (t, e, n) => {
                  const o = e.selection;
                  if (o.isCollapsed) return;
                  if (!n.consumable.consume(o, 'selection')) return;
                  const i = [];
                  for (const t of o.getRanges()) {
                    const e = n.mapper.toViewRange(t);
                    i.push(e);
                  }
                  n.writer.setSelection(i, { backward: o.isBackward });
                },
                { priority: 'low' },
              ),
              this.downcastDispatcher.on(
                'selection',
                (t, e, n) => {
                  const o = e.selection;
                  if (!o.isCollapsed) return;
                  if (!n.consumable.consume(o, 'selection')) return;
                  const i = n.writer,
                    r = o.getFirstPosition(),
                    s = n.mapper.toViewPosition(r),
                    a = i.breakAttributes(s);
                  i.setSelection(a);
                },
                { priority: 'low' },
              ),
              this.view.document.roots.bindTo(this.model.document.roots).using(t => {
                if ('$graveyard' == t.rootName) return null;
                const e = new gi(this.view.document, t.name);
                return (e.rootName = t.rootName), this.mapper.bindElements(t, e), e;
              });
          }
          destroy() {
            this.view.destroy(), this.stopListening();
          }
        }
        Yt(oc, jt);
        class ic {
          constructor() {
            this._commands = new Map();
          }
          add(t, e) {
            this._commands.set(t, e);
          }
          get(t) {
            return this._commands.get(t);
          }
          execute(t, ...e) {
            const n = this.get(t);
            if (!n) throw new c.a('commandcollection-command-not-found', this, { commandName: t });
            return n.execute(...e);
          }
          *names() {
            yield* this._commands.keys();
          }
          *commands() {
            yield* this._commands.values();
          }
          [Symbol.iterator]() {
            return this._commands[Symbol.iterator]();
          }
          destroy() {
            for (const t of this.commands()) t.destroy();
          }
        }
        class rc {
          constructor() {
            this._consumables = new Map();
          }
          add(t, e) {
            let n;
            t.is('$text') || t.is('documentFragment')
              ? this._consumables.set(t, !0)
              : (this._consumables.has(t)
                  ? (n = this._consumables.get(t))
                  : ((n = new sc(t)), this._consumables.set(t, n)),
                n.add(e));
          }
          test(t, e) {
            const n = this._consumables.get(t);
            return void 0 === n ? null : t.is('$text') || t.is('documentFragment') ? n : n.test(e);
          }
          consume(t, e) {
            return (
              !!this.test(t, e) &&
              (t.is('$text') || t.is('documentFragment')
                ? this._consumables.set(t, !1)
                : this._consumables.get(t).consume(e),
              !0)
            );
          }
          revert(t, e) {
            const n = this._consumables.get(t);
            void 0 !== n && (t.is('$text') || t.is('documentFragment') ? this._consumables.set(t, !0) : n.revert(e));
          }
          static consumablesFromElement(t) {
            const e = { element: t, name: !0, attributes: [], classes: [], styles: [] },
              n = t.getAttributeKeys();
            for (const t of n) 'style' != t && 'class' != t && e.attributes.push(t);
            const o = t.getClassNames();
            for (const t of o) e.classes.push(t);
            const i = t.getStyleNames();
            for (const t of i) e.styles.push(t);
            return e;
          }
          static createFrom(t, e) {
            if ((e || (e = new rc(t)), t.is('$text'))) return e.add(t), e;
            t.is('element') && e.add(t, rc.consumablesFromElement(t)), t.is('documentFragment') && e.add(t);
            for (const n of t.getChildren()) e = rc.createFrom(n, e);
            return e;
          }
        }
        class sc {
          constructor(t) {
            (this.element = t),
              (this._canConsumeName = null),
              (this._consumables = { attributes: new Map(), styles: new Map(), classes: new Map() });
          }
          add(t) {
            t.name && (this._canConsumeName = !0);
            for (const e in this._consumables) e in t && this._add(e, t[e]);
          }
          test(t) {
            if (t.name && !this._canConsumeName) return this._canConsumeName;
            for (const e in this._consumables)
              if (e in t) {
                const n = this._test(e, t[e]);
                if (!0 !== n) return n;
              }
            return !0;
          }
          consume(t) {
            t.name && (this._canConsumeName = !1);
            for (const e in this._consumables) e in t && this._consume(e, t[e]);
          }
          revert(t) {
            t.name && (this._canConsumeName = !0);
            for (const e in this._consumables) e in t && this._revert(e, t[e]);
          }
          _add(t, e) {
            const n = _t(e) ? e : [e],
              o = this._consumables[t];
            for (const e of n) {
              if ('attributes' === t && ('class' === e || 'style' === e))
                throw new c.a('viewconsumable-invalid-attribute', this);
              if ((o.set(e, !0), 'styles' === t))
                for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) o.set(t, !0);
            }
          }
          _test(t, e) {
            const n = _t(e) ? e : [e],
              o = this._consumables[t];
            for (const e of n)
              if ('attributes' !== t || ('class' !== e && 'style' !== e)) {
                const t = o.get(e);
                if (void 0 === t) return null;
                if (!t) return !1;
              } else {
                const t = 'class' == e ? 'classes' : 'styles',
                  n = this._test(t, [...this._consumables[t].keys()]);
                if (!0 !== n) return n;
              }
            return !0;
          }
          _consume(t, e) {
            const n = _t(e) ? e : [e],
              o = this._consumables[t];
            for (const e of n)
              if ('attributes' !== t || ('class' !== e && 'style' !== e)) {
                if ((o.set(e, !1), 'styles' == t))
                  for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) o.set(t, !1);
              } else {
                const t = 'class' == e ? 'classes' : 'styles';
                this._consume(t, [...this._consumables[t].keys()]);
              }
          }
          _revert(t, e) {
            const n = _t(e) ? e : [e],
              o = this._consumables[t];
            for (const e of n)
              if ('attributes' !== t || ('class' !== e && 'style' !== e)) {
                !1 === o.get(e) && o.set(e, !0);
              } else {
                const t = 'class' == e ? 'classes' : 'styles';
                this._revert(t, [...this._consumables[t].keys()]);
              }
          }
        }
        class ac {
          constructor() {
            (this._sourceDefinitions = {}),
              (this._attributeProperties = {}),
              this.decorate('checkChild'),
              this.decorate('checkAttribute'),
              this.on(
                'checkAttribute',
                (t, e) => {
                  e[0] = new cc(e[0]);
                },
                { priority: 'highest' },
              ),
              this.on(
                'checkChild',
                (t, e) => {
                  (e[0] = new cc(e[0])), (e[1] = this.getDefinition(e[1]));
                },
                { priority: 'highest' },
              );
          }
          register(t, e) {
            if (this._sourceDefinitions[t]) throw new c.a('schema-cannot-register-item-twice', this, { itemName: t });
            (this._sourceDefinitions[t] = [Object.assign({}, e)]), this._clearCache();
          }
          extend(t, e) {
            if (!this._sourceDefinitions[t]) throw new c.a('schema-cannot-extend-missing-item', this, { itemName: t });
            this._sourceDefinitions[t].push(Object.assign({}, e)), this._clearCache();
          }
          getDefinitions() {
            return this._compiledDefinitions || this._compile(), this._compiledDefinitions;
          }
          getDefinition(t) {
            let e;
            return (
              (e = 'string' == typeof t ? t : t.is && (t.is('$text') || t.is('$textProxy')) ? '$text' : t.name),
              this.getDefinitions()[e]
            );
          }
          isRegistered(t) {
            return !!this.getDefinition(t);
          }
          isBlock(t) {
            const e = this.getDefinition(t);
            return !(!e || !e.isBlock);
          }
          isLimit(t) {
            const e = this.getDefinition(t);
            return !!e && !(!e.isLimit && !e.isObject);
          }
          isObject(t) {
            const e = this.getDefinition(t);
            return !!e && !!(e.isObject || (e.isLimit && e.isSelectable && e.isContent));
          }
          isInline(t) {
            const e = this.getDefinition(t);
            return !(!e || !e.isInline);
          }
          isSelectable(t) {
            const e = this.getDefinition(t);
            return !!e && !(!e.isSelectable && !e.isObject);
          }
          isContent(t) {
            const e = this.getDefinition(t);
            return !!e && !(!e.isContent && !e.isObject);
          }
          checkChild(t, e) {
            return !!e && this._checkContextMatch(e, t);
          }
          checkAttribute(t, e) {
            const n = this.getDefinition(t.last);
            return !!n && n.allowAttributes.includes(e);
          }
          checkMerge(t, e = null) {
            if (t instanceof ma) {
              const e = t.nodeBefore,
                n = t.nodeAfter;
              if (!(e instanceof ha)) throw new c.a('schema-check-merge-no-element-before', this);
              if (!(n instanceof ha)) throw new c.a('schema-check-merge-no-element-after', this);
              return this.checkMerge(e, n);
            }
            for (const n of e.getChildren()) if (!this.checkChild(t, n)) return !1;
            return !0;
          }
          addChildCheck(t) {
            this.on(
              'checkChild',
              (e, [n, o]) => {
                if (!o) return;
                const i = t(n, o);
                'boolean' == typeof i && (e.stop(), (e.return = i));
              },
              { priority: 'high' },
            );
          }
          addAttributeCheck(t) {
            this.on(
              'checkAttribute',
              (e, [n, o]) => {
                const i = t(n, o);
                'boolean' == typeof i && (e.stop(), (e.return = i));
              },
              { priority: 'high' },
            );
          }
          setAttributeProperties(t, e) {
            this._attributeProperties[t] = Object.assign(this.getAttributeProperties(t), e);
          }
          getAttributeProperties(t) {
            return this._attributeProperties[t] || {};
          }
          getLimitElement(t) {
            let e;
            if (t instanceof ma) e = t.parent;
            else {
              e = (t instanceof ba ? [t] : Array.from(t.getRanges())).reduce((t, e) => {
                const n = e.getCommonAncestor();
                return t ? t.getCommonAncestor(n, { includeSelf: !0 }) : n;
              }, null);
            }
            for (; !this.isLimit(e) && e.parent; ) e = e.parent;
            return e;
          }
          checkAttributeInSelection(t, e) {
            if (t.isCollapsed) {
              const n = [...t.getFirstPosition().getAncestors(), new ca('', t.getAttributes())];
              return this.checkAttribute(n, e);
            }
            {
              const n = t.getRanges();
              for (const t of n) for (const n of t) if (this.checkAttribute(n.item, e)) return !0;
            }
            return !1;
          }
          *getValidRanges(t, e) {
            t = (function* (t) {
              for (const e of t) yield* e.getMinimalFlatRanges();
            })(t);
            for (const n of t) yield* this._getValidRangesForRange(n, e);
          }
          getNearestSelectionRange(t, e = 'both') {
            if (this.checkChild(t, '$text')) return new ba(t);
            let n, o;
            const i =
              t
                .getAncestors()
                .reverse()
                .find(t => this.isLimit(t)) || t.root;
            ('both' != e && 'backward' != e) ||
              (n = new ua({ boundaries: ba._createIn(i), startPosition: t, direction: 'backward' })),
              ('both' != e && 'forward' != e) || (o = new ua({ boundaries: ba._createIn(i), startPosition: t }));
            for (const t of (function* (t, e) {
              let n = !1;
              for (; !n; ) {
                if (((n = !0), t)) {
                  const e = t.next();
                  e.done || ((n = !1), yield { walker: t, value: e.value });
                }
                if (e) {
                  const t = e.next();
                  t.done || ((n = !1), yield { walker: e, value: t.value });
                }
              }
            })(n, o)) {
              const e = t.walker == n ? 'elementEnd' : 'elementStart',
                o = t.value;
              if (o.type == e && this.isObject(o.item)) return ba._createOn(o.item);
              if (this.checkChild(o.nextPosition, '$text')) return new ba(o.nextPosition);
            }
            return null;
          }
          findAllowedParent(t, e) {
            let n = t.parent;
            for (; n; ) {
              if (this.checkChild(n, e)) return n;
              if (this.isLimit(n)) return null;
              n = n.parent;
            }
            return null;
          }
          removeDisallowedAttributes(t, e) {
            for (const n of t)
              if (n.is('$text')) _c(this, n, e);
              else {
                const t = ba._createIn(n).getPositions();
                for (const n of t) {
                  _c(this, n.nodeBefore || n.parent, e);
                }
              }
          }
          createContext(t) {
            return new cc(t);
          }
          _clearCache() {
            this._compiledDefinitions = null;
          }
          _compile() {
            const t = {},
              e = this._sourceDefinitions,
              n = Object.keys(e);
            for (const o of n) t[o] = lc(e[o], o);
            for (const e of n) dc(t, e);
            for (const e of n) hc(t, e);
            for (const e of n) uc(t, e);
            for (const e of n) pc(t, e), mc(t, e);
            for (const e of n) gc(t, e), fc(t, e), kc(t, e);
            this._compiledDefinitions = t;
          }
          _checkContextMatch(t, e, n = e.length - 1) {
            const o = e.getItem(n);
            if (t.allowIn.includes(o.name)) {
              if (0 == n) return !0;
              {
                const t = this.getDefinition(o);
                return this._checkContextMatch(t, e, n - 1);
              }
            }
            return !1;
          }
          *_getValidRangesForRange(t, e) {
            let n = t.start,
              o = t.start;
            for (const i of t.getItems({ shallow: !0 }))
              i.is('element') && (yield* this._getValidRangesForRange(ba._createIn(i), e)),
                this.checkAttribute(i, e) || (n.isEqual(o) || (yield new ba(n, o)), (n = ma._createAfter(i))),
                (o = ma._createAfter(i));
            n.isEqual(o) || (yield new ba(n, o));
          }
        }
        Yt(ac, jt);
        class cc {
          constructor(t) {
            if (t instanceof cc) return t;
            'string' == typeof t ? (t = [t]) : Array.isArray(t) || (t = t.getAncestors({ includeSelf: !0 })),
              (this._items = t.map(Ac));
          }
          get length() {
            return this._items.length;
          }
          get last() {
            return this._items[this._items.length - 1];
          }
          [Symbol.iterator]() {
            return this._items[Symbol.iterator]();
          }
          push(t) {
            const e = new cc([t]);
            return (e._items = [...this._items, ...e._items]), e;
          }
          getItem(t) {
            return this._items[t];
          }
          *getNames() {
            yield* this._items.map(t => t.name);
          }
          endsWith(t) {
            return Array.from(this.getNames()).join(' ').endsWith(t);
          }
          startsWith(t) {
            return Array.from(this.getNames()).join(' ').startsWith(t);
          }
        }
        function lc(t, e) {
          const n = {
            name: e,
            allowIn: [],
            allowContentOf: [],
            allowWhere: [],
            allowAttributes: [],
            allowAttributesOf: [],
            allowChildren: [],
            inheritTypesFrom: [],
          };
          return (
            (function (t, e) {
              for (const n of t) {
                const t = Object.keys(n).filter(t => t.startsWith('is'));
                for (const o of t) e[o] = n[o];
              }
            })(t, n),
            bc(t, n, 'allowIn'),
            bc(t, n, 'allowContentOf'),
            bc(t, n, 'allowWhere'),
            bc(t, n, 'allowAttributes'),
            bc(t, n, 'allowAttributesOf'),
            bc(t, n, 'allowChildren'),
            bc(t, n, 'inheritTypesFrom'),
            (function (t, e) {
              for (const n of t) {
                const t = n.inheritAllFrom;
                t &&
                  (e.allowContentOf.push(t),
                  e.allowWhere.push(t),
                  e.allowAttributesOf.push(t),
                  e.inheritTypesFrom.push(t));
              }
            })(t, n),
            n
          );
        }
        function dc(t, e) {
          const n = t[e];
          for (const o of n.allowChildren) {
            const n = t[o];
            n && n.allowIn.push(e);
          }
          n.allowChildren.length = 0;
        }
        function hc(t, e) {
          for (const n of t[e].allowContentOf)
            if (t[n]) {
              wc(t, n).forEach(t => {
                t.allowIn.push(e);
              });
            }
          delete t[e].allowContentOf;
        }
        function uc(t, e) {
          for (const n of t[e].allowWhere) {
            const o = t[n];
            if (o) {
              const n = o.allowIn;
              t[e].allowIn.push(...n);
            }
          }
          delete t[e].allowWhere;
        }
        function pc(t, e) {
          for (const n of t[e].allowAttributesOf) {
            const o = t[n];
            if (o) {
              const n = o.allowAttributes;
              t[e].allowAttributes.push(...n);
            }
          }
          delete t[e].allowAttributesOf;
        }
        function mc(t, e) {
          const n = t[e];
          for (const e of n.inheritTypesFrom) {
            const o = t[e];
            if (o) {
              const t = Object.keys(o).filter(t => t.startsWith('is'));
              for (const e of t) e in n || (n[e] = o[e]);
            }
          }
          delete n.inheritTypesFrom;
        }
        function gc(t, e) {
          const n = t[e],
            o = n.allowIn.filter(e => t[e]);
          n.allowIn = Array.from(new Set(o));
        }
        function fc(t, e) {
          const n = t[e];
          for (const o of n.allowIn) {
            t[o].allowChildren.push(e);
          }
        }
        function kc(t, e) {
          const n = t[e];
          n.allowAttributes = Array.from(new Set(n.allowAttributes));
        }
        function bc(t, e, n) {
          for (const o of t) 'string' == typeof o[n] ? e[n].push(o[n]) : Array.isArray(o[n]) && e[n].push(...o[n]);
        }
        function wc(t, e) {
          const n = t[e];
          return ((o = t), Object.keys(o).map(t => o[t])).filter(t => t.allowIn.includes(n.name));
          var o;
        }
        function Ac(t) {
          return 'string' == typeof t || t.is('documentFragment')
            ? { name: 'string' == typeof t ? t : '$documentFragment', *getAttributeKeys() {}, getAttribute() {} }
            : {
                name: t.is('element') ? t.name : '$text',
                *getAttributeKeys() {
                  yield* t.getAttributeKeys();
                },
                getAttribute: e => t.getAttribute(e),
              };
        }
        function _c(t, e, n) {
          for (const o of e.getAttributeKeys()) t.checkAttribute(e, o) || n.removeAttribute(o, e);
        }
        class Cc {
          constructor(t = {}) {
            (this._splitParts = new Map()),
              (this._cursorParents = new Map()),
              (this._modelCursor = null),
              (this.conversionApi = Object.assign({}, t)),
              (this.conversionApi.convertItem = this._convertItem.bind(this)),
              (this.conversionApi.convertChildren = this._convertChildren.bind(this)),
              (this.conversionApi.safeInsert = this._safeInsert.bind(this)),
              (this.conversionApi.updateConversionResult = this._updateConversionResult.bind(this)),
              (this.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind(this)),
              (this.conversionApi.getSplitParts = this._getSplitParts.bind(this));
          }
          convert(t, e, n = ['$root']) {
            this.fire('viewCleanup', t),
              (this._modelCursor = (function (t, e) {
                let n;
                for (const o of new cc(t)) {
                  const t = {};
                  for (const e of o.getAttributeKeys()) t[e] = o.getAttribute(e);
                  const i = e.createElement(o.name, t);
                  n && e.append(i, n), (n = ma._createAt(i, 0));
                }
                return n;
              })(n, e)),
              (this.conversionApi.writer = e),
              (this.conversionApi.consumable = rc.createFrom(t)),
              (this.conversionApi.store = {});
            const { modelRange: o } = this._convertItem(t, this._modelCursor),
              i = e.createDocumentFragment();
            if (o) {
              this._removeEmptyElements();
              for (const t of Array.from(this._modelCursor.parent.getChildren())) e.append(t, i);
              i.markers = (function (t, e) {
                const n = new Set(),
                  o = new Map(),
                  i = ba._createIn(t).getItems();
                for (const t of i) '$marker' == t.name && n.add(t);
                for (const t of n) {
                  const n = t.getAttribute('data-name'),
                    i = e.createPositionBefore(t);
                  o.has(n) ? (o.get(n).end = i.clone()) : o.set(n, new ba(i.clone())), e.remove(t);
                }
                return o;
              })(i, e);
            }
            return (
              (this._modelCursor = null),
              this._splitParts.clear(),
              this._cursorParents.clear(),
              (this.conversionApi.writer = null),
              (this.conversionApi.store = null),
              i
            );
          }
          _convertItem(t, e) {
            const n = Object.assign({ viewItem: t, modelCursor: e, modelRange: null });
            if (
              (t.is('element')
                ? this.fire('element:' + t.name, n, this.conversionApi)
                : t.is('$text')
                ? this.fire('text', n, this.conversionApi)
                : this.fire('documentFragment', n, this.conversionApi),
              n.modelRange && !(n.modelRange instanceof ba))
            )
              throw new c.a('view-conversion-dispatcher-incorrect-result', this);
            return { modelRange: n.modelRange, modelCursor: n.modelCursor };
          }
          _convertChildren(t, e) {
            let n = e.is('position') ? e : ma._createAt(e, 0);
            const o = new ba(n);
            for (const e of Array.from(t.getChildren())) {
              const t = this._convertItem(e, n);
              t.modelRange instanceof ba && ((o.end = t.modelRange.end), (n = t.modelCursor));
            }
            return { modelRange: o, modelCursor: n };
          }
          _safeInsert(t, e) {
            const n = this._splitToAllowedParent(t, e);
            return !!n && (this.conversionApi.writer.insert(t, n.position), !0);
          }
          _updateConversionResult(t, e) {
            const n = this._getSplitParts(t),
              o = this.conversionApi.writer;
            e.modelRange ||
              (e.modelRange = o.createRange(o.createPositionBefore(t), o.createPositionAfter(n[n.length - 1])));
            const i = this._cursorParents.get(t);
            e.modelCursor = i ? o.createPositionAt(i, 0) : e.modelRange.end;
          }
          _splitToAllowedParent(t, e) {
            const { schema: n, writer: o } = this.conversionApi;
            let i = n.findAllowedParent(e, t);
            if (i) {
              if (i === e.parent) return { position: e };
              this._modelCursor.parent.getAncestors().includes(i) && (i = null);
            }
            if (!i) return Ua(e, t, n) ? { position: Ja(e, o) } : null;
            const r = this.conversionApi.writer.split(e, i),
              s = [];
            for (const t of r.range.getWalker())
              if ('elementEnd' == t.type) s.push(t.item);
              else {
                const e = s.pop(),
                  n = t.item;
                this._registerSplitPair(e, n);
              }
            const a = r.range.end.parent;
            return this._cursorParents.set(t, a), { position: r.position, cursorParent: a };
          }
          _registerSplitPair(t, e) {
            this._splitParts.has(t) || this._splitParts.set(t, [t]);
            const n = this._splitParts.get(t);
            this._splitParts.set(e, n), n.push(e);
          }
          _getSplitParts(t) {
            let e;
            return (e = this._splitParts.has(t) ? this._splitParts.get(t) : [t]), e;
          }
          _removeEmptyElements() {
            let t = !1;
            for (const e of this._splitParts.keys())
              e.isEmpty && (this.conversionApi.writer.remove(e), this._splitParts.delete(e), (t = !0));
            t && this._removeEmptyElements();
          }
        }
        Yt(Cc, h);
        class vc {
          getHtml(t) {
            const e = document.implementation.createHTMLDocument('').createElement('div');
            return e.appendChild(t), e.innerHTML;
          }
        }
        class yc {
          constructor(t) {
            (this._domParser = new DOMParser()),
              (this._domConverter = new Or(t, { blockFillerMode: 'nbsp' })),
              (this._htmlWriter = new vc());
          }
          toData(t) {
            const e = this._domConverter.viewToDom(t, document);
            return this._htmlWriter.getHtml(e);
          }
          toView(t) {
            const e = this._toDom(t);
            return this._domConverter.domToView(e);
          }
          registerRawContentMatcher(t) {
            this._domConverter.registerRawContentMatcher(t);
          }
          useFillerType(t) {
            this._domConverter.blockFillerMode = 'marked' == t ? 'markedNbsp' : 'nbsp';
          }
          _toDom(t) {
            const e = this._domParser.parseFromString(t, 'text/html'),
              n = e.createDocumentFragment(),
              o = e.body.childNodes;
            for (; o.length > 0; ) n.appendChild(o[0]);
            return n;
          }
        }
        class xc {
          constructor(t, e) {
            (this.model = t),
              (this.mapper = new wa()),
              (this.downcastDispatcher = new Ca({ mapper: this.mapper, schema: t.schema })),
              this.downcastDispatcher.on(
                'insert:$text',
                (t, e, n) => {
                  if (!n.consumable.consume(e.item, 'insert')) return;
                  const o = n.writer,
                    i = n.mapper.toViewPosition(e.range.start),
                    r = o.createText(e.item.data);
                  o.insert(i, r);
                },
                { priority: 'lowest' },
              ),
              (this.upcastDispatcher = new Cc({ schema: t.schema })),
              (this.viewDocument = new Ti(e)),
              (this.stylesProcessor = e),
              (this.htmlProcessor = new yc(this.viewDocument)),
              (this.processor = this.htmlProcessor),
              (this._viewWriter = new Zi(this.viewDocument)),
              this.upcastDispatcher.on(
                'text',
                (t, e, { schema: n, consumable: o, writer: i }) => {
                  let r = e.modelCursor;
                  if (!o.test(e.viewItem)) return;
                  if (!n.checkChild(r, '$text')) {
                    if (!Ua(r, '$text', n)) return;
                    r = Ja(r, i);
                  }
                  o.consume(e.viewItem);
                  const s = i.createText(e.viewItem.data);
                  i.insert(s, r),
                    (e.modelRange = i.createRange(r, r.getShiftedBy(s.offsetSize))),
                    (e.modelCursor = e.modelRange.end);
                },
                { priority: 'lowest' },
              ),
              this.upcastDispatcher.on(
                'element',
                (t, e, n) => {
                  if (!e.modelRange && n.consumable.consume(e.viewItem, { name: !0 })) {
                    const { modelRange: t, modelCursor: o } = n.convertChildren(e.viewItem, e.modelCursor);
                    (e.modelRange = t), (e.modelCursor = o);
                  }
                },
                { priority: 'lowest' },
              ),
              this.upcastDispatcher.on(
                'documentFragment',
                (t, e, n) => {
                  if (!e.modelRange && n.consumable.consume(e.viewItem, { name: !0 })) {
                    const { modelRange: t, modelCursor: o } = n.convertChildren(e.viewItem, e.modelCursor);
                    (e.modelRange = t), (e.modelCursor = o);
                  }
                },
                { priority: 'lowest' },
              ),
              this.decorate('init'),
              this.decorate('set'),
              this.on(
                'init',
                () => {
                  this.fire('ready');
                },
                { priority: 'lowest' },
              ),
              this.on(
                'ready',
                () => {
                  this.model.enqueueChange('transparent', Wa);
                },
                { priority: 'lowest' },
              );
          }
          get(t = {}) {
            const { rootName: e = 'main', trim: n = 'empty' } = t;
            if (!this._checkIfRootsExists([e])) throw new c.a('datacontroller-get-non-existent-root', this);
            const o = this.model.document.getRoot(e);
            return 'empty' !== n || this.model.hasContent(o, { ignoreWhitespaces: !0 }) ? this.stringify(o, t) : '';
          }
          stringify(t, e = {}) {
            const n = this.toView(t, e);
            return this.processor.toData(n);
          }
          toView(t, e = {}) {
            const n = this.viewDocument,
              o = this._viewWriter;
            this.mapper.clearBindings();
            const i = ba._createIn(t),
              r = new Xi(n);
            this.mapper.bindElements(t, r),
              (this.downcastDispatcher.conversionApi.options = e),
              this.downcastDispatcher.convertInsert(i, o);
            const s = t.is('documentFragment')
              ? Array.from(t.markers)
              : (function (t) {
                  const e = [],
                    n = t.root.document;
                  if (!n) return [];
                  const o = ba._createIn(t);
                  for (const t of n.model.markers) {
                    const n = o.getIntersection(t.getRange());
                    n && e.push([t.name, n]);
                  }
                  return e;
                })(t);
            for (const [t, e] of s) this.downcastDispatcher.convertMarkerAdd(t, e, o);
            return delete this.downcastDispatcher.conversionApi.options, r;
          }
          init(t) {
            if (this.model.document.version) throw new c.a('datacontroller-init-document-not-empty', this);
            let e = {};
            if (('string' == typeof t ? (e.main = t) : (e = t), !this._checkIfRootsExists(Object.keys(e))))
              throw new c.a('datacontroller-init-non-existent-root', this);
            return (
              this.model.enqueueChange('transparent', t => {
                for (const n of Object.keys(e)) {
                  const o = this.model.document.getRoot(n);
                  t.insert(this.parse(e[n], o), o, 0);
                }
              }),
              Promise.resolve()
            );
          }
          set(t) {
            let e = {};
            if (('string' == typeof t ? (e.main = t) : (e = t), !this._checkIfRootsExists(Object.keys(e))))
              throw new c.a('datacontroller-set-non-existent-root', this);
            this.model.enqueueChange('transparent', t => {
              t.setSelection(null), t.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
              for (const n of Object.keys(e)) {
                const o = this.model.document.getRoot(n);
                t.remove(t.createRangeIn(o)), t.insert(this.parse(e[n], o), o, 0);
              }
            });
          }
          parse(t, e = '$root') {
            const n = this.processor.toView(t);
            return this.toModel(n, e);
          }
          toModel(t, e = '$root') {
            return this.model.change(n => this.upcastDispatcher.convert(t, n, e));
          }
          addStyleProcessorRules(t) {
            t(this.stylesProcessor);
          }
          registerRawContentMatcher(t) {
            this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(t),
              this.htmlProcessor.registerRawContentMatcher(t);
          }
          destroy() {
            this.stopListening();
          }
          _checkIfRootsExists(t) {
            for (const e of t) if (!this.model.document.getRootNames().includes(e)) return !1;
            return !0;
          }
        }
        Yt(xc, jt);
        class Ec {
          constructor(t, e) {
            (this._helpers = new Map()),
              (this._downcast = ho(t)),
              this._createConversionHelpers({ name: 'downcast', dispatchers: this._downcast, isDowncast: !0 }),
              (this._upcast = ho(e)),
              this._createConversionHelpers({ name: 'upcast', dispatchers: this._upcast, isDowncast: !1 });
          }
          addAlias(t, e) {
            const n = this._downcast.includes(e);
            if (!this._upcast.includes(e) && !n) throw new c.a('conversion-add-alias-dispatcher-not-registered', this);
            this._createConversionHelpers({ name: t, dispatchers: [e], isDowncast: n });
          }
          for(t) {
            if (!this._helpers.has(t)) throw new c.a('conversion-for-unknown-group', this);
            return this._helpers.get(t);
          }
          elementToElement(t) {
            this.for('downcast').elementToElement(t);
            for (const { model: e, view: n } of Dc(t))
              this.for('upcast').elementToElement({ model: e, view: n, converterPriority: t.converterPriority });
          }
          attributeToElement(t) {
            this.for('downcast').attributeToElement(t);
            for (const { model: e, view: n } of Dc(t))
              this.for('upcast').elementToAttribute({ view: n, model: e, converterPriority: t.converterPriority });
          }
          attributeToAttribute(t) {
            this.for('downcast').attributeToAttribute(t);
            for (const { model: e, view: n } of Dc(t)) this.for('upcast').attributeToAttribute({ view: n, model: e });
          }
          _createConversionHelpers({ name: t, dispatchers: e, isDowncast: n }) {
            if (this._helpers.has(t)) throw new c.a('conversion-group-exists', this);
            const o = n ? new La(e) : new Ya(e);
            this._helpers.set(t, o);
          }
        }
        function* Dc(t) {
          if (t.model.values)
            for (const e of t.model.values) {
              const n = { key: t.model.key, value: e },
                o = t.view[e],
                i = t.upcastAlso ? t.upcastAlso[e] : void 0;
              yield* Sc(n, o, i);
            }
          else yield* Sc(t.model, t.view, t.upcastAlso);
        }
        function* Sc(t, e, n) {
          if ((yield { model: t, view: e }, n)) for (const e of ho(n)) yield { model: t, view: e };
        }
        class Bc {
          constructor(t = 'default') {
            (this.operations = []), (this.type = t);
          }
          get baseVersion() {
            for (const t of this.operations) if (null !== t.baseVersion) return t.baseVersion;
            return null;
          }
          addOperation(t) {
            return (t.batch = this), this.operations.push(t), t;
          }
        }
        class Tc {
          constructor(t) {
            (this.baseVersion = t), (this.isDocumentOperation = null !== this.baseVersion), (this.batch = null);
          }
          _validate() {}
          toJSON() {
            const t = Object.assign({}, this);
            return (t.__className = this.constructor.className), delete t.batch, delete t.isDocumentOperation, t;
          }
          static get className() {
            return 'Operation';
          }
          static fromJSON(t) {
            return new this(t.baseVersion);
          }
        }
        class Pc {
          constructor(t) {
            (this.markers = new Map()), (this._children = new da()), t && this._insertChild(0, t);
          }
          [Symbol.iterator]() {
            return this.getChildren();
          }
          get childCount() {
            return this._children.length;
          }
          get maxOffset() {
            return this._children.maxOffset;
          }
          get isEmpty() {
            return 0 === this.childCount;
          }
          get root() {
            return this;
          }
          get parent() {
            return null;
          }
          is(t) {
            return 'documentFragment' === t || 'model:documentFragment' === t;
          }
          getChild(t) {
            return this._children.getNode(t);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          getChildIndex(t) {
            return this._children.getNodeIndex(t);
          }
          getChildStartOffset(t) {
            return this._children.getNodeStartOffset(t);
          }
          getPath() {
            return [];
          }
          getNodeByPath(t) {
            let e = this;
            for (const n of t) e = e.getChild(e.offsetToIndex(n));
            return e;
          }
          offsetToIndex(t) {
            return this._children.offsetToIndex(t);
          }
          toJSON() {
            const t = [];
            for (const e of this._children) t.push(e.toJSON());
            return t;
          }
          static fromJSON(t) {
            const e = [];
            for (const n of t) n.name ? e.push(ha.fromJSON(n)) : e.push(ca.fromJSON(n));
            return new Pc(e);
          }
          _appendChild(t) {
            this._insertChild(this.childCount, t);
          }
          _insertChild(t, e) {
            const n = (function (t) {
              if ('string' == typeof t) return [new ca(t)];
              ao(t) || (t = [t]);
              return Array.from(t).map(t =>
                'string' == typeof t ? new ca(t) : t instanceof la ? new ca(t.data, t.getAttributes()) : t,
              );
            })(e);
            for (const t of n) null !== t.parent && t._remove(), (t.parent = this);
            this._children._insertNodes(t, n);
          }
          _removeChildren(t, e = 1) {
            const n = this._children._removeNodes(t, e);
            for (const t of n) t.parent = null;
            return n;
          }
        }
        function Ic(t, e) {
          const n = (e = Rc(e)).reduce((t, e) => t + e.offsetSize, 0),
            o = t.parent;
          Mc(t);
          const i = t.index;
          return o._insertChild(i, e), Oc(o, i + e.length), Oc(o, i), new ba(t, t.getShiftedBy(n));
        }
        function zc(t) {
          if (!t.isFlat) throw new c.a('operation-utils-remove-range-not-flat', this);
          const e = t.start.parent;
          Mc(t.start), Mc(t.end);
          const n = e._removeChildren(t.start.index, t.end.index - t.start.index);
          return Oc(e, t.start.index), n;
        }
        function Fc(t, e) {
          if (!t.isFlat) throw new c.a('operation-utils-move-range-not-flat', this);
          const n = zc(t);
          return Ic((e = e._getTransformedByDeletion(t.start, t.end.offset - t.start.offset)), n);
        }
        function Rc(t) {
          const e = [];
          t instanceof Array || (t = [t]);
          for (let n = 0; n < t.length; n++)
            if ('string' == typeof t[n]) e.push(new ca(t[n]));
            else if (t[n] instanceof la) e.push(new ca(t[n].data, t[n].getAttributes()));
            else if (t[n] instanceof Pc || t[n] instanceof da) for (const o of t[n]) e.push(o);
            else t[n] instanceof aa && e.push(t[n]);
          for (let t = 1; t < e.length; t++) {
            const n = e[t],
              o = e[t - 1];
            n instanceof ca &&
              o instanceof ca &&
              Nc(n, o) &&
              (e.splice(t - 1, 2, new ca(o.data + n.data, o.getAttributes())), t--);
          }
          return e;
        }
        function Oc(t, e) {
          const n = t.getChild(e - 1),
            o = t.getChild(e);
          if (n && o && n.is('$text') && o.is('$text') && Nc(n, o)) {
            const i = new ca(n.data + o.data, n.getAttributes());
            t._removeChildren(e - 1, 2), t._insertChild(e - 1, i);
          }
        }
        function Mc(t) {
          const e = t.textNode,
            n = t.parent;
          if (e) {
            const o = t.offset - e.startOffset,
              i = e.index;
            n._removeChildren(i, 1);
            const r = new ca(e.data.substr(0, o), e.getAttributes()),
              s = new ca(e.data.substr(o), e.getAttributes());
            n._insertChild(i, [r, s]);
          }
        }
        function Nc(t, e) {
          const n = t.getAttributes(),
            o = e.getAttributes();
          for (const t of n) {
            if (t[1] !== e.getAttribute(t[0])) return !1;
            o.next();
          }
          return o.next().done;
        }
        var Vc = function (t, e) {
          return ds(t, e);
        };
        class Lc extends Tc {
          constructor(t, e, n, o, i) {
            super(i),
              (this.range = t.clone()),
              (this.key = e),
              (this.oldValue = void 0 === n ? null : n),
              (this.newValue = void 0 === o ? null : o);
          }
          get type() {
            return null === this.oldValue
              ? 'addAttribute'
              : null === this.newValue
              ? 'removeAttribute'
              : 'changeAttribute';
          }
          clone() {
            return new Lc(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
          }
          getReversed() {
            return new Lc(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
          }
          toJSON() {
            const t = super.toJSON();
            return (t.range = this.range.toJSON()), t;
          }
          _validate() {
            if (!this.range.isFlat) throw new c.a('attribute-operation-range-not-flat', this);
            for (const t of this.range.getItems({ shallow: !0 })) {
              if (null !== this.oldValue && !Vc(t.getAttribute(this.key), this.oldValue))
                throw new c.a('attribute-operation-wrong-old-value', this, {
                  item: t,
                  key: this.key,
                  value: this.oldValue,
                });
              if (null === this.oldValue && null !== this.newValue && t.hasAttribute(this.key))
                throw new c.a('attribute-operation-attribute-exists', this, { node: t, key: this.key });
            }
          }
          _execute() {
            Vc(this.oldValue, this.newValue) ||
              (function (t, e, n) {
                Mc(t.start), Mc(t.end);
                for (const o of t.getItems({ shallow: !0 })) {
                  const t = o.is('$textProxy') ? o.textNode : o;
                  null !== n ? t._setAttribute(e, n) : t._removeAttribute(e), Oc(t.parent, t.index);
                }
                Oc(t.end.parent, t.end.index);
              })(this.range, this.key, this.newValue);
          }
          static get className() {
            return 'AttributeOperation';
          }
          static fromJSON(t, e) {
            return new Lc(ba.fromJSON(t.range, e), t.key, t.oldValue, t.newValue, t.baseVersion);
          }
        }
        class Kc extends Tc {
          constructor(t, e) {
            super(null), (this.sourcePosition = t.clone()), (this.howMany = e);
          }
          get type() {
            return 'detach';
          }
          toJSON() {
            const t = super.toJSON();
            return (t.sourcePosition = this.sourcePosition.toJSON()), t;
          }
          _validate() {
            if (this.sourcePosition.root.document) throw new c.a('detach-operation-on-document-node', this);
          }
          _execute() {
            zc(ba._createFromPositionAndShift(this.sourcePosition, this.howMany));
          }
          static get className() {
            return 'DetachOperation';
          }
        }
        class qc extends Tc {
          constructor(t, e, n, o) {
            super(o),
              (this.sourcePosition = t.clone()),
              (this.sourcePosition.stickiness = 'toNext'),
              (this.howMany = e),
              (this.targetPosition = n.clone()),
              (this.targetPosition.stickiness = 'toNone');
          }
          get type() {
            return '$graveyard' == this.targetPosition.root.rootName
              ? 'remove'
              : '$graveyard' == this.sourcePosition.root.rootName
              ? 'reinsert'
              : 'move';
          }
          clone() {
            return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
          }
          getMovedRangeStart() {
            return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
          }
          getReversed() {
            const t = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
            return new this.constructor(this.getMovedRangeStart(), this.howMany, t, this.baseVersion + 1);
          }
          _validate() {
            const t = this.sourcePosition.parent,
              e = this.targetPosition.parent,
              n = this.sourcePosition.offset,
              o = this.targetPosition.offset;
            if (n + this.howMany > t.maxOffset) throw new c.a('move-operation-nodes-do-not-exist', this);
            if (t === e && n < o && o < n + this.howMany) throw new c.a('move-operation-range-into-itself', this);
            if (
              this.sourcePosition.root == this.targetPosition.root &&
              'prefix' == bo(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath())
            ) {
              const t = this.sourcePosition.path.length - 1;
              if (this.targetPosition.path[t] >= n && this.targetPosition.path[t] < n + this.howMany)
                throw new c.a('move-operation-node-into-itself', this);
            }
          }
          _execute() {
            Fc(ba._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.sourcePosition = this.sourcePosition.toJSON()), (t.targetPosition = this.targetPosition.toJSON()), t
            );
          }
          static get className() {
            return 'MoveOperation';
          }
          static fromJSON(t, e) {
            const n = ma.fromJSON(t.sourcePosition, e),
              o = ma.fromJSON(t.targetPosition, e);
            return new this(n, t.howMany, o, t.baseVersion);
          }
        }
        class Hc extends Tc {
          constructor(t, e, n) {
            super(n),
              (this.position = t.clone()),
              (this.position.stickiness = 'toNone'),
              (this.nodes = new da(Rc(e))),
              (this.shouldReceiveAttributes = !1);
          }
          get type() {
            return 'insert';
          }
          get howMany() {
            return this.nodes.maxOffset;
          }
          clone() {
            const t = new da([...this.nodes].map(t => t._clone(!0))),
              e = new Hc(this.position, t, this.baseVersion);
            return (e.shouldReceiveAttributes = this.shouldReceiveAttributes), e;
          }
          getReversed() {
            const t = this.position.root.document.graveyard,
              e = new ma(t, [0]);
            return new qc(this.position, this.nodes.maxOffset, e, this.baseVersion + 1);
          }
          _validate() {
            const t = this.position.parent;
            if (!t || t.maxOffset < this.position.offset) throw new c.a('insert-operation-position-invalid', this);
          }
          _execute() {
            const t = this.nodes;
            (this.nodes = new da([...t].map(t => t._clone(!0)))), Ic(this.position, t);
          }
          toJSON() {
            const t = super.toJSON();
            return (t.position = this.position.toJSON()), (t.nodes = this.nodes.toJSON()), t;
          }
          static get className() {
            return 'InsertOperation';
          }
          static fromJSON(t, e) {
            const n = [];
            for (const e of t.nodes) e.name ? n.push(ha.fromJSON(e)) : n.push(ca.fromJSON(e));
            const o = new Hc(ma.fromJSON(t.position, e), n, t.baseVersion);
            return (o.shouldReceiveAttributes = t.shouldReceiveAttributes), o;
          }
        }
        class jc extends Tc {
          constructor(t, e, n, o, i, r) {
            super(r),
              (this.name = t),
              (this.oldRange = e ? e.clone() : null),
              (this.newRange = n ? n.clone() : null),
              (this.affectsData = i),
              (this._markers = o);
          }
          get type() {
            return 'marker';
          }
          clone() {
            return new jc(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
          }
          getReversed() {
            return new jc(
              this.name,
              this.newRange,
              this.oldRange,
              this._markers,
              this.affectsData,
              this.baseVersion + 1,
            );
          }
          _execute() {
            const t = this.newRange ? '_set' : '_remove';
            this._markers[t](this.name, this.newRange, !0, this.affectsData);
          }
          toJSON() {
            const t = super.toJSON();
            return (
              this.oldRange && (t.oldRange = this.oldRange.toJSON()),
              this.newRange && (t.newRange = this.newRange.toJSON()),
              delete t._markers,
              t
            );
          }
          static get className() {
            return 'MarkerOperation';
          }
          static fromJSON(t, e) {
            return new jc(
              t.name,
              t.oldRange ? ba.fromJSON(t.oldRange, e) : null,
              t.newRange ? ba.fromJSON(t.newRange, e) : null,
              e.model.markers,
              t.affectsData,
              t.baseVersion,
            );
          }
        }
        class $c extends Tc {
          constructor(t, e, n, o) {
            super(o),
              (this.position = t),
              (this.position.stickiness = 'toNext'),
              (this.oldName = e),
              (this.newName = n);
          }
          get type() {
            return 'rename';
          }
          clone() {
            return new $c(this.position.clone(), this.oldName, this.newName, this.baseVersion);
          }
          getReversed() {
            return new $c(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
          }
          _validate() {
            const t = this.position.nodeAfter;
            if (!(t instanceof ha)) throw new c.a('rename-operation-wrong-position', this);
            if (t.name !== this.oldName) throw new c.a('rename-operation-wrong-name', this);
          }
          _execute() {
            this.position.nodeAfter.name = this.newName;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.position = this.position.toJSON()), t;
          }
          static get className() {
            return 'RenameOperation';
          }
          static fromJSON(t, e) {
            return new $c(ma.fromJSON(t.position, e), t.oldName, t.newName, t.baseVersion);
          }
        }
        class Gc extends Tc {
          constructor(t, e, n, o, i) {
            super(i), (this.root = t), (this.key = e), (this.oldValue = n), (this.newValue = o);
          }
          get type() {
            return null === this.oldValue
              ? 'addRootAttribute'
              : null === this.newValue
              ? 'removeRootAttribute'
              : 'changeRootAttribute';
          }
          clone() {
            return new Gc(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
          }
          getReversed() {
            return new Gc(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
          }
          _validate() {
            if (this.root != this.root.root || this.root.is('documentFragment'))
              throw new c.a('rootattribute-operation-not-a-root', this, { root: this.root, key: this.key });
            if (null !== this.oldValue && this.root.getAttribute(this.key) !== this.oldValue)
              throw new c.a('rootattribute-operation-wrong-old-value', this, { root: this.root, key: this.key });
            if (null === this.oldValue && null !== this.newValue && this.root.hasAttribute(this.key))
              throw new c.a('rootattribute-operation-attribute-exists', this, { root: this.root, key: this.key });
          }
          _execute() {
            null !== this.newValue
              ? this.root._setAttribute(this.key, this.newValue)
              : this.root._removeAttribute(this.key);
          }
          toJSON() {
            const t = super.toJSON();
            return (t.root = this.root.toJSON()), t;
          }
          static get className() {
            return 'RootAttributeOperation';
          }
          static fromJSON(t, e) {
            if (!e.getRoot(t.root))
              throw new c.a('rootattribute-operation-fromjson-no-root', this, { rootName: t.root });
            return new Gc(e.getRoot(t.root), t.key, t.oldValue, t.newValue, t.baseVersion);
          }
        }
        class Wc extends Tc {
          constructor(t, e, n, o, i) {
            super(i),
              (this.sourcePosition = t.clone()),
              (this.sourcePosition.stickiness = 'toPrevious'),
              (this.howMany = e),
              (this.targetPosition = n.clone()),
              (this.targetPosition.stickiness = 'toNext'),
              (this.graveyardPosition = o.clone());
          }
          get type() {
            return 'merge';
          }
          get deletionPosition() {
            return new ma(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
          }
          get movedRange() {
            const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
            return new ba(this.sourcePosition, t);
          }
          clone() {
            return new this.constructor(
              this.sourcePosition,
              this.howMany,
              this.targetPosition,
              this.graveyardPosition,
              this.baseVersion,
            );
          }
          getReversed() {
            const t = this.targetPosition._getTransformedByMergeOperation(this),
              e = this.sourcePosition.path.slice(0, -1),
              n = new ma(this.sourcePosition.root, e)._getTransformedByMergeOperation(this);
            return new Uc(t, this.howMany, n, this.graveyardPosition, this.baseVersion + 1);
          }
          _validate() {
            const t = this.sourcePosition.parent,
              e = this.targetPosition.parent;
            if (!t.parent) throw new c.a('merge-operation-source-position-invalid', this);
            if (!e.parent) throw new c.a('merge-operation-target-position-invalid', this);
            if (this.howMany != t.maxOffset) throw new c.a('merge-operation-how-many-invalid', this);
          }
          _execute() {
            const t = this.sourcePosition.parent;
            Fc(ba._createIn(t), this.targetPosition), Fc(ba._createOn(t), this.graveyardPosition);
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.sourcePosition = t.sourcePosition.toJSON()),
              (t.targetPosition = t.targetPosition.toJSON()),
              (t.graveyardPosition = t.graveyardPosition.toJSON()),
              t
            );
          }
          static get className() {
            return 'MergeOperation';
          }
          static fromJSON(t, e) {
            const n = ma.fromJSON(t.sourcePosition, e),
              o = ma.fromJSON(t.targetPosition, e),
              i = ma.fromJSON(t.graveyardPosition, e);
            return new this(n, t.howMany, o, i, t.baseVersion);
          }
        }
        class Uc extends Tc {
          constructor(t, e, n, o, i) {
            super(i),
              (this.splitPosition = t.clone()),
              (this.splitPosition.stickiness = 'toNext'),
              (this.howMany = e),
              (this.insertionPosition = n),
              (this.graveyardPosition = o ? o.clone() : null),
              this.graveyardPosition && (this.graveyardPosition.stickiness = 'toNext');
          }
          get type() {
            return 'split';
          }
          get moveTargetPosition() {
            const t = this.insertionPosition.path.slice();
            return t.push(0), new ma(this.insertionPosition.root, t);
          }
          get movedRange() {
            const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
            return new ba(this.splitPosition, t);
          }
          clone() {
            return new this.constructor(
              this.splitPosition,
              this.howMany,
              this.insertionPosition,
              this.graveyardPosition,
              this.baseVersion,
            );
          }
          getReversed() {
            const t = this.splitPosition.root.document.graveyard,
              e = new ma(t, [0]);
            return new Wc(this.moveTargetPosition, this.howMany, this.splitPosition, e, this.baseVersion + 1);
          }
          _validate() {
            const t = this.splitPosition.parent,
              e = this.splitPosition.offset;
            if (!t || t.maxOffset < e) throw new c.a('split-operation-position-invalid', this);
            if (!t.parent) throw new c.a('split-operation-split-in-root', this);
            if (this.howMany != t.maxOffset - this.splitPosition.offset)
              throw new c.a('split-operation-how-many-invalid', this);
            if (this.graveyardPosition && !this.graveyardPosition.nodeAfter)
              throw new c.a('split-operation-graveyard-position-invalid', this);
          }
          _execute() {
            const t = this.splitPosition.parent;
            if (this.graveyardPosition)
              Fc(ba._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
            else {
              const e = t._clone();
              Ic(this.insertionPosition, e);
            }
            Fc(
              new ba(ma._createAt(t, this.splitPosition.offset), ma._createAt(t, t.maxOffset)),
              this.moveTargetPosition,
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.splitPosition = this.splitPosition.toJSON()),
              (t.insertionPosition = this.insertionPosition.toJSON()),
              this.graveyardPosition && (t.graveyardPosition = this.graveyardPosition.toJSON()),
              t
            );
          }
          static get className() {
            return 'SplitOperation';
          }
          static getInsertionPosition(t) {
            const e = t.path.slice(0, -1);
            return e[e.length - 1]++, new ma(t.root, e, 'toPrevious');
          }
          static fromJSON(t, e) {
            const n = ma.fromJSON(t.splitPosition, e),
              o = ma.fromJSON(t.insertionPosition, e),
              i = t.graveyardPosition ? ma.fromJSON(t.graveyardPosition, e) : null;
            return new this(n, t.howMany, o, i, t.baseVersion);
          }
        }
        class Jc extends ha {
          constructor(t, e, n = 'main') {
            super(e), (this._document = t), (this.rootName = n);
          }
          get document() {
            return this._document;
          }
          is(t, e) {
            return e
              ? e === this.name &&
                  ('rootElement' === t || 'model:rootElement' === t || 'element' === t || 'model:element' === t)
              : 'rootElement' === t ||
                  'model:rootElement' === t ||
                  'element' === t ||
                  'model:element' === t ||
                  'node' === t ||
                  'model:node' === t;
          }
          toJSON() {
            return this.rootName;
          }
        }
        class Yc {
          constructor(t, e) {
            (this.model = t), (this.batch = e);
          }
          createText(t, e) {
            return new ca(t, e);
          }
          createElement(t, e) {
            return new ha(t, e);
          }
          createDocumentFragment() {
            return new Pc();
          }
          cloneElement(t, e = !0) {
            return t._clone(e);
          }
          insert(t, e, n = 0) {
            if ((this._assertWriterUsedCorrectly(), t instanceof ca && '' == t.data)) return;
            const o = ma._createAt(e, n);
            if (t.parent) {
              if (el(t.root, o.root)) return void this.move(ba._createOn(t), o);
              if (t.root.document) throw new c.a('model-writer-insert-forbidden-move', this);
              this.remove(t);
            }
            const i = o.root.document ? o.root.document.version : null,
              r = new Hc(o, t, i);
            if (
              (t instanceof ca && (r.shouldReceiveAttributes = !0),
              this.batch.addOperation(r),
              this.model.applyOperation(r),
              t instanceof Pc)
            )
              for (const [e, n] of t.markers) {
                const t = ma._createAt(n.root, 0),
                  i = {
                    range: new ba(n.start._getCombined(t, o), n.end._getCombined(t, o)),
                    usingOperation: !0,
                    affectsData: !0,
                  };
                this.model.markers.has(e) ? this.updateMarker(e, i) : this.addMarker(e, i);
              }
          }
          insertText(t, e, n, o) {
            e instanceof Pc || e instanceof ha || e instanceof ma
              ? this.insert(this.createText(t), e, n)
              : this.insert(this.createText(t, e), n, o);
          }
          insertElement(t, e, n, o) {
            e instanceof Pc || e instanceof ha || e instanceof ma
              ? this.insert(this.createElement(t), e, n)
              : this.insert(this.createElement(t, e), n, o);
          }
          append(t, e) {
            this.insert(t, e, 'end');
          }
          appendText(t, e, n) {
            e instanceof Pc || e instanceof ha
              ? this.insert(this.createText(t), e, 'end')
              : this.insert(this.createText(t, e), n, 'end');
          }
          appendElement(t, e, n) {
            e instanceof Pc || e instanceof ha
              ? this.insert(this.createElement(t), e, 'end')
              : this.insert(this.createElement(t, e), n, 'end');
          }
          setAttribute(t, e, n) {
            if ((this._assertWriterUsedCorrectly(), n instanceof ba)) {
              const o = n.getMinimalFlatRanges();
              for (const n of o) Qc(this, t, e, n);
            } else Xc(this, t, e, n);
          }
          setAttributes(t, e) {
            for (const [n, o] of vo(t)) this.setAttribute(n, o, e);
          }
          removeAttribute(t, e) {
            if ((this._assertWriterUsedCorrectly(), e instanceof ba)) {
              const n = e.getMinimalFlatRanges();
              for (const e of n) Qc(this, t, null, e);
            } else Xc(this, t, null, e);
          }
          clearAttributes(t) {
            this._assertWriterUsedCorrectly();
            const e = t => {
              for (const e of t.getAttributeKeys()) this.removeAttribute(e, t);
            };
            if (t instanceof ba) for (const n of t.getItems()) e(n);
            else e(t);
          }
          move(t, e, n) {
            if ((this._assertWriterUsedCorrectly(), !(t instanceof ba)))
              throw new c.a('writer-move-invalid-range', this);
            if (!t.isFlat) throw new c.a('writer-move-range-not-flat', this);
            const o = ma._createAt(e, n);
            if (o.isEqual(t.start)) return;
            if ((this._addOperationForAffectedMarkers('move', t), !el(t.root, o.root)))
              throw new c.a('writer-move-different-document', this);
            const i = t.root.document ? t.root.document.version : null,
              r = new qc(t.start, t.end.offset - t.start.offset, o, i);
            this.batch.addOperation(r), this.model.applyOperation(r);
          }
          remove(t) {
            this._assertWriterUsedCorrectly();
            const e = (t instanceof ba ? t : ba._createOn(t)).getMinimalFlatRanges().reverse();
            for (const t of e)
              this._addOperationForAffectedMarkers('move', t),
                tl(t.start, t.end.offset - t.start.offset, this.batch, this.model);
          }
          merge(t) {
            this._assertWriterUsedCorrectly();
            const e = t.nodeBefore,
              n = t.nodeAfter;
            if ((this._addOperationForAffectedMarkers('merge', t), !(e instanceof ha)))
              throw new c.a('writer-merge-no-element-before', this);
            if (!(n instanceof ha)) throw new c.a('writer-merge-no-element-after', this);
            t.root.document ? this._merge(t) : this._mergeDetached(t);
          }
          createPositionFromPath(t, e, n) {
            return this.model.createPositionFromPath(t, e, n);
          }
          createPositionAt(t, e) {
            return this.model.createPositionAt(t, e);
          }
          createPositionAfter(t) {
            return this.model.createPositionAfter(t);
          }
          createPositionBefore(t) {
            return this.model.createPositionBefore(t);
          }
          createRange(t, e) {
            return this.model.createRange(t, e);
          }
          createRangeIn(t) {
            return this.model.createRangeIn(t);
          }
          createRangeOn(t) {
            return this.model.createRangeOn(t);
          }
          createSelection(t, e, n) {
            return this.model.createSelection(t, e, n);
          }
          _mergeDetached(t) {
            const e = t.nodeBefore,
              n = t.nodeAfter;
            this.move(ba._createIn(n), ma._createAt(e, 'end')), this.remove(n);
          }
          _merge(t) {
            const e = ma._createAt(t.nodeBefore, 'end'),
              n = ma._createAt(t.nodeAfter, 0),
              o = t.root.document.graveyard,
              i = new ma(o, [0]),
              r = t.root.document.version,
              s = new Wc(n, t.nodeAfter.maxOffset, e, i, r);
            this.batch.addOperation(s), this.model.applyOperation(s);
          }
          rename(t, e) {
            if ((this._assertWriterUsedCorrectly(), !(t instanceof ha)))
              throw new c.a('writer-rename-not-element-instance', this);
            const n = t.root.document ? t.root.document.version : null,
              o = new $c(ma._createBefore(t), t.name, e, n);
            this.batch.addOperation(o), this.model.applyOperation(o);
          }
          split(t, e) {
            this._assertWriterUsedCorrectly();
            let n,
              o,
              i = t.parent;
            if (!i.parent) throw new c.a('writer-split-element-no-parent', this);
            if ((e || (e = i.parent), !t.parent.getAncestors({ includeSelf: !0 }).includes(e)))
              throw new c.a('writer-split-invalid-limit-element', this);
            do {
              const e = i.root.document ? i.root.document.version : null,
                r = i.maxOffset - t.offset,
                s = Uc.getInsertionPosition(t),
                a = new Uc(t, r, s, null, e);
              this.batch.addOperation(a),
                this.model.applyOperation(a),
                n || o || ((n = i), (o = t.parent.nextSibling)),
                (i = (t = this.createPositionAfter(t.parent)).parent);
            } while (i !== e);
            return { position: t, range: new ba(ma._createAt(n, 'end'), ma._createAt(o, 0)) };
          }
          wrap(t, e) {
            if ((this._assertWriterUsedCorrectly(), !t.isFlat)) throw new c.a('writer-wrap-range-not-flat', this);
            const n = e instanceof ha ? e : new ha(e);
            if (n.childCount > 0) throw new c.a('writer-wrap-element-not-empty', this);
            if (null !== n.parent) throw new c.a('writer-wrap-element-attached', this);
            this.insert(n, t.start);
            const o = new ba(t.start.getShiftedBy(1), t.end.getShiftedBy(1));
            this.move(o, ma._createAt(n, 0));
          }
          unwrap(t) {
            if ((this._assertWriterUsedCorrectly(), null === t.parent))
              throw new c.a('writer-unwrap-element-no-parent', this);
            this.move(ba._createIn(t), this.createPositionAfter(t)), this.remove(t);
          }
          addMarker(t, e) {
            if ((this._assertWriterUsedCorrectly(), !e || 'boolean' != typeof e.usingOperation))
              throw new c.a('writer-addmarker-no-usingoperation', this);
            const n = e.usingOperation,
              o = e.range,
              i = void 0 !== e.affectsData && e.affectsData;
            if (this.model.markers.has(t)) throw new c.a('writer-addmarker-marker-exists', this);
            if (!o) throw new c.a('writer-addmarker-no-range', this);
            return n ? (Zc(this, t, null, o, i), this.model.markers.get(t)) : this.model.markers._set(t, o, n, i);
          }
          updateMarker(t, e) {
            this._assertWriterUsedCorrectly();
            const n = 'string' == typeof t ? t : t.name,
              o = this.model.markers.get(n);
            if (!o) throw new c.a('writer-updatemarker-marker-not-exists', this);
            if (!e) return void this.model.markers._refresh(o);
            const i = 'boolean' == typeof e.usingOperation,
              r = 'boolean' == typeof e.affectsData,
              s = r ? e.affectsData : o.affectsData;
            if (!i && !e.range && !r) throw new c.a('writer-updatemarker-wrong-options', this);
            const a = o.getRange(),
              l = e.range ? e.range : a;
            i && e.usingOperation !== o.managedUsingOperations
              ? e.usingOperation
                ? Zc(this, n, null, l, s)
                : (Zc(this, n, a, null, s), this.model.markers._set(n, l, void 0, s))
              : o.managedUsingOperations
              ? Zc(this, n, a, l, s)
              : this.model.markers._set(n, l, void 0, s);
          }
          removeMarker(t) {
            this._assertWriterUsedCorrectly();
            const e = 'string' == typeof t ? t : t.name;
            if (!this.model.markers.has(e)) throw new c.a('writer-removemarker-no-marker', this);
            const n = this.model.markers.get(e);
            if (!n.managedUsingOperations) return void this.model.markers._remove(e);
            Zc(this, e, n.getRange(), null, n.affectsData);
          }
          setSelection(t, e, n) {
            this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(t, e, n);
          }
          setSelectionFocus(t, e) {
            this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(t, e);
          }
          setSelectionAttribute(t, e) {
            if ((this._assertWriterUsedCorrectly(), 'string' == typeof t)) this._setSelectionAttribute(t, e);
            else for (const [e, n] of vo(t)) this._setSelectionAttribute(e, n);
          }
          removeSelectionAttribute(t) {
            if ((this._assertWriterUsedCorrectly(), 'string' == typeof t)) this._removeSelectionAttribute(t);
            else for (const e of t) this._removeSelectionAttribute(e);
          }
          overrideSelectionGravity() {
            return this.model.document.selection._overrideGravity();
          }
          restoreSelectionGravity(t) {
            this.model.document.selection._restoreGravity(t);
          }
          _setSelectionAttribute(t, e) {
            const n = this.model.document.selection;
            if (n.isCollapsed && n.anchor.parent.isEmpty) {
              const o = Ra._getStoreAttributeKey(t);
              this.setAttribute(o, e, n.anchor.parent);
            }
            n._setAttribute(t, e);
          }
          _removeSelectionAttribute(t) {
            const e = this.model.document.selection;
            if (e.isCollapsed && e.anchor.parent.isEmpty) {
              const n = Ra._getStoreAttributeKey(t);
              this.removeAttribute(n, e.anchor.parent);
            }
            e._removeAttribute(t);
          }
          _assertWriterUsedCorrectly() {
            if (this.model._currentWriter !== this) throw new c.a('writer-incorrect-use', this);
          }
          _addOperationForAffectedMarkers(t, e) {
            for (const n of this.model.markers) {
              if (!n.managedUsingOperations) continue;
              const o = n.getRange();
              let i = !1;
              if ('move' === t)
                i =
                  e.containsPosition(o.start) ||
                  e.start.isEqual(o.start) ||
                  e.containsPosition(o.end) ||
                  e.end.isEqual(o.end);
              else {
                const t = e.nodeBefore,
                  n = e.nodeAfter,
                  r = o.start.parent == t && o.start.isAtEnd,
                  s = o.end.parent == n && 0 == o.end.offset,
                  a = o.end.nodeAfter == n,
                  c = o.start.nodeAfter == n;
                i = r || s || a || c;
              }
              i && this.updateMarker(n.name, { range: o });
            }
          }
        }
        function Qc(t, e, n, o) {
          const i = t.model,
            r = i.document;
          let s,
            a,
            c,
            l = o.start;
          for (const t of o.getWalker({ shallow: !0 }))
            (c = t.item.getAttribute(e)), s && a != c && (a != n && d(), (l = s)), (s = t.nextPosition), (a = c);
          function d() {
            const o = new ba(l, s),
              c = o.root.document ? r.version : null,
              d = new Lc(o, e, a, n, c);
            t.batch.addOperation(d), i.applyOperation(d);
          }
          s instanceof ma && s != l && a != n && d();
        }
        function Xc(t, e, n, o) {
          const i = t.model,
            r = i.document,
            s = o.getAttribute(e);
          let a, c;
          if (s != n) {
            if (o.root === o) {
              const t = o.document ? r.version : null;
              c = new Gc(o, e, s, n, t);
            } else {
              a = new ba(ma._createBefore(o), t.createPositionAfter(o));
              const i = a.root.document ? r.version : null;
              c = new Lc(a, e, s, n, i);
            }
            t.batch.addOperation(c), i.applyOperation(c);
          }
        }
        function Zc(t, e, n, o, i) {
          const r = t.model,
            s = r.document,
            a = new jc(e, n, o, r.markers, i, s.version);
          t.batch.addOperation(a), r.applyOperation(a);
        }
        function tl(t, e, n, o) {
          let i;
          if (t.root.document) {
            const n = o.document,
              r = new ma(n.graveyard, [0]);
            i = new qc(t, e, r, n.version);
          } else i = new Kc(t, e);
          n.addOperation(i), o.applyOperation(i);
        }
        function el(t, e) {
          return t === e || (t instanceof Jc && e instanceof Jc);
        }
        class nl {
          constructor(t) {
            (this._markerCollection = t),
              (this._changesInElement = new Map()),
              (this._elementSnapshots = new Map()),
              (this._changedMarkers = new Map()),
              (this._changeCount = 0),
              (this._cachedChanges = null),
              (this._cachedChangesWithGraveyard = null);
          }
          get isEmpty() {
            return 0 == this._changesInElement.size && 0 == this._changedMarkers.size;
          }
          refreshItem(t) {
            if (this._isInInsertedElement(t.parent)) return;
            this._markRemove(t.parent, t.startOffset, t.offsetSize),
              this._markInsert(t.parent, t.startOffset, t.offsetSize);
            const e = ba._createOn(t);
            for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
              const e = t.getRange();
              this.bufferMarkerChange(t.name, e, e, t.affectsData);
            }
            this._cachedChanges = null;
          }
          bufferOperation(t) {
            switch (t.type) {
              case 'insert':
                if (this._isInInsertedElement(t.position.parent)) return;
                this._markInsert(t.position.parent, t.position.offset, t.nodes.maxOffset);
                break;
              case 'addAttribute':
              case 'removeAttribute':
              case 'changeAttribute':
                for (const e of t.range.getItems({ shallow: !0 }))
                  this._isInInsertedElement(e.parent) || this._markAttribute(e);
                break;
              case 'remove':
              case 'move':
              case 'reinsert': {
                if (
                  t.sourcePosition.isEqual(t.targetPosition) ||
                  t.sourcePosition.getShiftedBy(t.howMany).isEqual(t.targetPosition)
                )
                  return;
                const e = this._isInInsertedElement(t.sourcePosition.parent),
                  n = this._isInInsertedElement(t.targetPosition.parent);
                e || this._markRemove(t.sourcePosition.parent, t.sourcePosition.offset, t.howMany),
                  n || this._markInsert(t.targetPosition.parent, t.getMovedRangeStart().offset, t.howMany);
                break;
              }
              case 'rename': {
                if (this._isInInsertedElement(t.position.parent)) return;
                this._markRemove(t.position.parent, t.position.offset, 1),
                  this._markInsert(t.position.parent, t.position.offset, 1);
                const e = ba._createFromPositionAndShift(t.position, 1);
                for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
                  const e = t.getRange();
                  this.bufferMarkerChange(t.name, e, e, t.affectsData);
                }
                break;
              }
              case 'split': {
                const e = t.splitPosition.parent;
                this._isInInsertedElement(e) || this._markRemove(e, t.splitPosition.offset, t.howMany),
                  this._isInInsertedElement(t.insertionPosition.parent) ||
                    this._markInsert(t.insertionPosition.parent, t.insertionPosition.offset, 1),
                  t.graveyardPosition && this._markRemove(t.graveyardPosition.parent, t.graveyardPosition.offset, 1);
                break;
              }
              case 'merge': {
                const e = t.sourcePosition.parent;
                this._isInInsertedElement(e.parent) || this._markRemove(e.parent, e.startOffset, 1);
                const n = t.graveyardPosition.parent;
                this._markInsert(n, t.graveyardPosition.offset, 1);
                const o = t.targetPosition.parent;
                this._isInInsertedElement(o) || this._markInsert(o, t.targetPosition.offset, e.maxOffset);
                break;
              }
            }
            this._cachedChanges = null;
          }
          bufferMarkerChange(t, e, n, o) {
            const i = this._changedMarkers.get(t);
            i
              ? ((i.newRange = n),
                (i.affectsData = o),
                null == i.oldRange && null == i.newRange && this._changedMarkers.delete(t))
              : this._changedMarkers.set(t, { oldRange: e, newRange: n, affectsData: o });
          }
          getMarkersToRemove() {
            const t = [];
            for (const [e, n] of this._changedMarkers) null != n.oldRange && t.push({ name: e, range: n.oldRange });
            return t;
          }
          getMarkersToAdd() {
            const t = [];
            for (const [e, n] of this._changedMarkers) null != n.newRange && t.push({ name: e, range: n.newRange });
            return t;
          }
          getChangedMarkers() {
            return Array.from(this._changedMarkers).map(t => ({
              name: t[0],
              data: { oldRange: t[1].oldRange, newRange: t[1].newRange },
            }));
          }
          hasDataChanges() {
            for (const [, t] of this._changedMarkers) if (t.affectsData) return !0;
            return this._changesInElement.size > 0;
          }
          getChanges(t = { includeChangesInGraveyard: !1 }) {
            if (this._cachedChanges)
              return t.includeChangesInGraveyard
                ? this._cachedChangesWithGraveyard.slice()
                : this._cachedChanges.slice();
            let e = [];
            for (const t of this._changesInElement.keys()) {
              const n = this._changesInElement
                  .get(t)
                  .sort((t, e) =>
                    t.offset === e.offset
                      ? t.type != e.type
                        ? 'remove' == t.type
                          ? -1
                          : 1
                        : 0
                      : t.offset < e.offset
                      ? -1
                      : 1,
                  ),
                o = this._elementSnapshots.get(t),
                i = ol(t.getChildren()),
                r = il(o.length, n);
              let s = 0,
                a = 0;
              for (const n of r)
                if ('i' === n) e.push(this._getInsertDiff(t, s, i[s].name)), s++;
                else if ('r' === n) e.push(this._getRemoveDiff(t, s, o[a].name)), a++;
                else if ('a' === n) {
                  const n = i[s].attributes,
                    r = o[a].attributes;
                  let c;
                  if ('$text' == i[s].name) c = new ba(ma._createAt(t, s), ma._createAt(t, s + 1));
                  else {
                    const e = t.offsetToIndex(s);
                    c = new ba(ma._createAt(t, s), ma._createAt(t.getChild(e), 0));
                  }
                  e.push(...this._getAttributesDiff(c, r, n)), s++, a++;
                } else s++, a++;
            }
            e.sort((t, e) =>
              t.position.root != e.position.root
                ? t.position.root.rootName < e.position.root.rootName
                  ? -1
                  : 1
                : t.position.isEqual(e.position)
                ? t.changeCount - e.changeCount
                : t.position.isBefore(e.position)
                ? -1
                : 1,
            );
            for (let t = 1, n = 0; t < e.length; t++) {
              const o = e[n],
                i = e[t],
                r =
                  'remove' == o.type &&
                  'remove' == i.type &&
                  '$text' == o.name &&
                  '$text' == i.name &&
                  o.position.isEqual(i.position),
                s =
                  'insert' == o.type &&
                  'insert' == i.type &&
                  '$text' == o.name &&
                  '$text' == i.name &&
                  o.position.parent == i.position.parent &&
                  o.position.offset + o.length == i.position.offset,
                a =
                  'attribute' == o.type &&
                  'attribute' == i.type &&
                  o.position.parent == i.position.parent &&
                  o.range.isFlat &&
                  i.range.isFlat &&
                  o.position.offset + o.length == i.position.offset &&
                  o.attributeKey == i.attributeKey &&
                  o.attributeOldValue == i.attributeOldValue &&
                  o.attributeNewValue == i.attributeNewValue;
              r || s || a ? (o.length++, a && (o.range.end = o.range.end.getShiftedBy(1)), (e[t] = null)) : (n = t);
            }
            e = e.filter(t => t);
            for (const t of e) delete t.changeCount, 'attribute' == t.type && (delete t.position, delete t.length);
            return (
              (this._changeCount = 0),
              (this._cachedChangesWithGraveyard = e.slice()),
              (this._cachedChanges = e.filter(rl)),
              t.includeChangesInGraveyard ? this._cachedChangesWithGraveyard : this._cachedChanges
            );
          }
          reset() {
            this._changesInElement.clear(),
              this._elementSnapshots.clear(),
              this._changedMarkers.clear(),
              (this._cachedChanges = null);
          }
          _markInsert(t, e, n) {
            const o = { type: 'insert', offset: e, howMany: n, count: this._changeCount++ };
            this._markChange(t, o);
          }
          _markRemove(t, e, n) {
            const o = { type: 'remove', offset: e, howMany: n, count: this._changeCount++ };
            this._markChange(t, o), this._removeAllNestedChanges(t, e, n);
          }
          _markAttribute(t) {
            const e = { type: 'attribute', offset: t.startOffset, howMany: t.offsetSize, count: this._changeCount++ };
            this._markChange(t.parent, e);
          }
          _markChange(t, e) {
            this._makeSnapshot(t);
            const n = this._getChangesForElement(t);
            this._handleChange(e, n), n.push(e);
            for (let t = 0; t < n.length; t++) n[t].howMany < 1 && (n.splice(t, 1), t--);
          }
          _getChangesForElement(t) {
            let e;
            return (
              this._changesInElement.has(t)
                ? (e = this._changesInElement.get(t))
                : ((e = []), this._changesInElement.set(t, e)),
              e
            );
          }
          _makeSnapshot(t) {
            this._elementSnapshots.has(t) || this._elementSnapshots.set(t, ol(t.getChildren()));
          }
          _handleChange(t, e) {
            t.nodesToHandle = t.howMany;
            for (const n of e) {
              const o = t.offset + t.howMany,
                i = n.offset + n.howMany;
              if (
                'insert' == t.type &&
                ('insert' == n.type &&
                  (t.offset <= n.offset
                    ? (n.offset += t.howMany)
                    : t.offset < i && ((n.howMany += t.nodesToHandle), (t.nodesToHandle = 0))),
                'remove' == n.type && t.offset < n.offset && (n.offset += t.howMany),
                'attribute' == n.type)
              )
                if (t.offset <= n.offset) n.offset += t.howMany;
                else if (t.offset < i) {
                  const i = n.howMany;
                  (n.howMany = t.offset - n.offset),
                    e.unshift({ type: 'attribute', offset: o, howMany: i - n.howMany, count: this._changeCount++ });
                }
              if ('remove' == t.type) {
                if ('insert' == n.type)
                  if (o <= n.offset) n.offset -= t.howMany;
                  else if (o <= i)
                    if (t.offset < n.offset) {
                      const e = o - n.offset;
                      (n.offset = t.offset), (n.howMany -= e), (t.nodesToHandle -= e);
                    } else (n.howMany -= t.nodesToHandle), (t.nodesToHandle = 0);
                  else if (t.offset <= n.offset) (t.nodesToHandle -= n.howMany), (n.howMany = 0);
                  else if (t.offset < i) {
                    const e = i - t.offset;
                    (n.howMany -= e), (t.nodesToHandle -= e);
                  }
                if (
                  ('remove' == n.type &&
                    (o <= n.offset
                      ? (n.offset -= t.howMany)
                      : t.offset < n.offset && ((t.nodesToHandle += n.howMany), (n.howMany = 0))),
                  'attribute' == n.type)
                )
                  if (o <= n.offset) n.offset -= t.howMany;
                  else if (t.offset < n.offset) {
                    const e = o - n.offset;
                    (n.offset = t.offset), (n.howMany -= e);
                  } else if (t.offset < i)
                    if (o <= i) {
                      const o = n.howMany;
                      n.howMany = t.offset - n.offset;
                      const i = o - n.howMany - t.nodesToHandle;
                      e.unshift({ type: 'attribute', offset: t.offset, howMany: i, count: this._changeCount++ });
                    } else n.howMany -= i - t.offset;
              }
              if ('attribute' == t.type) {
                if ('insert' == n.type)
                  if (t.offset < n.offset && o > n.offset) {
                    if (o > i) {
                      const t = { type: 'attribute', offset: i, howMany: o - i, count: this._changeCount++ };
                      this._handleChange(t, e), e.push(t);
                    }
                    (t.nodesToHandle = n.offset - t.offset), (t.howMany = t.nodesToHandle);
                  } else
                    t.offset >= n.offset &&
                      t.offset < i &&
                      (o > i ? ((t.nodesToHandle = o - i), (t.offset = i)) : (t.nodesToHandle = 0));
                if ('remove' == n.type && t.offset < n.offset && o > n.offset) {
                  const i = { type: 'attribute', offset: n.offset, howMany: o - n.offset, count: this._changeCount++ };
                  this._handleChange(i, e),
                    e.push(i),
                    (t.nodesToHandle = n.offset - t.offset),
                    (t.howMany = t.nodesToHandle);
                }
                'attribute' == n.type &&
                  (t.offset >= n.offset && o <= i
                    ? ((t.nodesToHandle = 0), (t.howMany = 0), (t.offset = 0))
                    : t.offset <= n.offset && o >= i && (n.howMany = 0));
              }
            }
            (t.howMany = t.nodesToHandle), delete t.nodesToHandle;
          }
          _getInsertDiff(t, e, n) {
            return {
              type: 'insert',
              position: ma._createAt(t, e),
              name: n,
              length: 1,
              changeCount: this._changeCount++,
            };
          }
          _getRemoveDiff(t, e, n) {
            return {
              type: 'remove',
              position: ma._createAt(t, e),
              name: n,
              length: 1,
              changeCount: this._changeCount++,
            };
          }
          _getAttributesDiff(t, e, n) {
            const o = [];
            n = new Map(n);
            for (const [i, r] of e) {
              const e = n.has(i) ? n.get(i) : null;
              e !== r &&
                o.push({
                  type: 'attribute',
                  position: t.start,
                  range: t.clone(),
                  length: 1,
                  attributeKey: i,
                  attributeOldValue: r,
                  attributeNewValue: e,
                  changeCount: this._changeCount++,
                }),
                n.delete(i);
            }
            for (const [e, i] of n)
              o.push({
                type: 'attribute',
                position: t.start,
                range: t.clone(),
                length: 1,
                attributeKey: e,
                attributeOldValue: null,
                attributeNewValue: i,
                changeCount: this._changeCount++,
              });
            return o;
          }
          _isInInsertedElement(t) {
            const e = t.parent;
            if (!e) return !1;
            const n = this._changesInElement.get(e),
              o = t.startOffset;
            if (n) for (const t of n) if ('insert' == t.type && o >= t.offset && o < t.offset + t.howMany) return !0;
            return this._isInInsertedElement(e);
          }
          _removeAllNestedChanges(t, e, n) {
            const o = new ba(ma._createAt(t, e), ma._createAt(t, e + n));
            for (const t of o.getItems({ shallow: !0 }))
              t.is('element') &&
                (this._elementSnapshots.delete(t),
                this._changesInElement.delete(t),
                this._removeAllNestedChanges(t, 0, t.maxOffset));
          }
        }
        function ol(t) {
          const e = [];
          for (const n of t)
            if (n.is('$text'))
              for (let t = 0; t < n.data.length; t++) e.push({ name: '$text', attributes: new Map(n.getAttributes()) });
            else e.push({ name: n.name, attributes: new Map(n.getAttributes()) });
          return e;
        }
        function il(t, e) {
          const n = [];
          let o = 0,
            i = 0;
          for (const t of e) {
            if (t.offset > o) {
              for (let e = 0; e < t.offset - o; e++) n.push('e');
              i += t.offset - o;
            }
            if ('insert' == t.type) {
              for (let e = 0; e < t.howMany; e++) n.push('i');
              o = t.offset + t.howMany;
            } else if ('remove' == t.type) {
              for (let e = 0; e < t.howMany; e++) n.push('r');
              (o = t.offset), (i += t.howMany);
            } else n.push(...'a'.repeat(t.howMany).split('')), (o = t.offset + t.howMany), (i += t.howMany);
          }
          if (i < t) for (let e = 0; e < t - i - o; e++) n.push('e');
          return n;
        }
        function rl(t) {
          const e = t.position && '$graveyard' == t.position.root.rootName,
            n = t.range && '$graveyard' == t.range.root.rootName;
          return !e && !n;
        }
        class sl {
          constructor() {
            (this._operations = []), (this._undoPairs = new Map()), (this._undoneOperations = new Set());
          }
          addOperation(t) {
            this._operations.includes(t) || this._operations.push(t);
          }
          getOperations(t = Number.NEGATIVE_INFINITY, e = Number.POSITIVE_INFINITY) {
            const n = [];
            for (const o of this._operations) o.baseVersion >= t && o.baseVersion < e && n.push(o);
            return n;
          }
          getOperation(t) {
            for (const e of this._operations) if (e.baseVersion == t) return e;
          }
          setOperationAsUndone(t, e) {
            this._undoPairs.set(e, t), this._undoneOperations.add(t);
          }
          isUndoingOperation(t) {
            return this._undoPairs.has(t);
          }
          isUndoneOperation(t) {
            return this._undoneOperations.has(t);
          }
          getUndoneOperation(t) {
            return this._undoPairs.get(t);
          }
        }
        function al(t, e) {
          return (
            !!(n = t.charAt(e - 1)) &&
            1 == n.length &&
            /[\ud800-\udbff]/.test(n) &&
            (function (t) {
              return !!t && 1 == t.length && /[\udc00-\udfff]/.test(t);
            })(t.charAt(e))
          );
          var n;
        }
        function cl(t, e) {
          return (
            !!(n = t.charAt(e)) &&
            1 == n.length &&
            /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(n)
          );
          var n;
        }
        const ll = '$graveyard';
        class dl {
          constructor(t) {
            (this.model = t),
              (this.version = 0),
              (this.history = new sl(this)),
              (this.selection = new Ra(this)),
              (this.roots = new co({ idProperty: 'rootName' })),
              (this.differ = new nl(t.markers)),
              (this._postFixers = new Set()),
              (this._hasSelectionChangedFromTheLastChangeBlock = !1),
              this.createRoot('$root', ll),
              this.listenTo(
                t,
                'applyOperation',
                (t, e) => {
                  const n = e[0];
                  if (n.isDocumentOperation && n.baseVersion !== this.version)
                    throw new c.a('model-document-applyoperation-wrong-version', this, { operation: n });
                },
                { priority: 'highest' },
              ),
              this.listenTo(
                t,
                'applyOperation',
                (t, e) => {
                  const n = e[0];
                  n.isDocumentOperation && this.differ.bufferOperation(n);
                },
                { priority: 'high' },
              ),
              this.listenTo(
                t,
                'applyOperation',
                (t, e) => {
                  const n = e[0];
                  n.isDocumentOperation && (this.version++, this.history.addOperation(n));
                },
                { priority: 'low' },
              ),
              this.listenTo(this.selection, 'change', () => {
                this._hasSelectionChangedFromTheLastChangeBlock = !0;
              }),
              this.listenTo(t.markers, 'update', (t, e, n, o) => {
                this.differ.bufferMarkerChange(e.name, n, o, e.affectsData),
                  null === n &&
                    e.on('change', (t, n) => {
                      this.differ.bufferMarkerChange(e.name, n, e.getRange(), e.affectsData);
                    });
              });
          }
          get graveyard() {
            return this.getRoot(ll);
          }
          createRoot(t = '$root', e = 'main') {
            if (this.roots.get(e)) throw new c.a('model-document-createroot-name-exists', this, { name: e });
            const n = new Jc(this, t, e);
            return this.roots.add(n), n;
          }
          destroy() {
            this.selection.destroy(), this.stopListening();
          }
          getRoot(t = 'main') {
            return this.roots.get(t);
          }
          getRootNames() {
            return Array.from(this.roots, t => t.rootName).filter(t => t != ll);
          }
          registerPostFixer(t) {
            this._postFixers.add(t);
          }
          toJSON() {
            const t = wo(this);
            return (t.selection = '[engine.model.DocumentSelection]'), (t.model = '[engine.model.Model]'), t;
          }
          _handleChangeBlock(t) {
            this._hasDocumentChangedFromTheLastChangeBlock() &&
              (this._callPostFixers(t),
              this.selection.refresh(),
              this.differ.hasDataChanges() ? this.fire('change:data', t.batch) : this.fire('change', t.batch),
              this.selection.refresh(),
              this.differ.reset()),
              (this._hasSelectionChangedFromTheLastChangeBlock = !1);
          }
          _hasDocumentChangedFromTheLastChangeBlock() {
            return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
          }
          _getDefaultRoot() {
            for (const t of this.roots) if (t !== this.graveyard) return t;
            return this.graveyard;
          }
          _getDefaultRange() {
            const t = this._getDefaultRoot(),
              e = this.model,
              n = e.schema,
              o = e.createPositionFromPath(t, [0]);
            return n.getNearestSelectionRange(o) || e.createRange(o);
          }
          _validateSelectionRange(t) {
            return hl(t.start) && hl(t.end);
          }
          _callPostFixers(t) {
            let e = !1;
            do {
              for (const n of this._postFixers) if ((this.selection.refresh(), (e = n(t)), e)) break;
            } while (e);
          }
        }
        function hl(t) {
          const e = t.textNode;
          if (e) {
            const n = e.data,
              o = t.offset - e.startOffset;
            return !al(n, o) && !cl(n, o);
          }
          return !0;
        }
        Yt(dl, h);
        class ul {
          constructor() {
            this._markers = new Map();
          }
          [Symbol.iterator]() {
            return this._markers.values();
          }
          has(t) {
            return this._markers.has(t);
          }
          get(t) {
            return this._markers.get(t) || null;
          }
          _set(t, e, n = !1, o = !1) {
            const i = t instanceof pl ? t.name : t;
            if (i.includes(',')) throw new c.a('markercollection-incorrect-marker-name', this);
            const r = this._markers.get(i);
            if (r) {
              const t = r.getRange();
              let s = !1;
              return (
                t.isEqual(e) || (r._attachLiveRange(Pa.fromRange(e)), (s = !0)),
                n != r.managedUsingOperations && ((r._managedUsingOperations = n), (s = !0)),
                'boolean' == typeof o && o != r.affectsData && ((r._affectsData = o), (s = !0)),
                s && this.fire('update:' + i, r, t, e),
                r
              );
            }
            const s = Pa.fromRange(e),
              a = new pl(i, s, n, o);
            return this._markers.set(i, a), this.fire('update:' + i, a, null, e), a;
          }
          _remove(t) {
            const e = t instanceof pl ? t.name : t,
              n = this._markers.get(e);
            return (
              !!n &&
              (this._markers.delete(e), this.fire('update:' + e, n, n.getRange(), null), this._destroyMarker(n), !0)
            );
          }
          _refresh(t) {
            const e = t instanceof pl ? t.name : t,
              n = this._markers.get(e);
            if (!n) throw new c.a('markercollection-refresh-marker-not-exists', this);
            const o = n.getRange();
            this.fire('update:' + e, n, o, o, n.managedUsingOperations, n.affectsData);
          }
          *getMarkersAtPosition(t) {
            for (const e of this) e.getRange().containsPosition(t) && (yield e);
          }
          *getMarkersIntersectingRange(t) {
            for (const e of this) null !== e.getRange().getIntersection(t) && (yield e);
          }
          destroy() {
            for (const t of this._markers.values()) this._destroyMarker(t);
            (this._markers = null), this.stopListening();
          }
          *getMarkersGroup(t) {
            for (const e of this._markers.values()) e.name.startsWith(t + ':') && (yield e);
          }
          _destroyMarker(t) {
            t.stopListening(), t._detachLiveRange();
          }
        }
        Yt(ul, h);
        class pl {
          constructor(t, e, n, o) {
            (this.name = t),
              (this._liveRange = this._attachLiveRange(e)),
              (this._managedUsingOperations = n),
              (this._affectsData = o);
          }
          get managedUsingOperations() {
            if (!this._liveRange) throw new c.a('marker-destroyed', this);
            return this._managedUsingOperations;
          }
          get affectsData() {
            if (!this._liveRange) throw new c.a('marker-destroyed', this);
            return this._affectsData;
          }
          getStart() {
            if (!this._liveRange) throw new c.a('marker-destroyed', this);
            return this._liveRange.start.clone();
          }
          getEnd() {
            if (!this._liveRange) throw new c.a('marker-destroyed', this);
            return this._liveRange.end.clone();
          }
          getRange() {
            if (!this._liveRange) throw new c.a('marker-destroyed', this);
            return this._liveRange.toRange();
          }
          is(t) {
            return 'marker' === t || 'model:marker' === t;
          }
          _attachLiveRange(t) {
            return (
              this._liveRange && this._detachLiveRange(),
              t.delegate('change:range').to(this),
              t.delegate('change:content').to(this),
              (this._liveRange = t),
              t
            );
          }
          _detachLiveRange() {
            this._liveRange.stopDelegating('change:range', this),
              this._liveRange.stopDelegating('change:content', this),
              this._liveRange.detach(),
              (this._liveRange = null);
          }
        }
        Yt(pl, h);
        class ml extends Tc {
          get type() {
            return 'noop';
          }
          clone() {
            return new ml(this.baseVersion);
          }
          getReversed() {
            return new ml(this.baseVersion + 1);
          }
          _execute() {}
          static get className() {
            return 'NoOperation';
          }
        }
        const gl = {};
        (gl[Lc.className] = Lc),
          (gl[Hc.className] = Hc),
          (gl[jc.className] = jc),
          (gl[qc.className] = qc),
          (gl[ml.className] = ml),
          (gl[Tc.className] = Tc),
          (gl[$c.className] = $c),
          (gl[Gc.className] = Gc),
          (gl[Uc.className] = Uc),
          (gl[Wc.className] = Wc);
        class fl extends ma {
          constructor(t, e, n = 'toNone') {
            if ((super(t, e, n), !this.root.is('rootElement')))
              throw new c.a('model-liveposition-root-not-rootelement', t);
            kl.call(this);
          }
          detach() {
            this.stopListening();
          }
          is(t) {
            return 'livePosition' === t || 'model:livePosition' === t || 'position' == t || 'model:position' === t;
          }
          toPosition() {
            return new ma(this.root, this.path.slice(), this.stickiness);
          }
          static fromPosition(t, e) {
            return new this(t.root, t.path.slice(), e || t.stickiness);
          }
        }
        function kl() {
          this.listenTo(
            this.root.document.model,
            'applyOperation',
            (t, e) => {
              const n = e[0];
              n.isDocumentOperation && bl.call(this, n);
            },
            { priority: 'low' },
          );
        }
        function bl(t) {
          const e = this.getTransformedByOperation(t);
          if (!this.isEqual(e)) {
            const t = this.toPosition();
            (this.path = e.path), (this.root = e.root), this.fire('change', t);
          }
        }
        Yt(fl, h);
        class wl {
          constructor(t, e, n) {
            (this.model = t),
              (this.writer = e),
              (this.position = n),
              (this.canMergeWith = new Set([this.position.parent])),
              (this.schema = t.schema),
              (this._documentFragment = e.createDocumentFragment()),
              (this._documentFragmentPosition = e.createPositionAt(this._documentFragment, 0)),
              (this._firstNode = null),
              (this._lastNode = null),
              (this._lastAutoParagraph = null),
              (this._filterAttributesOf = []),
              (this._affectedStart = null),
              (this._affectedEnd = null);
          }
          handleNodes(t) {
            for (const e of Array.from(t)) this._handleNode(e);
            this._insertPartialFragment(),
              this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph),
              this._mergeOnRight(),
              this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer),
              (this._filterAttributesOf = []);
          }
          _updateLastNodeFromAutoParagraph(t) {
            const e = this.writer.createPositionAfter(this._lastNode),
              n = this.writer.createPositionAfter(t);
            if (n.isAfter(e)) {
              if (((this._lastNode = t), this.position.parent != t || !this.position.isAtEnd))
                throw new c.a('insertcontent-invalid-insertion-position', this);
              (this.position = n), this._setAffectedBoundaries(this.position);
            }
          }
          getSelectionRange() {
            return this.nodeToSelect
              ? ba._createOn(this.nodeToSelect)
              : this.model.schema.getNearestSelectionRange(this.position);
          }
          getAffectedRange() {
            return this._affectedStart ? new ba(this._affectedStart, this._affectedEnd) : null;
          }
          destroy() {
            this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach();
          }
          _handleNode(t) {
            if (this.schema.isObject(t)) return void this._handleObject(t);
            let e = this._checkAndAutoParagraphToAllowedPosition(t);
            e || ((e = this._checkAndSplitToAllowedPosition(t)), e)
              ? (this._appendToFragment(t), this._firstNode || (this._firstNode = t), (this._lastNode = t))
              : this._handleDisallowedNode(t);
          }
          _insertPartialFragment() {
            if (this._documentFragment.isEmpty) return;
            const t = fl.fromPosition(this.position, 'toNext');
            this._setAffectedBoundaries(this.position),
              this._documentFragment.getChild(0) == this._firstNode &&
                (this.writer.insert(this._firstNode, this.position),
                this._mergeOnLeft(),
                (this.position = t.toPosition())),
              this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position),
              (this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0)),
              (this.position = t.toPosition()),
              t.detach();
          }
          _handleObject(t) {
            this._checkAndSplitToAllowedPosition(t) ? this._appendToFragment(t) : this._tryAutoparagraphing(t);
          }
          _handleDisallowedNode(t) {
            t.is('element') ? this.handleNodes(t.getChildren()) : this._tryAutoparagraphing(t);
          }
          _appendToFragment(t) {
            if (!this.schema.checkChild(this.position, t))
              throw new c.a('insertcontent-wrong-position', this, { node: t, position: this.position });
            this.writer.insert(t, this._documentFragmentPosition),
              (this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(t.offsetSize)),
              this.schema.isObject(t) && !this.schema.checkChild(this.position, '$text')
                ? (this.nodeToSelect = t)
                : (this.nodeToSelect = null),
              this._filterAttributesOf.push(t);
          }
          _setAffectedBoundaries(t) {
            this._affectedStart || (this._affectedStart = fl.fromPosition(t, 'toPrevious')),
              (this._affectedEnd && !this._affectedEnd.isBefore(t)) ||
                (this._affectedEnd && this._affectedEnd.detach(), (this._affectedEnd = fl.fromPosition(t, 'toNext')));
          }
          _mergeOnLeft() {
            const t = this._firstNode;
            if (!(t instanceof ha)) return;
            if (!this._canMergeLeft(t)) return;
            const e = fl._createBefore(t);
            e.stickiness = 'toNext';
            const n = fl.fromPosition(this.position, 'toNext');
            this._affectedStart.isEqual(e) &&
              (this._affectedStart.detach(), (this._affectedStart = fl._createAt(e.nodeBefore, 'end', 'toPrevious'))),
              this._firstNode === this._lastNode && ((this._firstNode = e.nodeBefore), (this._lastNode = e.nodeBefore)),
              this.writer.merge(e),
              e.isEqual(this._affectedEnd) &&
                this._firstNode === this._lastNode &&
                (this._affectedEnd.detach(), (this._affectedEnd = fl._createAt(e.nodeBefore, 'end', 'toNext'))),
              (this.position = n.toPosition()),
              n.detach(),
              this._filterAttributesOf.push(this.position.parent),
              e.detach();
          }
          _mergeOnRight() {
            const t = this._lastNode;
            if (!(t instanceof ha)) return;
            if (!this._canMergeRight(t)) return;
            const e = fl._createAfter(t);
            if (((e.stickiness = 'toNext'), !this.position.isEqual(e)))
              throw new c.a('insertcontent-invalid-insertion-position', this);
            this.position = ma._createAt(e.nodeBefore, 'end');
            const n = fl.fromPosition(this.position, 'toPrevious');
            this._affectedEnd.isEqual(e) &&
              (this._affectedEnd.detach(), (this._affectedEnd = fl._createAt(e.nodeBefore, 'end', 'toNext'))),
              this._firstNode === this._lastNode && ((this._firstNode = e.nodeBefore), (this._lastNode = e.nodeBefore)),
              this.writer.merge(e),
              e.getShiftedBy(-1).isEqual(this._affectedStart) &&
                this._firstNode === this._lastNode &&
                (this._affectedStart.detach(), (this._affectedStart = fl._createAt(e.nodeBefore, 0, 'toPrevious'))),
              (this.position = n.toPosition()),
              n.detach(),
              this._filterAttributesOf.push(this.position.parent),
              e.detach();
          }
          _canMergeLeft(t) {
            const e = t.previousSibling;
            return e instanceof ha && this.canMergeWith.has(e) && this.model.schema.checkMerge(e, t);
          }
          _canMergeRight(t) {
            const e = t.nextSibling;
            return e instanceof ha && this.canMergeWith.has(e) && this.model.schema.checkMerge(t, e);
          }
          _tryAutoparagraphing(t) {
            const e = this.writer.createElement('paragraph');
            this._getAllowedIn(e, this.position.parent) &&
              this.schema.checkChild(e, t) &&
              (e._appendChild(t), this._handleNode(e));
          }
          _checkAndAutoParagraphToAllowedPosition(t) {
            if (this.schema.checkChild(this.position.parent, t)) return !0;
            if (!this.schema.checkChild(this.position.parent, 'paragraph') || !this.schema.checkChild('paragraph', t))
              return !1;
            this._insertPartialFragment();
            const e = this.writer.createElement('paragraph');
            return (
              this.writer.insert(e, this.position),
              this._setAffectedBoundaries(this.position),
              (this._lastAutoParagraph = e),
              (this.position = this.writer.createPositionAt(e, 0)),
              !0
            );
          }
          _checkAndSplitToAllowedPosition(t) {
            const e = this._getAllowedIn(t, this.position.parent);
            if (!e) return !1;
            for (e != this.position.parent && this._insertPartialFragment(); e != this.position.parent; ) {
              if (this.schema.isLimit(this.position.parent)) return !1;
              if (this.position.isAtStart) {
                const t = this.position.parent;
                (this.position = this.writer.createPositionBefore(t)),
                  t.isEmpty && t.parent === e && this.writer.remove(t);
              } else if (this.position.isAtEnd) this.position = this.writer.createPositionAfter(this.position.parent);
              else {
                const t = this.writer.createPositionAfter(this.position.parent);
                this._setAffectedBoundaries(this.position),
                  this.writer.split(this.position),
                  (this.position = t),
                  this.canMergeWith.add(this.position.nodeAfter);
              }
            }
            return !0;
          }
          _getAllowedIn(t, e) {
            return this.schema.checkChild(e, t) ? e : e.parent ? this._getAllowedIn(t, e.parent) : null;
          }
        }
        function Al(t, e, n = {}) {
          if (e.isCollapsed) return;
          const o = e.getFirstRange();
          if ('$graveyard' == o.root.rootName) return;
          const i = t.schema;
          t.change(t => {
            if (
              !n.doNotResetEntireContent &&
              (function (t, e) {
                const n = t.getLimitElement(e);
                if (!e.containsEntireContent(n)) return !1;
                const o = e.getFirstRange();
                if (o.start.parent == o.end.parent) return !1;
                return t.checkChild(n, 'paragraph');
              })(i, e)
            )
              return void (function (t, e) {
                const n = t.model.schema.getLimitElement(e);
                t.remove(t.createRangeIn(n)), yl(t, t.createPositionAt(n, 0), e);
              })(t, e);
            const [r, s] = (function (t) {
              const e = t.root.document.model,
                n = t.start;
              let o = t.end;
              if (e.hasContent(t, { ignoreMarkers: !0 })) {
                const n = (function (t) {
                  const e = t.parent,
                    n = e.root.document.model.schema,
                    o = e.getAncestors({ parentFirst: !0, includeSelf: !0 });
                  for (const t of o) {
                    if (n.isLimit(t)) return null;
                    if (n.isBlock(t)) return t;
                  }
                })(o);
                if (n && o.isTouching(e.createPositionAt(n, 0))) {
                  const n = e.createSelection(t);
                  e.modifySelection(n, { direction: 'backward' });
                  const i = n.getLastPosition(),
                    r = e.createRange(i, o);
                  e.hasContent(r, { ignoreMarkers: !0 }) || (o = i);
                }
              }
              return [fl.fromPosition(n, 'toPrevious'), fl.fromPosition(o, 'toNext')];
            })(o);
            r.isTouching(s) || t.remove(t.createRange(r, s)),
              n.leaveUnmerged ||
                (!(function (t, e, n) {
                  const o = t.model;
                  if (!vl(t.model.schema, e, n)) return;
                  const [i, r] = (function (t, e) {
                    const n = t.getAncestors(),
                      o = e.getAncestors();
                    let i = 0;
                    for (; n[i] && n[i] == o[i]; ) i++;
                    return [n[i], o[i]];
                  })(e, n);
                  if (!i || !r) return;
                  !o.hasContent(i, { ignoreMarkers: !0 }) && o.hasContent(r, { ignoreMarkers: !0 })
                    ? Cl(t, e, n, i.parent)
                    : _l(t, e, n, i.parent);
                })(t, r, s),
                i.removeDisallowedAttributes(r.parent.getChildren(), t)),
              xl(t, e, r),
              !n.doNotAutoparagraph &&
                (function (t, e) {
                  const n = t.checkChild(e, '$text'),
                    o = t.checkChild(e, 'paragraph');
                  return !n && o;
                })(i, r) &&
                yl(t, r, e),
              r.detach(),
              s.detach();
          });
        }
        function _l(t, e, n, o) {
          const i = e.parent,
            r = n.parent;
          if (i != o && r != o) {
            for (
              e = t.createPositionAfter(i), (n = t.createPositionBefore(r)).isEqual(e) || t.insert(r, e), t.merge(e);
              n.parent.isEmpty;

            ) {
              const e = n.parent;
              (n = t.createPositionBefore(e)), t.remove(e);
            }
            vl(t.model.schema, e, n) && _l(t, e, n, o);
          }
        }
        function Cl(t, e, n, o) {
          const i = e.parent,
            r = n.parent;
          if (i != o && r != o) {
            for (
              e = t.createPositionAfter(i), (n = t.createPositionBefore(r)).isEqual(e) || t.insert(i, n);
              e.parent.isEmpty;

            ) {
              const n = e.parent;
              (e = t.createPositionBefore(n)), t.remove(n);
            }
            (n = t.createPositionBefore(r)),
              (function (t, e) {
                const n = e.nodeBefore,
                  o = e.nodeAfter;
                n.name != o.name && t.rename(n, o.name);
                t.clearAttributes(n), t.setAttributes(Object.fromEntries(o.getAttributes()), n), t.merge(e);
              })(t, n),
              vl(t.model.schema, e, n) && Cl(t, e, n, o);
          }
        }
        function vl(t, e, n) {
          const o = e.parent,
            i = n.parent;
          return (
            o != i &&
            !t.isLimit(o) &&
            !t.isLimit(i) &&
            (function (t, e, n) {
              const o = new ba(t, e);
              for (const t of o.getWalker()) if (n.isLimit(t.item)) return !1;
              return !0;
            })(e, n, t)
          );
        }
        function yl(t, e, n) {
          const o = t.createElement('paragraph');
          t.insert(o, e), xl(t, n, t.createPositionAt(o, 0));
        }
        function xl(t, e, n) {
          e instanceof Ra ? t.setSelection(n) : e.setTo(n);
        }
        const El = ' ,.?!:;"-()';
        function Dl(t, e) {
          const { isForward: n, walker: o, unit: i, schema: r } = t,
            { type: s, item: a, nextPosition: c } = e;
          if ('text' == s)
            return 'word' === t.unit
              ? (function (t, e) {
                  let n = t.position.textNode;
                  if (n) {
                    let o = t.position.offset - n.startOffset;
                    for (; !Bl(n.data, o, e) && !Tl(n, o, e); ) {
                      t.next();
                      const i = e ? t.position.nodeAfter : t.position.nodeBefore;
                      if (i && i.is('$text')) {
                        const o = i.data.charAt(e ? 0 : i.data.length - 1);
                        El.includes(o) || (t.next(), (n = t.position.textNode));
                      }
                      o = t.position.offset - n.startOffset;
                    }
                  }
                  return t.position;
                })(o, n)
              : (function (t, e) {
                  const n = t.position.textNode;
                  if (n) {
                    const o = n.data;
                    let i = t.position.offset - n.startOffset;
                    for (; al(o, i) || ('character' == e && cl(o, i)); )
                      t.next(), (i = t.position.offset - n.startOffset);
                  }
                  return t.position;
                })(o, i);
          if (s == (n ? 'elementStart' : 'elementEnd')) {
            if (r.isSelectable(a)) return ma._createAt(a, n ? 'after' : 'before');
            if (r.checkChild(c, '$text')) return c;
          } else {
            if (r.isLimit(a)) return void o.skip(() => !0);
            if (r.checkChild(c, '$text')) return c;
          }
        }
        function Sl(t, e) {
          const n = t.root,
            o = ma._createAt(n, e ? 'end' : 0);
          return e ? new ba(t, o) : new ba(o, t);
        }
        function Bl(t, e, n) {
          const o = e + (n ? 0 : -1);
          return El.includes(t.charAt(o));
        }
        function Tl(t, e, n) {
          return e === (n ? t.endOffset : 0);
        }
        function Pl(t, e) {
          const n = [];
          Array.from(t.getItems({ direction: 'backward' }))
            .map(t => e.createRangeOn(t))
            .filter(
              e =>
                (e.start.isAfter(t.start) || e.start.isEqual(t.start)) &&
                (e.end.isBefore(t.end) || e.end.isEqual(t.end)),
            )
            .forEach(t => {
              n.push(t.start.parent), e.remove(t);
            }),
            n.forEach(t => {
              let n = t;
              for (; n.parent && n.isEmpty; ) {
                const t = e.createRangeOn(n);
                (n = n.parent), e.remove(t);
              }
            });
        }
        function Il(t) {
          t.document.registerPostFixer(e =>
            (function (t, e) {
              const n = e.document.selection,
                o = e.schema,
                i = [];
              let r = !1;
              for (const t of n.getRanges()) {
                const e = zl(t, o);
                e && !e.isEqual(t) ? (i.push(e), (r = !0)) : i.push(t);
              }
              r &&
                t.setSelection(
                  (function (t) {
                    const e = [];
                    e.push(t.shift());
                    for (const n of t) {
                      const t = e.pop();
                      if (n.isEqual(t)) e.push(t);
                      else if (n.isIntersecting(t)) {
                        const o = t.start.isAfter(n.start) ? n.start : t.start,
                          i = t.end.isAfter(n.end) ? t.end : n.end,
                          r = new ba(o, i);
                        e.push(r);
                      } else e.push(t), e.push(n);
                    }
                    return e;
                  })(i),
                  { backward: n.isBackward },
                );
            })(e, t),
          );
        }
        function zl(t, e) {
          return t.isCollapsed
            ? (function (t, e) {
                const n = t.start,
                  o = e.getNearestSelectionRange(n);
                if (!o) return null;
                if (!o.isCollapsed) return o;
                const i = o.start;
                if (n.isEqual(i)) return null;
                return new ba(i);
              })(t, e)
            : (function (t, e) {
                const { start: n, end: o } = t,
                  i = e.checkChild(n, '$text'),
                  r = e.checkChild(o, '$text'),
                  s = e.getLimitElement(n),
                  a = e.getLimitElement(o);
                if (s === a) {
                  if (i && r) return null;
                  if (
                    (function (t, e, n) {
                      const o = (t.nodeAfter && !n.isLimit(t.nodeAfter)) || n.checkChild(t, '$text'),
                        i = (e.nodeBefore && !n.isLimit(e.nodeBefore)) || n.checkChild(e, '$text');
                      return o || i;
                    })(n, o, e)
                  ) {
                    const t =
                        n.nodeAfter && e.isSelectable(n.nodeAfter) ? null : e.getNearestSelectionRange(n, 'forward'),
                      i =
                        o.nodeBefore && e.isSelectable(o.nodeBefore) ? null : e.getNearestSelectionRange(o, 'backward'),
                      r = t ? t.start : n,
                      s = i ? i.end : o;
                    return new ba(r, s);
                  }
                }
                const c = s && !s.is('rootElement'),
                  l = a && !a.is('rootElement');
                if (c || l) {
                  const t = n.nodeAfter && o.nodeBefore && n.nodeAfter.parent === o.nodeBefore.parent,
                    i = c && (!t || !Rl(n.nodeAfter, e)),
                    r = l && (!t || !Rl(o.nodeBefore, e));
                  let d = n,
                    h = o;
                  return i && (d = ma._createBefore(Fl(s, e))), r && (h = ma._createAfter(Fl(a, e))), new ba(d, h);
                }
                return null;
              })(t, e);
        }
        function Fl(t, e) {
          let n = t,
            o = n;
          for (; e.isLimit(o) && o.parent; ) (n = o), (o = o.parent);
          return n;
        }
        function Rl(t, e) {
          return t && e.isSelectable(t);
        }
        class Ol {
          constructor() {
            (this.markers = new ul()),
              (this.document = new dl(this)),
              (this.schema = new ac()),
              (this._pendingChanges = []),
              (this._currentWriter = null),
              ['insertContent', 'deleteContent', 'modifySelection', 'getSelectedContent', 'applyOperation'].forEach(t =>
                this.decorate(t),
              ),
              this.on(
                'applyOperation',
                (t, e) => {
                  e[0]._validate();
                },
                { priority: 'highest' },
              ),
              this.schema.register('$root', { isLimit: !0 }),
              this.schema.register('$block', { allowIn: '$root', isBlock: !0 }),
              this.schema.register('$text', { allowIn: '$block', isInline: !0, isContent: !0 }),
              this.schema.register('$clipboardHolder', {
                allowContentOf: '$root',
                allowChildren: '$text',
                isLimit: !0,
              }),
              this.schema.register('$documentFragment', {
                allowContentOf: '$root',
                allowChildren: '$text',
                isLimit: !0,
              }),
              this.schema.register('$marker'),
              this.schema.addChildCheck((t, e) => {
                if ('$marker' === e.name) return !0;
              }),
              Il(this),
              this.document.registerPostFixer(Wa);
          }
          change(t) {
            try {
              return 0 === this._pendingChanges.length
                ? (this._pendingChanges.push({ batch: new Bc(), callback: t }), this._runPendingChanges()[0])
                : t(this._currentWriter);
            } catch (t) {
              c.a.rethrowUnexpectedError(t, this);
            }
          }
          enqueueChange(t, e) {
            try {
              'string' == typeof t ? (t = new Bc(t)) : 'function' == typeof t && ((e = t), (t = new Bc())),
                this._pendingChanges.push({ batch: t, callback: e }),
                1 == this._pendingChanges.length && this._runPendingChanges();
            } catch (t) {
              c.a.rethrowUnexpectedError(t, this);
            }
          }
          applyOperation(t) {
            t._execute();
          }
          insertContent(t, e, n) {
            return (function (t, e, n, o) {
              return t.change(i => {
                let r;
                (r = n ? (n instanceof Ea || n instanceof Ra ? n : i.createSelection(n, o)) : t.document.selection),
                  r.isCollapsed || t.deleteContent(r, { doNotAutoparagraph: !0 });
                const s = new wl(t, i, r.anchor);
                let a;
                (a = e.is('documentFragment') ? e.getChildren() : [e]), s.handleNodes(a);
                const c = s.getSelectionRange();
                c && (r instanceof Ra ? i.setSelection(c) : r.setTo(c));
                const l = s.getAffectedRange() || t.createRange(r.anchor);
                return s.destroy(), l;
              });
            })(this, t, e, n);
          }
          deleteContent(t, e) {
            Al(this, t, e);
          }
          modifySelection(t, e) {
            !(function (t, e, n = {}) {
              const o = t.schema,
                i = 'backward' != n.direction,
                r = n.unit ? n.unit : 'character',
                s = e.focus,
                a = new ua({ boundaries: Sl(s, i), singleCharacters: !0, direction: i ? 'forward' : 'backward' }),
                c = { walker: a, schema: o, isForward: i, unit: r };
              let l;
              for (; (l = a.next()); ) {
                if (l.done) return;
                const n = Dl(c, l.value);
                if (n)
                  return void (e instanceof Ra
                    ? t.change(t => {
                        t.setSelectionFocus(n);
                      })
                    : e.setFocus(n));
              }
            })(this, t, e);
          }
          getSelectedContent(t) {
            return (function (t, e) {
              return t.change(t => {
                const n = t.createDocumentFragment(),
                  o = e.getFirstRange();
                if (!o || o.isCollapsed) return n;
                const i = o.start.root,
                  r = o.start.getCommonPath(o.end),
                  s = i.getNodeByPath(r);
                let a;
                a =
                  o.start.parent == o.end.parent
                    ? o
                    : t.createRange(
                        t.createPositionAt(s, o.start.path[r.length]),
                        t.createPositionAt(s, o.end.path[r.length] + 1),
                      );
                const c = a.end.offset - a.start.offset;
                for (const e of a.getItems({ shallow: !0 }))
                  e.is('$textProxy') ? t.appendText(e.data, e.getAttributes(), n) : t.append(t.cloneElement(e, !0), n);
                if (a != o) {
                  const e = o._getTransformedByMove(a.start, t.createPositionAt(n, 0), c)[0],
                    i = t.createRange(t.createPositionAt(n, 0), e.start);
                  Pl(t.createRange(e.end, t.createPositionAt(n, 'end')), t), Pl(i, t);
                }
                return n;
              });
            })(this, t);
          }
          hasContent(t, e = {}) {
            const n = t instanceof ha ? ba._createIn(t) : t;
            if (n.isCollapsed) return !1;
            const { ignoreWhitespaces: o = !1, ignoreMarkers: i = !1 } = e;
            if (!i) for (const t of this.markers.getMarkersIntersectingRange(n)) if (t.affectsData) return !0;
            for (const t of n.getItems())
              if (this.schema.isContent(t)) {
                if (!t.is('$textProxy')) return !0;
                if (!o) return !0;
                if (-1 !== t.data.search(/\S/)) return !0;
              }
            return !1;
          }
          createPositionFromPath(t, e, n) {
            return new ma(t, e, n);
          }
          createPositionAt(t, e) {
            return ma._createAt(t, e);
          }
          createPositionAfter(t) {
            return ma._createAfter(t);
          }
          createPositionBefore(t) {
            return ma._createBefore(t);
          }
          createRange(t, e) {
            return new ba(t, e);
          }
          createRangeIn(t) {
            return ba._createIn(t);
          }
          createRangeOn(t) {
            return ba._createOn(t);
          }
          createSelection(t, e, n) {
            return new Ea(t, e, n);
          }
          createBatch(t) {
            return new Bc(t);
          }
          createOperationFromJSON(t) {
            return class {
              static fromJSON(t, e) {
                return gl[t.__className].fromJSON(t, e);
              }
            }.fromJSON(t, this.document);
          }
          destroy() {
            this.document.destroy(), this.stopListening();
          }
          _runPendingChanges() {
            const t = [];
            for (this.fire('_beforeChanges'); this._pendingChanges.length; ) {
              const e = this._pendingChanges[0].batch;
              this._currentWriter = new Yc(this, e);
              const n = this._pendingChanges[0].callback(this._currentWriter);
              t.push(n),
                this.document._handleChangeBlock(this._currentWriter),
                this._pendingChanges.shift(),
                (this._currentWriter = null);
            }
            return this.fire('_afterChanges'), t;
          }
        }
        Yt(Ol, jt);
        class Ml extends Us {
          constructor(t) {
            super(), (this.editor = t);
          }
          set(t, e, n = {}) {
            if ('string' == typeof e) {
              const t = e;
              e = (e, n) => {
                this.editor.execute(t), n();
              };
            }
            super.set(t, e, n);
          }
        }
        class Nl {
          constructor(t = {}) {
            (this._context = t.context || new fo({ language: t.language })), this._context._addEditor(this, !t.context);
            const e = Array.from(this.constructor.builtinPlugins || []);
            (this.config = new io(t, this.constructor.defaultConfig)),
              this.config.define('plugins', e),
              this.config.define(this._context._getEditorConfig()),
              (this.plugins = new lo(this, e, this._context.plugins)),
              (this.locale = this._context.locale),
              (this.t = this.locale.t),
              (this.commands = new ic()),
              this.set('state', 'initializing'),
              this.once('ready', () => (this.state = 'ready'), { priority: 'high' }),
              this.once('destroy', () => (this.state = 'destroyed'), { priority: 'high' }),
              this.set('isReadOnly', !1),
              (this.model = new Ol());
            const n = new si();
            (this.data = new xc(this.model, n)),
              (this.editing = new oc(this.model, n)),
              this.editing.view.document.bind('isReadOnly').to(this),
              (this.conversion = new Ec(
                [this.editing.downcastDispatcher, this.data.downcastDispatcher],
                this.data.upcastDispatcher,
              )),
              this.conversion.addAlias('dataDowncast', this.data.downcastDispatcher),
              this.conversion.addAlias('editingDowncast', this.editing.downcastDispatcher),
              (this.keystrokes = new Ml(this)),
              this.keystrokes.listenTo(this.editing.view.document);
          }
          initPlugins() {
            const t = this.config,
              e = t.get('plugins'),
              n = t.get('removePlugins') || [],
              o = t.get('extraPlugins') || [],
              i = t.get('substitutePlugins') || [];
            return this.plugins.init(e.concat(o), n, i);
          }
          destroy() {
            let t = Promise.resolve();
            return (
              'initializing' == this.state && (t = new Promise(t => this.once('ready', t))),
              t
                .then(() => {
                  this.fire('destroy'), this.stopListening(), this.commands.destroy();
                })
                .then(() => this.plugins.destroy())
                .then(() => {
                  this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy();
                })
                .then(() => this._context._removeEditor(this))
            );
          }
          execute(...t) {
            try {
              return this.commands.execute(...t);
            } catch (t) {
              c.a.rethrowUnexpectedError(t, this);
            }
          }
          focus() {
            this.editing.view.focus();
          }
        }
        Yt(Nl, jt);
        class Vl {
          constructor(t) {
            (this.editor = t), (this._components = new Map());
          }
          *names() {
            for (const t of this._components.values()) yield t.originalName;
          }
          add(t, e) {
            this._components.set(Ll(t), { callback: e, originalName: t });
          }
          create(t) {
            if (!this.has(t)) throw new c.a('componentfactory-item-missing', this, { name: t });
            return this._components.get(Ll(t)).callback(this.editor.locale);
          }
          has(t) {
            return this._components.has(Ll(t));
          }
        }
        function Ll(t) {
          return String(t).toLowerCase();
        }
        class Kl {
          constructor(t) {
            (this.editor = t),
              (this.componentFactory = new Vl(t)),
              (this.focusTracker = new Ws()),
              (this._editableElementsMap = new Map()),
              this.listenTo(t.editing.view.document, 'layoutChanged', () => this.update());
          }
          get element() {
            return null;
          }
          update() {
            this.fire('update');
          }
          destroy() {
            this.stopListening(), this.focusTracker.destroy();
            for (const t of this._editableElementsMap.values()) t.ckeditorInstance = null;
            this._editableElementsMap = new Map();
          }
          setEditableElement(t, e) {
            this._editableElementsMap.set(t, e), e.ckeditorInstance || (e.ckeditorInstance = this.editor);
          }
          getEditableElement(t = 'main') {
            return this._editableElementsMap.get(t);
          }
          getEditableElementsNames() {
            return this._editableElementsMap.keys();
          }
          get _editableElements() {
            return (
              console.warn(
                'editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.',
                { editorUI: this },
              ),
              this._editableElementsMap
            );
          }
        }
        Yt(Kl, h);
        var ql = {
          setData(t) {
            this.data.set(t);
          },
          getData(t) {
            return this.data.get(t);
          },
        };
        class Hl extends ko {
          static get pluginName() {
            return 'PendingActions';
          }
          init() {
            this.set('hasAny', !1),
              (this._actions = new co({ idProperty: '_id' })),
              this._actions.delegate('add', 'remove').to(this);
          }
          add(t) {
            if ('string' != typeof t) throw new c.a('pendingactions-add-invalid-message', this);
            const e = Object.create(jt);
            return e.set('message', t), this._actions.add(e), (this.hasAny = !0), e;
          }
          remove(t) {
            this._actions.remove(t), (this.hasAny = !!this._actions.length);
          }
          get first() {
            return this._actions.get(0);
          }
          [Symbol.iterator]() {
            return this._actions[Symbol.iterator]();
          }
        }
        const jl =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>',
          $l =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>',
          Gl =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>',
          Wl =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>',
          Ul =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>',
          Jl =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
          Yl =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>',
          Ql =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>',
          Xl =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
          Zl =
            '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>',
          td =
            '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>',
          ed =
            '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>',
          nd =
            '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>',
          od =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>',
          id =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>',
          rd =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';
        function sd({ emitter: t, activator: e, callback: n, contextElements: o }) {
          t.listenTo(document, 'mousedown', (t, i) => {
            if (!e()) return;
            const r = 'function' == typeof i.composedPath ? i.composedPath() : [];
            for (const t of o) if (t.contains(i.target) || r.includes(t)) return;
            n();
          });
        }
        function ad(t) {
          t.set('_isCssTransitionsDisabled', !1),
            (t.disableCssTransitions = () => {
              t._isCssTransitionsDisabled = !0;
            }),
            (t.enableCssTransitions = () => {
              t._isCssTransitionsDisabled = !1;
            }),
            t.extendTemplate({
              attributes: { class: [t.bindTemplate.if('_isCssTransitionsDisabled', 'ck-transitions-disabled')] },
            });
        }
        function cd({ view: t }) {
          t.listenTo(
            t.element,
            'submit',
            (e, n) => {
              n.preventDefault(), t.fire('submit');
            },
            { useCapture: !0 },
          );
        }
        class ld extends co {
          constructor(t = []) {
            super(t, { idProperty: 'viewUid' }),
              this.on('add', (t, e, n) => {
                this._renderViewIntoCollectionParent(e, n);
              }),
              this.on('remove', (t, e) => {
                e.element && this._parentElement && e.element.remove();
              }),
              (this._parentElement = null);
          }
          destroy() {
            this.map(t => t.destroy());
          }
          setParent(t) {
            this._parentElement = t;
            for (const t of this) this._renderViewIntoCollectionParent(t);
          }
          delegate(...t) {
            if (!t.length || !t.every(t => 'string' == typeof t))
              throw new c.a('ui-viewcollection-delegate-wrong-events', this);
            return {
              to: e => {
                for (const n of this) for (const o of t) n.delegate(o).to(e);
                this.on('add', (n, o) => {
                  for (const n of t) o.delegate(n).to(e);
                }),
                  this.on('remove', (n, o) => {
                    for (const n of t) o.stopDelegating(n, e);
                  });
              },
            };
          }
          _renderViewIntoCollectionParent(t, e) {
            t.isRendered || t.render(),
              t.element &&
                this._parentElement &&
                this._parentElement.insertBefore(t.element, this._parentElement.children[e]);
          }
        }
        var dd = n(1),
          hd = n.n(dd),
          ud = n(12),
          pd = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(ud.a, pd), ud.a.locals;
        class md {
          constructor(t) {
            (this.element = null),
              (this.isRendered = !1),
              (this.locale = t),
              (this.t = t && t.t),
              (this._viewCollections = new co()),
              (this._unboundChildren = this.createCollection()),
              this._viewCollections.on('add', (e, n) => {
                n.locale = t;
              }),
              this.decorate('render');
          }
          get bindTemplate() {
            return this._bindTemplate ? this._bindTemplate : (this._bindTemplate = gd.bind(this, this));
          }
          createCollection(t) {
            const e = new ld(t);
            return this._viewCollections.add(e), e;
          }
          registerChild(t) {
            ao(t) || (t = [t]);
            for (const e of t) this._unboundChildren.add(e);
          }
          deregisterChild(t) {
            ao(t) || (t = [t]);
            for (const e of t) this._unboundChildren.remove(e);
          }
          setTemplate(t) {
            this.template = new gd(t);
          }
          extendTemplate(t) {
            gd.extend(this.template, t);
          }
          render() {
            if (this.isRendered) throw new c.a('ui-view-render-already-rendered', this);
            this.template && ((this.element = this.template.render()), this.registerChild(this.template.getViews())),
              (this.isRendered = !0);
          }
          destroy() {
            this.stopListening(),
              this._viewCollections.map(t => t.destroy()),
              this.template && this.template._revertData && this.template.revert(this.element);
          }
        }
        Yt(md, Kr), Yt(md, jt);
        class gd {
          constructor(t) {
            Object.assign(this, xd(yd(t))), (this._isRendered = !1), (this._revertData = null);
          }
          render() {
            const t = this._renderNode({ intoFragment: !0 });
            return (this._isRendered = !0), t;
          }
          apply(t) {
            return (
              (this._revertData = { children: [], bindings: [], attributes: {} }),
              this._renderNode({ node: t, isApplying: !0, revertData: this._revertData }),
              t
            );
          }
          revert(t) {
            if (!this._revertData) throw new c.a('ui-template-revert-not-applied', [this, t]);
            this._revertTemplateFromNode(t, this._revertData);
          }
          *getViews() {
            yield* (function* t(e) {
              if (e.children) for (const n of e.children) Pd(n) ? yield n : Id(n) && (yield* t(n));
            })(this);
          }
          static bind(t, e) {
            return {
              to: (n, o) => new kd({ eventNameOrFunction: n, attribute: n, observable: t, emitter: e, callback: o }),
              if: (n, o, i) => new bd({ observable: t, emitter: e, attribute: n, valueIfTrue: o, callback: i }),
            };
          }
          static extend(t, e) {
            if (t._isRendered) throw new c.a('template-extend-render', [this, t]);
            Bd(t, xd(yd(e)));
          }
          _renderNode(t) {
            let e;
            if (((e = t.node ? this.tag && this.text : this.tag ? this.text : !this.text), e))
              throw new c.a('ui-template-wrong-syntax', this);
            return this.text ? this._renderText(t) : this._renderElement(t);
          }
          _renderElement(t) {
            let e = t.node;
            return (
              e || (e = t.node = document.createElementNS(this.ns || 'http://www.w3.org/1999/xhtml', this.tag)),
              this._renderAttributes(t),
              this._renderElementChildren(t),
              this._setUpListeners(t),
              e
            );
          }
          _renderText(t) {
            let e = t.node;
            return (
              e ? (t.revertData.text = e.textContent) : (e = t.node = document.createTextNode('')),
              wd(this.text)
                ? this._bindToObservable({ schema: this.text, updater: _d(e), data: t })
                : (e.textContent = this.text.join('')),
              e
            );
          }
          _renderAttributes(t) {
            let e, n, o, i;
            if (!this.attributes) return;
            const r = t.node,
              s = t.revertData;
            for (e in this.attributes)
              if (
                ((o = r.getAttribute(e)),
                (n = this.attributes[e]),
                s && (s.attributes[e] = o),
                (i = w(n[0]) && n[0].ns ? n[0].ns : null),
                wd(n))
              ) {
                const a = i ? n[0].value : n;
                s && Fd(e) && a.unshift(o), this._bindToObservable({ schema: a, updater: Cd(r, e, i), data: t });
              } else
                'style' == e && 'string' != typeof n[0]
                  ? this._renderStyleAttribute(n[0], t)
                  : (s && o && Fd(e) && n.unshift(o),
                    (n = n
                      .map(t => (t && t.value) || t)
                      .reduce((t, e) => t.concat(e), [])
                      .reduce(Dd, '')),
                    Td(n) || r.setAttributeNS(i, e, n));
          }
          _renderStyleAttribute(t, e) {
            const n = e.node;
            for (const o in t) {
              const i = t[o];
              wd(i) ? this._bindToObservable({ schema: [i], updater: vd(n, o), data: e }) : (n.style[o] = i);
            }
          }
          _renderElementChildren(t) {
            const e = t.node,
              n = t.intoFragment ? document.createDocumentFragment() : e,
              o = t.isApplying;
            let i = 0;
            for (const r of this.children)
              if (zd(r)) {
                if (!o) {
                  r.setParent(e);
                  for (const t of r) n.appendChild(t.element);
                }
              } else if (Pd(r)) o || (r.isRendered || r.render(), n.appendChild(r.element));
              else if (xr(r)) n.appendChild(r);
              else if (o) {
                const e = { children: [], bindings: [], attributes: {} };
                t.revertData.children.push(e),
                  r._renderNode({ node: n.childNodes[i++], isApplying: !0, revertData: e });
              } else n.appendChild(r.render());
            t.intoFragment && e.appendChild(n);
          }
          _setUpListeners(t) {
            if (this.eventListeners)
              for (const e in this.eventListeners) {
                const n = this.eventListeners[e].map(n => {
                  const [o, i] = e.split('@');
                  return n.activateDomEventListener(o, i, t);
                });
                t.revertData && t.revertData.bindings.push(n);
              }
          }
          _bindToObservable({ schema: t, updater: e, data: n }) {
            const o = n.revertData;
            Ad(t, e, n);
            const i = t
              .filter(t => !Td(t))
              .filter(t => t.observable)
              .map(o => o.activateAttributeListener(t, e, n));
            o && o.bindings.push(i);
          }
          _revertTemplateFromNode(t, e) {
            for (const t of e.bindings) for (const e of t) e();
            if (e.text) t.textContent = e.text;
            else {
              for (const n in e.attributes) {
                const o = e.attributes[n];
                null === o ? t.removeAttribute(n) : t.setAttribute(n, o);
              }
              for (let n = 0; n < e.children.length; ++n) this._revertTemplateFromNode(t.childNodes[n], e.children[n]);
            }
          }
        }
        Yt(gd, h);
        class fd {
          constructor(t) {
            Object.assign(this, t);
          }
          getValue(t) {
            const e = this.observable[this.attribute];
            return this.callback ? this.callback(e, t) : e;
          }
          activateAttributeListener(t, e, n) {
            const o = () => Ad(t, e, n);
            return (
              this.emitter.listenTo(this.observable, 'change:' + this.attribute, o),
              () => {
                this.emitter.stopListening(this.observable, 'change:' + this.attribute, o);
              }
            );
          }
        }
        class kd extends fd {
          activateDomEventListener(t, e, n) {
            const o = (t, n) => {
              (e && !n.target.matches(e)) ||
                ('function' == typeof this.eventNameOrFunction
                  ? this.eventNameOrFunction(n)
                  : this.observable.fire(this.eventNameOrFunction, n));
            };
            return (
              this.emitter.listenTo(n.node, t, o),
              () => {
                this.emitter.stopListening(n.node, t, o);
              }
            );
          }
        }
        class bd extends fd {
          getValue(t) {
            return !Td(super.getValue(t)) && (this.valueIfTrue || !0);
          }
        }
        function wd(t) {
          return !!t && (t.value && (t = t.value), Array.isArray(t) ? t.some(wd) : t instanceof fd);
        }
        function Ad(t, e, { node: n }) {
          let o = (function (t, e) {
            return t.map(t => (t instanceof fd ? t.getValue(e) : t));
          })(t, n);
          (o = 1 == t.length && t[0] instanceof bd ? o[0] : o.reduce(Dd, '')), Td(o) ? e.remove() : e.set(o);
        }
        function _d(t) {
          return {
            set(e) {
              t.textContent = e;
            },
            remove() {
              t.textContent = '';
            },
          };
        }
        function Cd(t, e, n) {
          return {
            set(o) {
              t.setAttributeNS(n, e, o);
            },
            remove() {
              t.removeAttributeNS(n, e);
            },
          };
        }
        function vd(t, e) {
          return {
            set(n) {
              t.style[e] = n;
            },
            remove() {
              t.style[e] = null;
            },
          };
        }
        function yd(t) {
          return no(t, t => {
            if (t && (t instanceof fd || Id(t) || Pd(t) || zd(t))) return t;
          });
        }
        function xd(t) {
          if (
            ('string' == typeof t
              ? (t = (function (t) {
                  return { text: [t] };
                })(t))
              : t.text &&
                (function (t) {
                  t.text = ho(t.text);
                })(t),
            t.on &&
              ((t.eventListeners = (function (t) {
                for (const e in t) Ed(t, e);
                return t;
              })(t.on)),
              delete t.on),
            !t.text)
          ) {
            t.attributes &&
              (function (t) {
                for (const e in t) t[e].value && (t[e].value = ho(t[e].value)), Ed(t, e);
              })(t.attributes);
            const e = [];
            if (t.children)
              if (zd(t.children)) e.push(t.children);
              else for (const n of t.children) Id(n) || Pd(n) || xr(n) ? e.push(n) : e.push(new gd(n));
            t.children = e;
          }
          return t;
        }
        function Ed(t, e) {
          t[e] = ho(t[e]);
        }
        function Dd(t, e) {
          return Td(e) ? t : Td(t) ? e : `${t} ${e}`;
        }
        function Sd(t, e) {
          for (const n in e) t[n] ? t[n].push(...e[n]) : (t[n] = e[n]);
        }
        function Bd(t, e) {
          if (
            (e.attributes && (t.attributes || (t.attributes = {}), Sd(t.attributes, e.attributes)),
            e.eventListeners && (t.eventListeners || (t.eventListeners = {}), Sd(t.eventListeners, e.eventListeners)),
            e.text && t.text.push(...e.text),
            e.children && e.children.length)
          ) {
            if (t.children.length != e.children.length) throw new c.a('ui-template-extend-children-mismatch', t);
            let n = 0;
            for (const o of e.children) Bd(t.children[n++], o);
          }
        }
        function Td(t) {
          return !t && 0 !== t;
        }
        function Pd(t) {
          return t instanceof md;
        }
        function Id(t) {
          return t instanceof gd;
        }
        function zd(t) {
          return t instanceof ld;
        }
        function Fd(t) {
          return 'class' == t || 'style' == t;
        }
        class Rd extends ld {
          constructor(t, e = []) {
            super(e), (this.locale = t);
          }
          attachToDom() {
            this._bodyCollectionContainer = new gd({
              tag: 'div',
              attributes: {
                class: ['ck', 'ck-reset_all', 'ck-body', 'ck-rounded-corners'],
                dir: this.locale.uiLanguageDirection,
              },
              children: this,
            }).render();
            let t = document.querySelector('.ck-body-wrapper');
            t || ((t = Rs(document, 'div', { class: 'ck-body-wrapper' })), document.body.appendChild(t)),
              t.appendChild(this._bodyCollectionContainer);
          }
          detachFromDom() {
            super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
            const t = document.querySelector('.ck-body-wrapper');
            t && 0 == t.childElementCount && t.remove();
          }
        }
        var Od = n(13),
          Md = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Od.a, Md), Od.a.locals;
        class Nd extends md {
          constructor() {
            super();
            const t = this.bindTemplate;
            this.set('content', ''),
              this.set('viewBox', '0 0 20 20'),
              this.set('fillColor', ''),
              this.setTemplate({
                tag: 'svg',
                ns: 'http://www.w3.org/2000/svg',
                attributes: { class: ['ck', 'ck-icon'], viewBox: t.to('viewBox') },
              });
          }
          render() {
            super.render(),
              this._updateXMLContent(),
              this._colorFillPaths(),
              this.on('change:content', () => {
                this._updateXMLContent(), this._colorFillPaths();
              }),
              this.on('change:fillColor', () => {
                this._colorFillPaths();
              });
          }
          _updateXMLContent() {
            if (this.content) {
              const t = new DOMParser().parseFromString(this.content.trim(), 'image/svg+xml').querySelector('svg'),
                e = t.getAttribute('viewBox');
              for (e && (this.viewBox = e), this.element.innerHTML = ''; t.childNodes.length > 0; )
                this.element.appendChild(t.childNodes[0]);
            }
          }
          _colorFillPaths() {
            this.fillColor &&
              this.element.querySelectorAll('.ck-icon__fill').forEach(t => {
                t.style.fill = this.fillColor;
              });
          }
        }
        var Vd = n(14),
          Ld = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Vd.a, Ld), Vd.a.locals;
        class Kd extends md {
          constructor(t) {
            super(t), this.set('text', ''), this.set('position', 's');
            const e = this.bindTemplate;
            this.setTemplate({
              tag: 'span',
              attributes: {
                class: [
                  'ck',
                  'ck-tooltip',
                  e.to('position', t => 'ck-tooltip_' + t),
                  e.if('text', 'ck-hidden', t => !t.trim()),
                ],
              },
              children: [
                { tag: 'span', attributes: { class: ['ck', 'ck-tooltip__text'] }, children: [{ text: e.to('text') }] },
              ],
            });
          }
        }
        var qd = n(15),
          Hd = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(qd.a, Hd), qd.a.locals;
        class jd extends md {
          constructor(t) {
            super(t);
            const e = this.bindTemplate,
              n = s();
            this.set('class'),
              this.set('labelStyle'),
              this.set('icon'),
              this.set('isEnabled', !0),
              this.set('isOn', !1),
              this.set('isVisible', !0),
              this.set('isToggleable', !1),
              this.set('keystroke'),
              this.set('label'),
              this.set('tabindex', -1),
              this.set('tooltip'),
              this.set('tooltipPosition', 's'),
              this.set('type', 'button'),
              this.set('withText', !1),
              this.set('withKeystroke', !1),
              (this.children = this.createCollection()),
              (this.tooltipView = this._createTooltipView()),
              (this.labelView = this._createLabelView(n)),
              (this.iconView = new Nd()),
              this.iconView.extendTemplate({ attributes: { class: 'ck-button__icon' } }),
              (this.keystrokeView = this._createKeystrokeView()),
              this.bind('_tooltipString').to(
                this,
                'tooltip',
                this,
                'label',
                this,
                'keystroke',
                this._getTooltipString.bind(this),
              ),
              this.setTemplate({
                tag: 'button',
                attributes: {
                  class: [
                    'ck',
                    'ck-button',
                    e.to('class'),
                    e.if('isEnabled', 'ck-disabled', t => !t),
                    e.if('isVisible', 'ck-hidden', t => !t),
                    e.to('isOn', t => (t ? 'ck-on' : 'ck-off')),
                    e.if('withText', 'ck-button_with-text'),
                    e.if('withKeystroke', 'ck-button_with-keystroke'),
                  ],
                  type: e.to('type', t => t || 'button'),
                  tabindex: e.to('tabindex'),
                  'aria-labelledby': `ck-editor__aria-label_${n}`,
                  'aria-disabled': e.if('isEnabled', !0, t => !t),
                  'aria-pressed': e.to('isOn', t => !!this.isToggleable && String(t)),
                },
                children: this.children,
                on: {
                  mousedown: e.to(t => {
                    t.preventDefault();
                  }),
                  click: e.to(t => {
                    this.isEnabled ? this.fire('execute') : t.preventDefault();
                  }),
                },
              });
          }
          render() {
            super.render(),
              this.icon && (this.iconView.bind('content').to(this, 'icon'), this.children.add(this.iconView)),
              this.children.add(this.tooltipView),
              this.children.add(this.labelView),
              this.withKeystroke && this.children.add(this.keystrokeView);
          }
          focus() {
            this.element.focus();
          }
          _createTooltipView() {
            const t = new Kd();
            return t.bind('text').to(this, '_tooltipString'), t.bind('position').to(this, 'tooltipPosition'), t;
          }
          _createLabelView(t) {
            const e = new md(),
              n = this.bindTemplate;
            return (
              e.setTemplate({
                tag: 'span',
                attributes: {
                  class: ['ck', 'ck-button__label'],
                  style: n.to('labelStyle'),
                  id: `ck-editor__aria-label_${t}`,
                },
                children: [{ text: this.bindTemplate.to('label') }],
              }),
              e
            );
          }
          _createKeystrokeView() {
            const t = new md();
            return (
              t.setTemplate({
                tag: 'span',
                attributes: { class: ['ck', 'ck-button__keystroke'] },
                children: [{ text: this.bindTemplate.to('keystroke', t => ji(t)) }],
              }),
              t
            );
          }
          _getTooltipString(t, e, n) {
            return t
              ? 'string' == typeof t
                ? t
                : (n && (n = ji(n)), t instanceof Function ? t(e, n) : `${e}${n ? ` (${n})` : ''}`)
              : '';
          }
        }
        var $d = n(16),
          Gd = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()($d.a, Gd), $d.a.locals;
        class Wd extends jd {
          constructor(t) {
            super(t),
              (this.isToggleable = !0),
              (this.toggleSwitchView = this._createToggleView()),
              this.extendTemplate({ attributes: { class: 'ck-switchbutton' } });
          }
          render() {
            super.render(), this.children.add(this.toggleSwitchView);
          }
          _createToggleView() {
            const t = new md();
            return (
              t.setTemplate({
                tag: 'span',
                attributes: { class: ['ck', 'ck-button__toggle'] },
                children: [{ tag: 'span', attributes: { class: ['ck', 'ck-button__toggle__inner'] } }],
              }),
              t
            );
          }
        }
        function Ud(t) {
          return 'string' == typeof t
            ? { model: t, label: t, hasBorder: !1, view: { name: 'span', styles: { color: t } } }
            : {
                model: t.color,
                label: t.label || t.color,
                hasBorder: void 0 !== t.hasBorder && t.hasBorder,
                view: { name: 'span', styles: { color: `${t.color}` } },
              };
        }
        class Jd extends jd {
          constructor(t) {
            super(t);
            const e = this.bindTemplate;
            this.set('color'),
              this.set('hasBorder'),
              (this.icon =
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>'),
              this.extendTemplate({
                attributes: {
                  style: { backgroundColor: e.to('color') },
                  class: ['ck', 'ck-color-grid__tile', e.if('hasBorder', 'ck-color-table__color-tile_bordered')],
                },
              });
          }
          render() {
            super.render(), (this.iconView.fillColor = 'hsl(0, 0%, 100%)');
          }
        }
        class Yd {
          constructor(t) {
            if ((Object.assign(this, t), t.actions && t.keystrokeHandler))
              for (const e in t.actions) {
                let n = t.actions[e];
                'string' == typeof n && (n = [n]);
                for (const o of n)
                  t.keystrokeHandler.set(o, (t, n) => {
                    this[e](), n();
                  });
              }
          }
          get first() {
            return this.focusables.find(Qd) || null;
          }
          get last() {
            return this.focusables.filter(Qd).slice(-1)[0] || null;
          }
          get next() {
            return this._getFocusableItem(1);
          }
          get previous() {
            return this._getFocusableItem(-1);
          }
          get current() {
            let t = null;
            return null === this.focusTracker.focusedElement
              ? null
              : (this.focusables.find((e, n) => {
                  const o = e.element === this.focusTracker.focusedElement;
                  return o && (t = n), o;
                }),
                t);
          }
          focusFirst() {
            this._focus(this.first);
          }
          focusLast() {
            this._focus(this.last);
          }
          focusNext() {
            this._focus(this.next);
          }
          focusPrevious() {
            this._focus(this.previous);
          }
          _focus(t) {
            t && t.focus();
          }
          _getFocusableItem(t) {
            const e = this.current,
              n = this.focusables.length;
            if (!n) return null;
            if (null === e) return this[1 === t ? 'first' : 'last'];
            let o = (e + n + t) % n;
            do {
              const e = this.focusables.get(o);
              if (Qd(e)) return e;
              o = (o + n + t) % n;
            } while (o !== e);
            return null;
          }
        }
        function Qd(t) {
          return !(!t.focus || 'none' == Tr.window.getComputedStyle(t.element).display);
        }
        var Xd = n(17),
          Zd = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Xd.a, Zd), Xd.a.locals;
        class th extends md {
          constructor(t, e) {
            super(t);
            const n = (e && e.colorDefinitions) || [],
              o = {};
            e && e.columns && (o.gridTemplateColumns = `repeat( ${e.columns}, 1fr)`),
              this.set('selectedColor'),
              (this.items = this.createCollection()),
              (this.focusTracker = new Ws()),
              (this.keystrokes = new Us()),
              (this._focusCycler = new Yd({
                focusables: this.items,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: { focusPrevious: 'arrowleft', focusNext: 'arrowright' },
              })),
              this.items.on('add', (t, e) => {
                e.isOn = e.color === this.selectedColor;
              }),
              n.forEach(t => {
                const e = new Jd();
                e.set({ color: t.color, label: t.label, tooltip: !0, hasBorder: t.options.hasBorder }),
                  e.on('execute', () => {
                    this.fire('execute', { value: t.color, hasBorder: t.options.hasBorder, label: t.label });
                  }),
                  this.items.add(e);
              }),
              this.setTemplate({
                tag: 'div',
                children: this.items,
                attributes: { class: ['ck', 'ck-color-grid'], style: o },
              }),
              this.on('change:selectedColor', (t, e, n) => {
                for (const t of this.items) t.isOn = t.color === n;
              });
          }
          focus() {
            this.items.length && this.items.first.focus();
          }
          focusLast() {
            this.items.length && this.items.last.focus();
          }
          render() {
            super.render();
            for (const t of this.items) this.focusTracker.add(t.element);
            this.items.on('add', (t, e) => {
              this.focusTracker.add(e.element);
            }),
              this.items.on('remove', (t, e) => {
                this.focusTracker.remove(e.element);
              }),
              this.keystrokes.listenTo(this.element);
          }
        }
        var eh =
          '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
        class nh extends jd {
          constructor(t) {
            super(t),
              (this.arrowView = this._createArrowView()),
              this.extendTemplate({ attributes: { 'aria-haspopup': !0 } }),
              this.delegate('execute').to(this, 'open');
          }
          render() {
            super.render(), this.children.add(this.arrowView);
          }
          _createArrowView() {
            const t = new Nd();
            return (t.content = eh), t.extendTemplate({ attributes: { class: 'ck-dropdown__arrow' } }), t;
          }
        }
        var oh = n(18),
          ih = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(oh.a, ih), oh.a.locals;
        class rh extends md {
          constructor(t) {
            super(t);
            const e = this.bindTemplate;
            this.set('icon'),
              this.set('isEnabled', !0),
              this.set('isOn', !1),
              this.set('isToggleable', !1),
              this.set('isVisible', !0),
              this.set('keystroke'),
              this.set('label'),
              this.set('tabindex', -1),
              this.set('tooltip'),
              this.set('tooltipPosition', 's'),
              this.set('type', 'button'),
              this.set('withText', !1),
              (this.children = this.createCollection()),
              (this.actionView = this._createActionView()),
              (this.arrowView = this._createArrowView()),
              (this.keystrokes = new Us()),
              (this.focusTracker = new Ws()),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: [
                    'ck',
                    'ck-splitbutton',
                    e.if('isVisible', 'ck-hidden', t => !t),
                    this.arrowView.bindTemplate.if('isOn', 'ck-splitbutton_open'),
                  ],
                },
                children: this.children,
              });
          }
          render() {
            super.render(),
              this.children.add(this.actionView),
              this.children.add(this.arrowView),
              this.focusTracker.add(this.actionView.element),
              this.focusTracker.add(this.arrowView.element),
              this.keystrokes.listenTo(this.element),
              this.keystrokes.set('arrowright', (t, e) => {
                this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), e());
              }),
              this.keystrokes.set('arrowleft', (t, e) => {
                this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), e());
              });
          }
          focus() {
            this.actionView.focus();
          }
          _createActionView() {
            const t = new jd();
            return (
              t
                .bind(
                  'icon',
                  'isEnabled',
                  'isOn',
                  'isToggleable',
                  'keystroke',
                  'label',
                  'tabindex',
                  'tooltip',
                  'tooltipPosition',
                  'type',
                  'withText',
                )
                .to(this),
              t.extendTemplate({ attributes: { class: 'ck-splitbutton__action' } }),
              t.delegate('execute').to(this),
              t
            );
          }
          _createArrowView() {
            const t = new jd(),
              e = t.bindTemplate;
            return (
              (t.icon = eh),
              t.extendTemplate({
                attributes: {
                  class: 'ck-splitbutton__arrow',
                  'aria-haspopup': !0,
                  'aria-expanded': e.to('isOn', t => String(t)),
                },
              }),
              t.bind('isEnabled').to(this),
              t.delegate('execute').to(this, 'open'),
              t
            );
          }
        }
        class sh extends md {
          constructor(t) {
            super(t);
            const e = this.bindTemplate;
            this.set('isVisible', !1),
              this.set('position', 'se'),
              (this.children = this.createCollection()),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: [
                    'ck',
                    'ck-reset',
                    'ck-dropdown__panel',
                    e.to('position', t => `ck-dropdown__panel_${t}`),
                    e.if('isVisible', 'ck-dropdown__panel-visible'),
                  ],
                },
                children: this.children,
                on: { selectstart: e.to(t => t.preventDefault()) },
              });
          }
          focus() {
            this.children.length && this.children.first.focus();
          }
          focusLast() {
            if (this.children.length) {
              const t = this.children.last;
              'function' == typeof t.focusLast ? t.focusLast() : t.focus();
            }
          }
        }
        var ah = n(19),
          ch = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(ah.a, ch), ah.a.locals;
        function lh({ element: t, target: e, positions: n, limiter: o, fitInViewport: i }) {
          I(e) && (e = e()), I(o) && (o = o());
          const r = (function (t) {
              return t && t.parentNode ? (t.offsetParent === Tr.document.body ? null : t.offsetParent) : null;
            })(t),
            s = new Vs(t),
            a = new Vs(e);
          let c, l;
          if (o || i) {
            const t = (function (t, e) {
              const { elementRect: n, viewportRect: o } = e,
                i = n.getArea(),
                r = (function (t, { targetRect: e, elementRect: n, limiterRect: o, viewportRect: i }) {
                  const r = [],
                    s = n.getArea();
                  for (const a of t) {
                    const t = dh(a, e, n);
                    if (!t) continue;
                    const [c, l] = t;
                    let d = 0,
                      h = 0;
                    if (o)
                      if (i) {
                        const t = o.getIntersection(i);
                        t && (d = t.getIntersectionArea(l));
                      } else d = o.getIntersectionArea(l);
                    i && (h = i.getIntersectionArea(l));
                    const u = { positionName: c, positionRect: l, limiterIntersectArea: d, viewportIntersectArea: h };
                    if (d === s) return [u];
                    r.push(u);
                  }
                  return r;
                })(t, e);
              if (o) {
                const t = hh(
                  r.filter(({ viewportIntersectArea: t }) => t === i),
                  i,
                );
                if (t) return t;
              }
              return hh(r, i);
            })(n, {
              targetRect: a,
              elementRect: s,
              limiterRect: o && new Vs(o).getVisible(),
              viewportRect: i && new Vs(Tr.window),
            });
            [l, c] = t || dh(n[0], a, s);
          } else [l, c] = dh(n[0], a, s);
          let d = uh(c);
          return (
            r &&
              (d = (function ({ left: t, top: e }, n) {
                const o = uh(new Vs(n)),
                  i = Ms(n);
                return (
                  (t -= o.left),
                  (e -= o.top),
                  (t += n.scrollLeft),
                  (e += n.scrollTop),
                  (t -= i.left),
                  (e -= i.top),
                  { left: t, top: e }
                );
              })(d, r)),
            { left: d.left, top: d.top, name: l }
          );
        }
        function dh(t, e, n) {
          const o = t(e, n);
          if (!o) return null;
          const { left: i, top: r, name: s } = o;
          return [s, n.clone().moveTo(i, r)];
        }
        function hh(t, e) {
          let n,
            o,
            i = 0;
          for (const { positionName: r, positionRect: s, limiterIntersectArea: a, viewportIntersectArea: c } of t) {
            if (a === e) return [r, s];
            const t = c ** 2 + a ** 2;
            t > i && ((i = t), (n = s), (o = r));
          }
          return n ? [o, n] : null;
        }
        function uh({ left: t, top: e }) {
          const { scrollX: n, scrollY: o } = Tr.window;
          return { left: t + n, top: e + o };
        }
        class ph extends md {
          constructor(t, e, n) {
            super(t);
            const o = this.bindTemplate;
            (this.buttonView = e),
              (this.panelView = n),
              this.set('isOpen', !1),
              this.set('isEnabled', !0),
              this.set('class'),
              this.set('id'),
              this.set('panelPosition', 'auto'),
              (this.keystrokes = new Us()),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: ['ck', 'ck-dropdown', o.to('class'), o.if('isEnabled', 'ck-disabled', t => !t)],
                  id: o.to('id'),
                  'aria-describedby': o.to('ariaDescribedById'),
                },
                children: [e, n],
              }),
              e.extendTemplate({ attributes: { class: ['ck-dropdown__button'] } });
          }
          render() {
            super.render(),
              this.listenTo(this.buttonView, 'open', () => {
                this.isOpen = !this.isOpen;
              }),
              this.panelView.bind('isVisible').to(this, 'isOpen'),
              this.on('change:isOpen', () => {
                this.isOpen &&
                  ('auto' === this.panelPosition
                    ? (this.panelView.position = ph._getOptimalPosition({
                        element: this.panelView.element,
                        target: this.buttonView.element,
                        fitInViewport: !0,
                        positions: this._panelPositions,
                      }).name)
                    : (this.panelView.position = this.panelPosition));
              }),
              this.keystrokes.listenTo(this.element);
            const t = (t, e) => {
              this.isOpen && (this.buttonView.focus(), (this.isOpen = !1), e());
            };
            this.keystrokes.set('arrowdown', (t, e) => {
              this.buttonView.isEnabled && !this.isOpen && ((this.isOpen = !0), e());
            }),
              this.keystrokes.set('arrowright', (t, e) => {
                this.isOpen && e();
              }),
              this.keystrokes.set('arrowleft', t),
              this.keystrokes.set('esc', t);
          }
          focus() {
            this.buttonView.focus();
          }
          get _panelPositions() {
            const {
              south: t,
              north: e,
              southEast: n,
              southWest: o,
              northEast: i,
              northWest: r,
              southMiddleEast: s,
              southMiddleWest: a,
              northMiddleEast: c,
              northMiddleWest: l,
            } = ph.defaultPanelPositions;
            return 'rtl' !== this.locale.uiLanguageDirection
              ? [n, o, s, a, t, i, r, c, l, e]
              : [o, n, a, s, t, r, i, l, c, e];
          }
        }
        (ph.defaultPanelPositions = {
          south: (t, e) => ({ top: t.bottom, left: t.left - (e.width - t.width) / 2, name: 's' }),
          southEast: t => ({ top: t.bottom, left: t.left, name: 'se' }),
          southWest: (t, e) => ({ top: t.bottom, left: t.left - e.width + t.width, name: 'sw' }),
          southMiddleEast: (t, e) => ({ top: t.bottom, left: t.left - (e.width - t.width) / 4, name: 'sme' }),
          southMiddleWest: (t, e) => ({ top: t.bottom, left: t.left - (3 * (e.width - t.width)) / 4, name: 'smw' }),
          north: (t, e) => ({ top: t.top - e.height, left: t.left - (e.width - t.width) / 2, name: 'n' }),
          northEast: (t, e) => ({ top: t.top - e.height, left: t.left, name: 'ne' }),
          northWest: (t, e) => ({ top: t.top - e.height, left: t.left - e.width + t.width, name: 'nw' }),
          northMiddleEast: (t, e) => ({ top: t.top - e.height, left: t.left - (e.width - t.width) / 4, name: 'nme' }),
          northMiddleWest: (t, e) => ({
            top: t.top - e.height,
            left: t.left - (3 * (e.width - t.width)) / 4,
            name: 'nmw',
          }),
        }),
          (ph._getOptimalPosition = lh);
        class mh extends md {
          constructor(t) {
            super(t), this.setTemplate({ tag: 'span', attributes: { class: ['ck', 'ck-toolbar__separator'] } });
          }
        }
        class gh extends md {
          constructor(t) {
            super(t), this.setTemplate({ tag: 'span', attributes: { class: ['ck', 'ck-toolbar__line-break'] } });
          }
        }
        function fh(t) {
          return Array.isArray(t)
            ? { items: t, removeItems: [] }
            : t
            ? Object.assign({ items: [], removeItems: [] }, t)
            : { items: [], removeItems: [] };
        }
        var kh = n(20),
          bh = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(kh.a, bh), kh.a.locals;
        class wh extends md {
          constructor(t, e) {
            super(t);
            const n = this.bindTemplate,
              o = this.t;
            (this.options = e || {}),
              this.set('ariaLabel', o('Editor toolbar')),
              this.set('maxWidth', 'auto'),
              (this.items = this.createCollection()),
              (this.focusTracker = new Ws()),
              (this.keystrokes = new Us()),
              this.set('class'),
              this.set('isCompact', !1),
              (this.itemsView = new Ah(t)),
              (this.children = this.createCollection()),
              this.children.add(this.itemsView),
              (this.focusables = this.createCollection());
            const i = 'rtl' === t.uiLanguageDirection;
            this._focusCycler = new Yd({
              focusables: this.focusables,
              focusTracker: this.focusTracker,
              keystrokeHandler: this.keystrokes,
              actions: {
                focusPrevious: [i ? 'arrowright' : 'arrowleft', 'arrowup'],
                focusNext: [i ? 'arrowleft' : 'arrowright', 'arrowdown'],
              },
            });
            const r = ['ck', 'ck-toolbar', n.to('class'), n.if('isCompact', 'ck-toolbar_compact')];
            var s;
            this.options.shouldGroupWhenFull && this.options.isFloating && r.push('ck-toolbar_floating'),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: r,
                  role: 'toolbar',
                  'aria-label': n.to('ariaLabel'),
                  style: { maxWidth: n.to('maxWidth') },
                },
                children: this.children,
                on: {
                  mousedown:
                    ((s = this),
                    s.bindTemplate.to(t => {
                      t.target === s.element && t.preventDefault();
                    })),
                },
              }),
              (this._behavior = this.options.shouldGroupWhenFull ? new Ch(this) : new _h(this));
          }
          render() {
            super.render();
            for (const t of this.items) this.focusTracker.add(t.element);
            this.items.on('add', (t, e) => {
              this.focusTracker.add(e.element);
            }),
              this.items.on('remove', (t, e) => {
                this.focusTracker.remove(e.element);
              }),
              this.keystrokes.listenTo(this.element),
              this._behavior.render(this);
          }
          destroy() {
            return this._behavior.destroy(), super.destroy();
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          focusLast() {
            this._focusCycler.focusLast();
          }
          fillFromConfig(t, e) {
            const n = fh(t),
              o = n.items.filter(
                (t, o, i) =>
                  '|' === t ||
                  (-1 === n.removeItems.indexOf(t) &&
                    ('-' === t
                      ? !this.options.shouldGroupWhenFull ||
                        (Object(c.b)('toolbarview-line-break-ignored-when-grouping-items', i), !1)
                      : !!e.has(t) || (Object(c.b)('toolbarview-item-unavailable', { name: t }), !1))),
              ),
              i = this._cleanSeparators(o).map(t => ('|' === t ? new mh() : '-' === t ? new gh() : e.create(t)));
            this.items.addMany(i);
          }
          _cleanSeparators(t) {
            const e = t => '-' !== t && '|' !== t,
              n = t.length,
              o = t.findIndex(e),
              i = n - t.slice().reverse().findIndex(e);
            return t.slice(o, i).filter((t, n, o) => {
              if (e(t)) return !0;
              return !(n > 0 && o[n - 1] === t);
            });
          }
        }
        class Ah extends md {
          constructor(t) {
            super(t),
              (this.children = this.createCollection()),
              this.setTemplate({
                tag: 'div',
                attributes: { class: ['ck', 'ck-toolbar__items'] },
                children: this.children,
              });
          }
        }
        class _h {
          constructor(t) {
            const e = t.bindTemplate;
            t.set('isVertical', !1),
              t.itemsView.children.bindTo(t.items).using(t => t),
              t.focusables.bindTo(t.items).using(t => t),
              t.extendTemplate({ attributes: { class: [e.if('isVertical', 'ck-toolbar_vertical')] } });
          }
          render() {}
          destroy() {}
        }
        class Ch {
          constructor(t) {
            (this.view = t),
              (this.viewChildren = t.children),
              (this.viewFocusables = t.focusables),
              (this.viewItemsView = t.itemsView),
              (this.viewFocusTracker = t.focusTracker),
              (this.viewLocale = t.locale),
              (this.ungroupedItems = t.createCollection()),
              (this.groupedItems = t.createCollection()),
              (this.groupedItemsDropdown = this._createGroupedItemsDropdown()),
              (this.resizeObserver = null),
              (this.cachedPadding = null),
              (this.shouldUpdateGroupingOnNextResize = !1),
              t.itemsView.children.bindTo(this.ungroupedItems).using(t => t),
              this.ungroupedItems.on('add', this._updateFocusCycleableItems.bind(this)),
              this.ungroupedItems.on('remove', this._updateFocusCycleableItems.bind(this)),
              t.children.on('add', this._updateFocusCycleableItems.bind(this)),
              t.children.on('remove', this._updateFocusCycleableItems.bind(this)),
              t.items.on('change', (t, e) => {
                const n = e.index;
                for (const t of e.removed)
                  n >= this.ungroupedItems.length ? this.groupedItems.remove(t) : this.ungroupedItems.remove(t);
                for (let t = n; t < n + e.added.length; t++) {
                  const o = e.added[t - n];
                  t > this.ungroupedItems.length
                    ? this.groupedItems.add(o, t - this.ungroupedItems.length)
                    : this.ungroupedItems.add(o, t);
                }
                this._updateGrouping();
              }),
              t.extendTemplate({ attributes: { class: ['ck-toolbar_grouping'] } });
          }
          render(t) {
            (this.viewElement = t.element), this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(t);
          }
          destroy() {
            this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy();
          }
          _updateGrouping() {
            if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) return;
            if (!this.viewElement.offsetParent) return void (this.shouldUpdateGroupingOnNextResize = !0);
            const t = this.groupedItems.length;
            let e;
            for (; this._areItemsOverflowing; ) this._groupLastItem(), (e = !0);
            if (!e && this.groupedItems.length) {
              for (; this.groupedItems.length && !this._areItemsOverflowing; ) this._ungroupFirstItem();
              this._areItemsOverflowing && this._groupLastItem();
            }
            this.groupedItems.length !== t && this.view.fire('groupedItemsUpdate');
          }
          get _areItemsOverflowing() {
            if (!this.ungroupedItems.length) return !1;
            const t = this.viewElement,
              e = this.viewLocale.uiLanguageDirection,
              n = new Vs(t.lastChild),
              o = new Vs(t);
            if (!this.cachedPadding) {
              const n = Tr.window.getComputedStyle(t),
                o = 'ltr' === e ? 'paddingRight' : 'paddingLeft';
              this.cachedPadding = Number.parseInt(n[o]);
            }
            return 'ltr' === e ? n.right > o.right - this.cachedPadding : n.left < o.left + this.cachedPadding;
          }
          _enableGroupingOnResize() {
            let t;
            (this.resizeObserver = new qs(this.viewElement, e => {
              (t && t === e.contentRect.width && !this.shouldUpdateGroupingOnNextResize) ||
                ((this.shouldUpdateGroupingOnNextResize = !1), this._updateGrouping(), (t = e.contentRect.width));
            })),
              this._updateGrouping();
          }
          _enableGroupingOnMaxWidthChange(t) {
            t.on('change:maxWidth', () => {
              this._updateGrouping();
            });
          }
          _groupLastItem() {
            this.groupedItems.length ||
              (this.viewChildren.add(new mh()),
              this.viewChildren.add(this.groupedItemsDropdown),
              this.viewFocusTracker.add(this.groupedItemsDropdown.element)),
              this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
          }
          _ungroupFirstItem() {
            this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)),
              this.groupedItems.length ||
                (this.viewChildren.remove(this.groupedItemsDropdown),
                this.viewChildren.remove(this.viewChildren.last),
                this.viewFocusTracker.remove(this.groupedItemsDropdown.element));
          }
          _createGroupedItemsDropdown() {
            const t = this.viewLocale,
              e = t.t,
              n = Ih(t);
            return (
              (n.class = 'ck-toolbar__grouped-dropdown'),
              (n.panelPosition = 'ltr' === t.uiLanguageDirection ? 'sw' : 'se'),
              zh(n, []),
              n.buttonView.set({
                label: e('Show more items'),
                tooltip: !0,
                tooltipPosition: 'rtl' === t.uiLanguageDirection ? 'se' : 'sw',
                icon: rd,
              }),
              n.toolbarView.items.bindTo(this.groupedItems).using(t => t),
              n
            );
          }
          _updateFocusCycleableItems() {
            this.viewFocusables.clear(),
              this.ungroupedItems.map(t => {
                this.viewFocusables.add(t);
              }),
              this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown);
          }
        }
        var vh = n(21),
          yh = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(vh.a, yh), vh.a.locals;
        class xh extends md {
          constructor() {
            super(),
              (this.items = this.createCollection()),
              (this.focusTracker = new Ws()),
              (this.keystrokes = new Us()),
              (this._focusCycler = new Yd({
                focusables: this.items,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: { focusPrevious: 'arrowup', focusNext: 'arrowdown' },
              })),
              this.setTemplate({
                tag: 'ul',
                attributes: { class: ['ck', 'ck-reset', 'ck-list'] },
                children: this.items,
              });
          }
          render() {
            super.render();
            for (const t of this.items) this.focusTracker.add(t.element);
            this.items.on('add', (t, e) => {
              this.focusTracker.add(e.element);
            }),
              this.items.on('remove', (t, e) => {
                this.focusTracker.remove(e.element);
              }),
              this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          focusLast() {
            this._focusCycler.focusLast();
          }
        }
        class Eh extends md {
          constructor(t) {
            super(t),
              (this.children = this.createCollection()),
              this.setTemplate({ tag: 'li', attributes: { class: ['ck', 'ck-list__item'] }, children: this.children });
          }
          focus() {
            this.children.first.focus();
          }
        }
        class Dh extends md {
          constructor(t) {
            super(t), this.setTemplate({ tag: 'li', attributes: { class: ['ck', 'ck-list__separator'] } });
          }
        }
        var Sh = n(22),
          Bh = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 },
          Th = (hd()(Sh.a, Bh), Sh.a.locals, n(23)),
          Ph = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Th.a, Ph), Th.a.locals;
        function Ih(t, e = nh) {
          const n = new e(t),
            o = new sh(t),
            i = new ph(t, n, o);
          return (
            n.bind('isEnabled').to(i),
            n instanceof nh ? n.bind('isOn').to(i, 'isOpen') : n.arrowView.bind('isOn').to(i, 'isOpen'),
            (function (t) {
              (function (t) {
                t.on('render', () => {
                  sd({
                    emitter: t,
                    activator: () => t.isOpen,
                    callback: () => {
                      t.isOpen = !1;
                    },
                    contextElements: [t.element],
                  });
                });
              })(t),
                (function (t) {
                  t.on('execute', e => {
                    e.source instanceof Wd || (t.isOpen = !1);
                  });
                })(t),
                (function (t) {
                  t.keystrokes.set('arrowdown', (e, n) => {
                    t.isOpen && (t.panelView.focus(), n());
                  }),
                    t.keystrokes.set('arrowup', (e, n) => {
                      t.isOpen && (t.panelView.focusLast(), n());
                    });
                })(t);
            })(i),
            i
          );
        }
        function zh(t, e) {
          const n = t.locale,
            o = n.t,
            i = (t.toolbarView = new wh(n));
          i.set('ariaLabel', o('Dropdown toolbar')),
            t.extendTemplate({ attributes: { class: ['ck-toolbar-dropdown'] } }),
            e.map(t => i.items.add(t)),
            t.panelView.children.add(i),
            i.items.delegate('execute').to(t);
        }
        function Fh(t, e) {
          const n = t.locale,
            o = (t.listView = new xh(n));
          o.items.bindTo(e).using(({ type: t, model: e }) => {
            if ('separator' === t) return new Dh(n);
            if ('button' === t || 'switchbutton' === t) {
              const o = new Eh(n);
              let i;
              return (
                (i = 'button' === t ? new jd(n) : new Wd(n)),
                i.bind(...Object.keys(e)).to(e),
                i.delegate('execute').to(o),
                o.children.add(i),
                o
              );
            }
          }),
            t.panelView.children.add(o),
            o.items.delegate('execute').to(t);
        }
        var Rh = n(24),
          Oh = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Rh.a, Oh), Rh.a.locals;
        class Mh extends md {
          constructor(t) {
            super(t), (this.body = new Rd(t));
          }
          render() {
            super.render(), this.body.attachToDom();
          }
          destroy() {
            return this.body.detachFromDom(), super.destroy();
          }
        }
        var Nh = n(25),
          Vh = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Nh.a, Vh), Nh.a.locals;
        class Lh extends md {
          constructor(t) {
            super(t), this.set('text'), this.set('for'), (this.id = `ck-editor__label_${s()}`);
            const e = this.bindTemplate;
            this.setTemplate({
              tag: 'label',
              attributes: { class: ['ck', 'ck-label'], id: this.id, for: e.to('for') },
              children: [{ text: e.to('text') }],
            });
          }
        }
        class Kh extends md {
          constructor(t, e, n) {
            super(t),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: ['ck', 'ck-content', 'ck-editor__editable', 'ck-rounded-corners'],
                  lang: t.contentLanguage,
                  dir: t.contentLanguageDirection,
                },
              }),
              (this.name = null),
              this.set('isFocused', !1),
              (this._editableElement = n),
              (this._hasExternalElement = !!this._editableElement),
              (this._editingView = e);
          }
          render() {
            super.render(),
              this._hasExternalElement
                ? this.template.apply((this.element = this._editableElement))
                : (this._editableElement = this.element),
              this.on('change:isFocused', () => this._updateIsFocusedClasses()),
              this._updateIsFocusedClasses();
          }
          destroy() {
            this._hasExternalElement && this.template.revert(this._editableElement), super.destroy();
          }
          _updateIsFocusedClasses() {
            const t = this._editingView;
            function e(e) {
              t.change(n => {
                const o = t.document.getRoot(e.name);
                n.addClass(e.isFocused ? 'ck-focused' : 'ck-blurred', o),
                  n.removeClass(e.isFocused ? 'ck-blurred' : 'ck-focused', o);
              });
            }
            t.isRenderingInProgress
              ? (function n(o) {
                  t.once('change:isRenderingInProgress', (t, i, r) => {
                    r ? n(o) : e(o);
                  });
                })(this)
              : e(this);
          }
        }
        class qh extends Kh {
          constructor(t, e, n) {
            super(t, e, n),
              this.extendTemplate({ attributes: { role: 'textbox', class: 'ck-editor__editable_inline' } });
          }
          render() {
            super.render();
            const t = this._editingView,
              e = this.t;
            t.change(n => {
              const o = t.document.getRoot(this.name);
              n.setAttribute('aria-label', e('Rich Text Editor, %0', this.name), o);
            });
          }
        }
        var Hh = n(26),
          jh = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Hh.a, jh), Hh.a.locals;
        var $h = n(27),
          Gh = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()($h.a, Gh), $h.a.locals;
        class Wh extends md {
          constructor(t) {
            super(t),
              this.set('value'),
              this.set('id'),
              this.set('placeholder'),
              this.set('isReadOnly', !1),
              this.set('hasError', !1),
              this.set('ariaDescribedById'),
              (this.focusTracker = new Ws()),
              this.bind('isFocused').to(this.focusTracker),
              this.set('isEmpty', !0);
            const e = this.bindTemplate;
            this.setTemplate({
              tag: 'input',
              attributes: {
                type: 'text',
                class: [
                  'ck',
                  'ck-input',
                  'ck-input-text',
                  e.if('isFocused', 'ck-input_focused'),
                  e.if('isEmpty', 'ck-input-text_empty'),
                  e.if('hasError', 'ck-error'),
                ],
                id: e.to('id'),
                placeholder: e.to('placeholder'),
                readonly: e.to('isReadOnly'),
                'aria-invalid': e.if('hasError', !0),
                'aria-describedby': e.to('ariaDescribedById'),
              },
              on: { input: e.to('input'), change: e.to(this._updateIsEmpty.bind(this)) },
            });
          }
          render() {
            super.render(),
              this.focusTracker.add(this.element),
              this._setDomElementValue(this.value),
              this._updateIsEmpty(),
              this.on('change:value', (t, e, n) => {
                this._setDomElementValue(n), this._updateIsEmpty();
              });
          }
          select() {
            this.element.select();
          }
          focus() {
            this.element.focus();
          }
          _updateIsEmpty() {
            this.isEmpty = !this.element.value;
          }
          _setDomElementValue(t) {
            this.element.value = t || 0 === t ? t : '';
          }
        }
        var Uh = n(28),
          Jh = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Uh.a, Jh), Uh.a.locals;
        class Yh extends md {
          constructor(t, e) {
            super(t);
            const n = `ck-labeled-field-view-${s()}`,
              o = `ck-labeled-field-view-status-${s()}`;
            (this.fieldView = e(this, n, o)),
              this.set('label'),
              this.set('isEnabled', !0),
              this.set('isEmpty', !0),
              this.set('isFocused', !1),
              this.set('errorText', null),
              this.set('infoText', null),
              this.set('class'),
              this.set('placeholder'),
              (this.labelView = this._createLabelView(n)),
              (this.statusView = this._createStatusView(o)),
              this.bind('_statusText').to(this, 'errorText', this, 'infoText', (t, e) => t || e);
            const i = this.bindTemplate;
            this.setTemplate({
              tag: 'div',
              attributes: {
                class: [
                  'ck',
                  'ck-labeled-field-view',
                  i.to('class'),
                  i.if('isEnabled', 'ck-disabled', t => !t),
                  i.if('isEmpty', 'ck-labeled-field-view_empty'),
                  i.if('isFocused', 'ck-labeled-field-view_focused'),
                  i.if('placeholder', 'ck-labeled-field-view_placeholder'),
                  i.if('errorText', 'ck-error'),
                ],
              },
              children: [
                {
                  tag: 'div',
                  attributes: { class: ['ck', 'ck-labeled-field-view__input-wrapper'] },
                  children: [this.fieldView, this.labelView],
                },
                this.statusView,
              ],
            });
          }
          _createLabelView(t) {
            const e = new Lh(this.locale);
            return (e.for = t), e.bind('text').to(this, 'label'), e;
          }
          _createStatusView(t) {
            const e = new md(this.locale),
              n = this.bindTemplate;
            return (
              e.setTemplate({
                tag: 'div',
                attributes: {
                  class: [
                    'ck',
                    'ck-labeled-field-view__status',
                    n.if('errorText', 'ck-labeled-field-view__status_error'),
                    n.if('_statusText', 'ck-hidden', t => !t),
                  ],
                  id: t,
                  role: n.if('errorText', 'alert'),
                },
                children: [{ text: n.to('_statusText') }],
              }),
              e
            );
          }
          focus() {
            this.fieldView.focus();
          }
        }
        function Qh(t, e, n) {
          const o = new Wh(t.locale);
          return (
            o.set({ id: e, ariaDescribedById: n }),
            o.bind('isReadOnly').to(t, 'isEnabled', t => !t),
            o.bind('hasError').to(t, 'errorText', t => !!t),
            o.on('input', () => {
              t.errorText = null;
            }),
            t.bind('isEmpty', 'isFocused', 'placeholder').to(o),
            o
          );
        }
        class Xh extends ko {
          static get pluginName() {
            return 'Notification';
          }
          init() {
            this.on(
              'show:warning',
              (t, e) => {
                window.alert(e.message);
              },
              { priority: 'lowest' },
            );
          }
          showSuccess(t, e = {}) {
            this._showNotification({ message: t, type: 'success', namespace: e.namespace, title: e.title });
          }
          showInfo(t, e = {}) {
            this._showNotification({ message: t, type: 'info', namespace: e.namespace, title: e.title });
          }
          showWarning(t, e = {}) {
            this._showNotification({ message: t, type: 'warning', namespace: e.namespace, title: e.title });
          }
          _showNotification(t) {
            const e = `show:${t.type}` + (t.namespace ? `:${t.namespace}` : '');
            this.fire(e, { message: t.message, type: t.type, title: t.title || '' });
          }
        }
        class Zh {
          constructor(t, e) {
            e && Mt(this, e), t && this.set(t);
          }
        }
        Yt(Zh, jt);
        var tu = n(29),
          eu = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(tu.a, eu), tu.a.locals;
        const nu = $s('px'),
          ou = Tr.document.body;
        class iu extends md {
          constructor(t) {
            super(t);
            const e = this.bindTemplate;
            this.set('top', 0),
              this.set('left', 0),
              this.set('position', 'arrow_nw'),
              this.set('isVisible', !1),
              this.set('withArrow', !0),
              this.set('class'),
              (this.content = this.createCollection()),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: [
                    'ck',
                    'ck-balloon-panel',
                    e.to('position', t => `ck-balloon-panel_${t}`),
                    e.if('isVisible', 'ck-balloon-panel_visible'),
                    e.if('withArrow', 'ck-balloon-panel_with-arrow'),
                    e.to('class'),
                  ],
                  style: { top: e.to('top', nu), left: e.to('left', nu) },
                },
                children: this.content,
              });
          }
          show() {
            this.isVisible = !0;
          }
          hide() {
            this.isVisible = !1;
          }
          attachTo(t) {
            this.show();
            const e = iu.defaultPositions,
              n = Object.assign(
                {},
                {
                  element: this.element,
                  positions: [
                    e.southArrowNorth,
                    e.southArrowNorthMiddleWest,
                    e.southArrowNorthMiddleEast,
                    e.southArrowNorthWest,
                    e.southArrowNorthEast,
                    e.northArrowSouth,
                    e.northArrowSouthMiddleWest,
                    e.northArrowSouthMiddleEast,
                    e.northArrowSouthWest,
                    e.northArrowSouthEast,
                  ],
                  limiter: ou,
                  fitInViewport: !0,
                },
                t,
              ),
              o = iu._getOptimalPosition(n),
              i = parseInt(o.left),
              r = parseInt(o.top),
              s = o.name;
            Object.assign(this, { top: r, left: i, position: s });
          }
          pin(t) {
            this.unpin(),
              (this._pinWhenIsVisibleCallback = () => {
                this.isVisible ? this._startPinning(t) : this._stopPinning();
              }),
              this._startPinning(t),
              this.listenTo(this, 'change:isVisible', this._pinWhenIsVisibleCallback);
          }
          unpin() {
            this._pinWhenIsVisibleCallback &&
              (this._stopPinning(),
              this.stopListening(this, 'change:isVisible', this._pinWhenIsVisibleCallback),
              (this._pinWhenIsVisibleCallback = null),
              this.hide());
          }
          _startPinning(t) {
            this.attachTo(t);
            const e = ru(t.target),
              n = t.limiter ? ru(t.limiter) : ou;
            this.listenTo(
              Tr.document,
              'scroll',
              (o, i) => {
                const r = i.target,
                  s = e && r.contains(e),
                  a = n && r.contains(n);
                (!s && !a && e && n) || this.attachTo(t);
              },
              { useCapture: !0 },
            ),
              this.listenTo(Tr.window, 'resize', () => {
                this.attachTo(t);
              });
          }
          _stopPinning() {
            this.stopListening(Tr.document, 'scroll'), this.stopListening(Tr.window, 'resize');
          }
        }
        function ru(t) {
          return oo(t) ? t : Os(t) ? t.commonAncestorContainer : 'function' == typeof t ? ru(t()) : null;
        }
        function su(t, e) {
          return t.top - e.height - iu.arrowVerticalOffset;
        }
        function au(t) {
          return t.bottom + iu.arrowVerticalOffset;
        }
        (iu.arrowHorizontalOffset = 25),
          (iu.arrowVerticalOffset = 10),
          (iu._getOptimalPosition = lh),
          (iu.defaultPositions = {
            northWestArrowSouthWest: (t, e) => ({
              top: su(t, e),
              left: t.left - iu.arrowHorizontalOffset,
              name: 'arrow_sw',
            }),
            northWestArrowSouthMiddleWest: (t, e) => ({
              top: su(t, e),
              left: t.left - 0.25 * e.width - iu.arrowHorizontalOffset,
              name: 'arrow_smw',
            }),
            northWestArrowSouth: (t, e) => ({ top: su(t, e), left: t.left - e.width / 2, name: 'arrow_s' }),
            northWestArrowSouthMiddleEast: (t, e) => ({
              top: su(t, e),
              left: t.left - 0.75 * e.width + iu.arrowHorizontalOffset,
              name: 'arrow_sme',
            }),
            northWestArrowSouthEast: (t, e) => ({
              top: su(t, e),
              left: t.left - e.width + iu.arrowHorizontalOffset,
              name: 'arrow_se',
            }),
            northArrowSouthWest: (t, e) => ({
              top: su(t, e),
              left: t.left + t.width / 2 - iu.arrowHorizontalOffset,
              name: 'arrow_sw',
            }),
            northArrowSouthMiddleWest: (t, e) => ({
              top: su(t, e),
              left: t.left + t.width / 2 - 0.25 * e.width - iu.arrowHorizontalOffset,
              name: 'arrow_smw',
            }),
            northArrowSouth: (t, e) => ({ top: su(t, e), left: t.left + t.width / 2 - e.width / 2, name: 'arrow_s' }),
            northArrowSouthMiddleEast: (t, e) => ({
              top: su(t, e),
              left: t.left + t.width / 2 - 0.75 * e.width + iu.arrowHorizontalOffset,
              name: 'arrow_sme',
            }),
            northArrowSouthEast: (t, e) => ({
              top: su(t, e),
              left: t.left + t.width / 2 - e.width + iu.arrowHorizontalOffset,
              name: 'arrow_se',
            }),
            northEastArrowSouthWest: (t, e) => ({
              top: su(t, e),
              left: t.right - iu.arrowHorizontalOffset,
              name: 'arrow_sw',
            }),
            northEastArrowSouthMiddleWest: (t, e) => ({
              top: su(t, e),
              left: t.right - 0.25 * e.width - iu.arrowHorizontalOffset,
              name: 'arrow_smw',
            }),
            northEastArrowSouth: (t, e) => ({ top: su(t, e), left: t.right - e.width / 2, name: 'arrow_s' }),
            northEastArrowSouthMiddleEast: (t, e) => ({
              top: su(t, e),
              left: t.right - 0.75 * e.width + iu.arrowHorizontalOffset,
              name: 'arrow_sme',
            }),
            northEastArrowSouthEast: (t, e) => ({
              top: su(t, e),
              left: t.right - e.width + iu.arrowHorizontalOffset,
              name: 'arrow_se',
            }),
            southWestArrowNorthWest: (t, e) => ({
              top: au(t),
              left: t.left - iu.arrowHorizontalOffset,
              name: 'arrow_nw',
            }),
            southWestArrowNorthMiddleWest: (t, e) => ({
              top: au(t),
              left: t.left - 0.25 * e.width - iu.arrowHorizontalOffset,
              name: 'arrow_nmw',
            }),
            southWestArrowNorth: (t, e) => ({ top: au(t), left: t.left - e.width / 2, name: 'arrow_n' }),
            southWestArrowNorthMiddleEast: (t, e) => ({
              top: au(t),
              left: t.left - 0.75 * e.width + iu.arrowHorizontalOffset,
              name: 'arrow_nme',
            }),
            southWestArrowNorthEast: (t, e) => ({
              top: au(t),
              left: t.left - e.width + iu.arrowHorizontalOffset,
              name: 'arrow_ne',
            }),
            southArrowNorthWest: (t, e) => ({
              top: au(t),
              left: t.left + t.width / 2 - iu.arrowHorizontalOffset,
              name: 'arrow_nw',
            }),
            southArrowNorthMiddleWest: (t, e) => ({
              top: au(t),
              left: t.left + t.width / 2 - 0.25 * e.width - iu.arrowHorizontalOffset,
              name: 'arrow_nmw',
            }),
            southArrowNorth: (t, e) => ({ top: au(t), left: t.left + t.width / 2 - e.width / 2, name: 'arrow_n' }),
            southArrowNorthMiddleEast: (t, e) => ({
              top: au(t),
              left: t.left + t.width / 2 - 0.75 * e.width + iu.arrowHorizontalOffset,
              name: 'arrow_nme',
            }),
            southArrowNorthEast: (t, e) => ({
              top: au(t),
              left: t.left + t.width / 2 - e.width + iu.arrowHorizontalOffset,
              name: 'arrow_ne',
            }),
            southEastArrowNorthWest: (t, e) => ({
              top: au(t),
              left: t.right - iu.arrowHorizontalOffset,
              name: 'arrow_nw',
            }),
            southEastArrowNorthMiddleWest: (t, e) => ({
              top: au(t),
              left: t.right - 0.25 * e.width - iu.arrowHorizontalOffset,
              name: 'arrow_nmw',
            }),
            southEastArrowNorth: (t, e) => ({ top: au(t), left: t.right - e.width / 2, name: 'arrow_n' }),
            southEastArrowNorthMiddleEast: (t, e) => ({
              top: au(t),
              left: t.right - 0.75 * e.width + iu.arrowHorizontalOffset,
              name: 'arrow_nme',
            }),
            southEastArrowNorthEast: (t, e) => ({
              top: au(t),
              left: t.right - e.width + iu.arrowHorizontalOffset,
              name: 'arrow_ne',
            }),
          });
        var cu = n(30),
          lu = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 },
          du = (hd()(cu.a, lu), cu.a.locals, n(31)),
          hu = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(du.a, hu), du.a.locals;
        const uu = $s('px');
        class pu extends Qt {
          static get pluginName() {
            return 'ContextualBalloon';
          }
          constructor(t) {
            super(t),
              (this.positionLimiter = () => {
                const t = this.editor.editing.view,
                  e = t.document.selection.editableElement;
                return e ? t.domConverter.mapViewToDom(e.root) : null;
              }),
              this.set('visibleView', null),
              (this.view = new iu(t.locale)),
              t.ui.view.body.add(this.view),
              t.ui.focusTracker.add(this.view.element),
              (this._viewToStack = new Map()),
              (this._idToStack = new Map()),
              this.set('_numberOfStacks', 0),
              this.set('_singleViewMode', !1),
              (this._rotatorView = this._createRotatorView()),
              (this._fakePanelsView = this._createFakePanelsView());
          }
          hasView(t) {
            return Array.from(this._viewToStack.keys()).includes(t);
          }
          add(t) {
            if (this.hasView(t.view)) throw new c.a('contextualballoon-add-view-exist', [this, t]);
            const e = t.stackId || 'main';
            if (!this._idToStack.has(e))
              return (
                this._idToStack.set(e, new Map([[t.view, t]])),
                this._viewToStack.set(t.view, this._idToStack.get(e)),
                (this._numberOfStacks = this._idToStack.size),
                void ((this._visibleStack && !t.singleViewMode) || this.showStack(e))
              );
            const n = this._idToStack.get(e);
            t.singleViewMode && this.showStack(e),
              n.set(t.view, t),
              this._viewToStack.set(t.view, n),
              n === this._visibleStack && this._showView(t);
          }
          remove(t) {
            if (!this.hasView(t)) throw new c.a('contextualballoon-remove-view-not-exist', [this, t]);
            const e = this._viewToStack.get(t);
            this._singleViewMode && this.visibleView === t && (this._singleViewMode = !1),
              this.visibleView === t &&
                (1 === e.size
                  ? this._idToStack.size > 1
                    ? this._showNextStack()
                    : (this.view.hide(), (this.visibleView = null), this._rotatorView.hideView())
                  : this._showView(Array.from(e.values())[e.size - 2])),
              1 === e.size
                ? (this._idToStack.delete(this._getStackId(e)), (this._numberOfStacks = this._idToStack.size))
                : e.delete(t),
              this._viewToStack.delete(t);
          }
          updatePosition(t) {
            t && (this._visibleStack.get(this.visibleView).position = t),
              this.view.pin(this._getBalloonPosition()),
              this._fakePanelsView.updatePosition();
          }
          showStack(t) {
            this.visibleStack = t;
            const e = this._idToStack.get(t);
            if (!e) throw new c.a('contextualballoon-showstack-stack-not-exist', this);
            this._visibleStack !== e && this._showView(Array.from(e.values()).pop());
          }
          get _visibleStack() {
            return this._viewToStack.get(this.visibleView);
          }
          _getStackId(t) {
            return Array.from(this._idToStack.entries()).find(e => e[1] === t)[0];
          }
          _showNextStack() {
            const t = Array.from(this._idToStack.values());
            let e = t.indexOf(this._visibleStack) + 1;
            t[e] || (e = 0), this.showStack(this._getStackId(t[e]));
          }
          _showPrevStack() {
            const t = Array.from(this._idToStack.values());
            let e = t.indexOf(this._visibleStack) - 1;
            t[e] || (e = t.length - 1), this.showStack(this._getStackId(t[e]));
          }
          _createRotatorView() {
            const t = new mu(this.editor.locale),
              e = this.editor.locale.t;
            return (
              this.view.content.add(t),
              t.bind('isNavigationVisible').to(this, '_numberOfStacks', this, '_singleViewMode', (t, e) => !e && t > 1),
              t.on('change:isNavigationVisible', () => this.updatePosition(), { priority: 'low' }),
              t.bind('counter').to(this, 'visibleView', this, '_numberOfStacks', (t, n) => {
                if (n < 2) return '';
                const o = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
                return e('%0 of %1', [o, n]);
              }),
              t.buttonNextView.on('execute', () => {
                t.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack();
              }),
              t.buttonPrevView.on('execute', () => {
                t.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack();
              }),
              t
            );
          }
          _createFakePanelsView() {
            const t = new gu(this.editor.locale, this.view);
            return (
              t
                .bind('numberOfPanels')
                .to(this, '_numberOfStacks', this, '_singleViewMode', (t, e) =>
                  !e && t >= 2 ? Math.min(t - 1, 2) : 0,
                ),
              t.listenTo(this.view, 'change:top', () => t.updatePosition()),
              t.listenTo(this.view, 'change:left', () => t.updatePosition()),
              this.editor.ui.view.body.add(t),
              t
            );
          }
          _showView({ view: t, balloonClassName: e = '', withArrow: n = !0, singleViewMode: o = !1 }) {
            (this.view.class = e),
              (this.view.withArrow = n),
              this._rotatorView.showView(t),
              (this.visibleView = t),
              this.view.pin(this._getBalloonPosition()),
              this._fakePanelsView.updatePosition(),
              o && (this._singleViewMode = !0);
          }
          _getBalloonPosition() {
            let t = Array.from(this._visibleStack.values()).pop().position;
            return t && !t.limiter && (t = Object.assign({}, t, { limiter: this.positionLimiter })), t;
          }
        }
        class mu extends md {
          constructor(t) {
            super(t);
            const e = t.t,
              n = this.bindTemplate;
            this.set('isNavigationVisible', !0),
              (this.focusTracker = new Ws()),
              (this.buttonPrevView = this._createButtonView(
                e('Previous'),
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>',
              )),
              (this.buttonNextView = this._createButtonView(
                e('Next'),
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>',
              )),
              (this.content = this.createCollection()),
              this.setTemplate({
                tag: 'div',
                attributes: { class: ['ck', 'ck-balloon-rotator'], 'z-index': '-1' },
                children: [
                  {
                    tag: 'div',
                    attributes: {
                      class: [
                        'ck-balloon-rotator__navigation',
                        n.to('isNavigationVisible', t => (t ? '' : 'ck-hidden')),
                      ],
                    },
                    children: [
                      this.buttonPrevView,
                      {
                        tag: 'span',
                        attributes: { class: ['ck-balloon-rotator__counter'] },
                        children: [{ text: n.to('counter') }],
                      },
                      this.buttonNextView,
                    ],
                  },
                  { tag: 'div', attributes: { class: 'ck-balloon-rotator__content' }, children: this.content },
                ],
              });
          }
          render() {
            super.render(), this.focusTracker.add(this.element);
          }
          showView(t) {
            this.hideView(), this.content.add(t);
          }
          hideView() {
            this.content.clear();
          }
          _createButtonView(t, e) {
            const n = new jd(this.locale);
            return n.set({ label: t, icon: e, tooltip: !0 }), n;
          }
        }
        class gu extends md {
          constructor(t, e) {
            super(t);
            const n = this.bindTemplate;
            this.set('top', 0),
              this.set('left', 0),
              this.set('height', 0),
              this.set('width', 0),
              this.set('numberOfPanels', 0),
              (this.content = this.createCollection()),
              (this._balloonPanelView = e),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: ['ck-fake-panel', n.to('numberOfPanels', t => (t ? '' : 'ck-hidden'))],
                  style: {
                    top: n.to('top', uu),
                    left: n.to('left', uu),
                    width: n.to('width', uu),
                    height: n.to('height', uu),
                  },
                },
                children: this.content,
              }),
              this.on('change:numberOfPanels', (t, e, n, o) => {
                n > o ? this._addPanels(n - o) : this._removePanels(o - n), this.updatePosition();
              });
          }
          _addPanels(t) {
            for (; t--; ) {
              const t = new md();
              t.setTemplate({ tag: 'div' }), this.content.add(t), this.registerChild(t);
            }
          }
          _removePanels(t) {
            for (; t--; ) {
              const t = this.content.last;
              this.content.remove(t), this.deregisterChild(t), t.destroy();
            }
          }
          updatePosition() {
            if (this.numberOfPanels) {
              const { top: t, left: e } = this._balloonPanelView,
                { width: n, height: o } = new Vs(this._balloonPanelView.element);
              Object.assign(this, { top: t, left: e, width: n, height: o });
            }
          }
        }
        var fu = n(32),
          ku = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(fu.a, ku), fu.a.locals;
        $s('px');
        $s('px');
        var bu = n(33),
          wu = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(bu.a, wu), bu.a.locals;
        $s('px');
        $s('px');
        var Au = n(34),
          _u = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Au.a, _u), Au.a.locals;
        const Cu = new WeakMap();
        function vu(t) {
          const { view: e, element: n, text: o, isDirectHost: i = !0, keepOnFocus: r = !1 } = t,
            s = e.document;
          Cu.has(s) || (Cu.set(s, new Map()), s.registerPostFixer(t => xu(s, t))),
            Cu.get(s).set(n, { text: o, isDirectHost: i, keepOnFocus: r, hostElement: i ? n : null }),
            e.change(t => xu(s, t));
        }
        function yu(t, e) {
          return !!e.hasClass('ck-placeholder') && (t.removeClass('ck-placeholder', e), !0);
        }
        function xu(t, e) {
          const n = Cu.get(t),
            o = [];
          let i = !1;
          for (const [t, r] of n) r.isDirectHost && (o.push(t), Eu(e, t, r) && (i = !0));
          for (const [t, r] of n) {
            if (r.isDirectHost) continue;
            const n = Du(t);
            n && (o.includes(n) || ((r.hostElement = n), Eu(e, t, r) && (i = !0)));
          }
          return i;
        }
        function Eu(t, e, n) {
          const { text: o, isDirectHost: i, hostElement: r } = n;
          let s = !1;
          r.getAttribute('data-placeholder') !== o && (t.setAttribute('data-placeholder', o, r), (s = !0));
          return (
            (i || 1 == e.childCount) &&
            (function (t, e) {
              if (!t.isAttached()) return !1;
              if (Array.from(t.getChildren()).some(t => !t.is('uiElement'))) return !1;
              if (e) return !0;
              const n = t.document;
              if (!n.isFocused) return !0;
              const o = n.selection.anchor;
              return o && o.parent !== t;
            })(r, n.keepOnFocus)
              ? (function (t, e) {
                  return !e.hasClass('ck-placeholder') && (t.addClass('ck-placeholder', e), !0);
                })(t, r) && (s = !0)
              : yu(t, r) && (s = !0),
            s
          );
        }
        function Du(t) {
          if (t.childCount) {
            const e = t.getChild(0);
            if (e.is('element') && !e.is('uiElement')) return e;
          }
          return null;
        }
        const Su = new Map();
        function Bu(t, e, n) {
          let o = Su.get(t);
          o || ((o = new Map()), Su.set(t, o)), o.set(e, n);
        }
        function Tu(t) {
          return [t];
        }
        function Pu(t, e, n = {}) {
          const o = (function (t, e) {
            const n = Su.get(t);
            return n && n.has(e) ? n.get(e) : Tu;
          })(t.constructor, e.constructor);
          try {
            return o((t = t.clone()), e, n);
          } catch (t) {
            throw t;
          }
        }
        function Iu(t, e, n) {
          (t = t.slice()), (e = e.slice());
          const o = new zu(n.document, n.useRelations, n.forceWeakRemove);
          o.setOriginalOperations(t), o.setOriginalOperations(e);
          const i = o.originalOperations;
          if (0 == t.length || 0 == e.length) return { operationsA: t, operationsB: e, originalOperations: i };
          const r = new WeakMap();
          for (const e of t) r.set(e, 0);
          const s = {
            nextBaseVersionA: t[t.length - 1].baseVersion + 1,
            nextBaseVersionB: e[e.length - 1].baseVersion + 1,
            originalOperationsACount: t.length,
            originalOperationsBCount: e.length,
          };
          let a = 0;
          for (; a < t.length; ) {
            const n = t[a],
              i = r.get(n);
            if (i == e.length) {
              a++;
              continue;
            }
            const s = e[i],
              c = Pu(n, s, o.getContext(n, s, !0)),
              l = Pu(s, n, o.getContext(s, n, !1));
            o.updateRelation(n, s), o.setOriginalOperations(c, n), o.setOriginalOperations(l, s);
            for (const t of c) r.set(t, i + l.length);
            t.splice(a, 1, ...c), e.splice(i, 1, ...l);
          }
          if (n.padWithNoOps) {
            const n = t.length - s.originalOperationsACount,
              o = e.length - s.originalOperationsBCount;
            Ru(t, o - n), Ru(e, n - o);
          }
          return (
            Fu(t, s.nextBaseVersionB),
            Fu(e, s.nextBaseVersionA),
            { operationsA: t, operationsB: e, originalOperations: i }
          );
        }
        class zu {
          constructor(t, e, n = !1) {
            (this.originalOperations = new Map()),
              (this._history = t.history),
              (this._useRelations = e),
              (this._forceWeakRemove = !!n),
              (this._relations = new Map());
          }
          setOriginalOperations(t, e = null) {
            const n = e ? this.originalOperations.get(e) : null;
            for (const e of t) this.originalOperations.set(e, n || e);
          }
          updateRelation(t, e) {
            switch (t.constructor) {
              case qc:
                switch (e.constructor) {
                  case Wc:
                    t.targetPosition.isEqual(e.sourcePosition) || e.movedRange.containsPosition(t.targetPosition)
                      ? this._setRelation(t, e, 'insertAtSource')
                      : t.targetPosition.isEqual(e.deletionPosition)
                      ? this._setRelation(t, e, 'insertBetween')
                      : t.targetPosition.isAfter(e.sourcePosition) && this._setRelation(t, e, 'moveTargetAfter');
                    break;
                  case qc:
                    t.targetPosition.isEqual(e.sourcePosition) || t.targetPosition.isBefore(e.sourcePosition)
                      ? this._setRelation(t, e, 'insertBefore')
                      : this._setRelation(t, e, 'insertAfter');
                }
                break;
              case Uc:
                switch (e.constructor) {
                  case Wc:
                    t.splitPosition.isBefore(e.sourcePosition) && this._setRelation(t, e, 'splitBefore');
                    break;
                  case qc:
                    if (t.splitPosition.isEqual(e.sourcePosition) || t.splitPosition.isBefore(e.sourcePosition))
                      this._setRelation(t, e, 'splitBefore');
                    else {
                      const n = ba._createFromPositionAndShift(e.sourcePosition, e.howMany);
                      if (t.splitPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(t.splitPosition)) {
                        const o = n.end.offset - t.splitPosition.offset,
                          i = t.splitPosition.offset - n.start.offset;
                        this._setRelation(t, e, { howMany: o, offset: i });
                      }
                    }
                }
                break;
              case Wc:
                switch (e.constructor) {
                  case Wc:
                    t.targetPosition.isEqual(e.sourcePosition) || this._setRelation(t, e, 'mergeTargetNotMoved'),
                      t.sourcePosition.isEqual(e.targetPosition) && this._setRelation(t, e, 'mergeSourceNotMoved'),
                      t.sourcePosition.isEqual(e.sourcePosition) && this._setRelation(t, e, 'mergeSameElement');
                    break;
                  case Uc:
                    t.sourcePosition.isEqual(e.splitPosition) && this._setRelation(t, e, 'splitAtSource');
                }
                break;
              case jc: {
                const n = t.newRange;
                if (!n) return;
                switch (e.constructor) {
                  case qc: {
                    const o = ba._createFromPositionAndShift(e.sourcePosition, e.howMany),
                      i = o.containsPosition(n.start) || o.start.isEqual(n.start),
                      r = o.containsPosition(n.end) || o.end.isEqual(n.end);
                    (!i && !r) ||
                      o.containsRange(n) ||
                      this._setRelation(t, e, {
                        side: i ? 'left' : 'right',
                        path: i ? n.start.path.slice() : n.end.path.slice(),
                      });
                    break;
                  }
                  case Wc: {
                    const o = n.start.isEqual(e.targetPosition),
                      i = n.start.isEqual(e.deletionPosition),
                      r = n.end.isEqual(e.deletionPosition),
                      s = n.end.isEqual(e.sourcePosition);
                    (o || i || r || s) &&
                      this._setRelation(t, e, {
                        wasInLeftElement: o,
                        wasStartBeforeMergedElement: i,
                        wasEndBeforeMergedElement: r,
                        wasInRightElement: s,
                      });
                    break;
                  }
                }
                break;
              }
            }
          }
          getContext(t, e, n) {
            return {
              aIsStrong: n,
              aWasUndone: this._wasUndone(t),
              bWasUndone: this._wasUndone(e),
              abRelation: this._useRelations ? this._getRelation(t, e) : null,
              baRelation: this._useRelations ? this._getRelation(e, t) : null,
              forceWeakRemove: this._forceWeakRemove,
            };
          }
          _wasUndone(t) {
            const e = this.originalOperations.get(t);
            return e.wasUndone || this._history.isUndoneOperation(e);
          }
          _getRelation(t, e) {
            const n = this.originalOperations.get(e),
              o = this._history.getUndoneOperation(n);
            if (!o) return null;
            const i = this.originalOperations.get(t),
              r = this._relations.get(i);
            return (r && r.get(o)) || null;
          }
          _setRelation(t, e, n) {
            const o = this.originalOperations.get(t),
              i = this.originalOperations.get(e);
            let r = this._relations.get(o);
            r || ((r = new Map()), this._relations.set(o, r)), r.set(i, n);
          }
        }
        function Fu(t, e) {
          for (const n of t) n.baseVersion = e++;
        }
        function Ru(t, e) {
          for (let n = 0; n < e; n++) t.push(new ml(0));
        }
        function Ou(t, e, n) {
          const o = t.nodes.getNode(0).getAttribute(e);
          if (o == n) return null;
          const i = new ba(t.position, t.position.getShiftedBy(t.howMany));
          return new Lc(i, e, o, n, 0);
        }
        function Mu(t, e) {
          return null === t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany);
        }
        function Nu(t, e) {
          const n = [];
          for (let o = 0; o < t.length; o++) {
            const i = t[o],
              r = new qc(i.start, i.end.offset - i.start.offset, e, 0);
            n.push(r);
            for (let e = o + 1; e < t.length; e++)
              t[e] = t[e]._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)[0];
            e = e._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany);
          }
          return n;
        }
        Bu(Lc, Lc, (t, e, n) => {
          if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) {
            const o = t.range.getDifference(e.range).map(e => new Lc(e, t.key, t.oldValue, t.newValue, 0)),
              i = t.range.getIntersection(e.range);
            return (
              i && n.aIsStrong && o.push(new Lc(i, e.key, e.newValue, t.newValue, 0)), 0 == o.length ? [new ml(0)] : o
            );
          }
          return [t];
        }),
          Bu(Lc, Hc, (t, e) => {
            if (t.range.start.hasSameParentAs(e.position) && t.range.containsPosition(e.position)) {
              const n = t.range
                ._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes)
                .map(e => new Lc(e, t.key, t.oldValue, t.newValue, t.baseVersion));
              if (e.shouldReceiveAttributes) {
                const o = Ou(e, t.key, t.oldValue);
                o && n.unshift(o);
              }
              return n;
            }
            return (t.range = t.range._getTransformedByInsertion(e.position, e.howMany, !1)[0]), [t];
          }),
          Bu(Lc, Wc, (t, e) => {
            const n = [];
            t.range.start.hasSameParentAs(e.deletionPosition) &&
              (t.range.containsPosition(e.deletionPosition) || t.range.start.isEqual(e.deletionPosition)) &&
              n.push(ba._createFromPositionAndShift(e.graveyardPosition, 1));
            const o = t.range._getTransformedByMergeOperation(e);
            return o.isCollapsed || n.push(o), n.map(e => new Lc(e, t.key, t.oldValue, t.newValue, t.baseVersion));
          }),
          Bu(Lc, qc, (t, e) =>
            (function (t, e) {
              const n = ba._createFromPositionAndShift(e.sourcePosition, e.howMany);
              let o = null,
                i = [];
              n.containsRange(t, !0)
                ? (o = t)
                : t.start.hasSameParentAs(n.start)
                ? ((i = t.getDifference(n)), (o = t.getIntersection(n)))
                : (i = [t]);
              const r = [];
              for (let t of i) {
                t = t._getTransformedByDeletion(e.sourcePosition, e.howMany);
                const n = e.getMovedRangeStart(),
                  o = t.start.hasSameParentAs(n);
                (t = t._getTransformedByInsertion(n, e.howMany, o)), r.push(...t);
              }
              o && r.push(o._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, !1)[0]);
              return r;
            })(t.range, e).map(e => new Lc(e, t.key, t.oldValue, t.newValue, t.baseVersion)),
          ),
          Bu(Lc, Uc, (t, e) => {
            if (t.range.end.isEqual(e.insertionPosition)) return e.graveyardPosition || t.range.end.offset++, [t];
            if (t.range.start.hasSameParentAs(e.splitPosition) && t.range.containsPosition(e.splitPosition)) {
              const n = t.clone();
              return (
                (n.range = new ba(
                  e.moveTargetPosition.clone(),
                  t.range.end._getCombined(e.splitPosition, e.moveTargetPosition),
                )),
                (t.range.end = e.splitPosition.clone()),
                (t.range.end.stickiness = 'toPrevious'),
                [t, n]
              );
            }
            return (t.range = t.range._getTransformedBySplitOperation(e)), [t];
          }),
          Bu(Hc, Lc, (t, e) => {
            const n = [t];
            if (
              t.shouldReceiveAttributes &&
              t.position.hasSameParentAs(e.range.start) &&
              e.range.containsPosition(t.position)
            ) {
              const o = Ou(t, e.key, e.newValue);
              o && n.push(o);
            }
            return n;
          }),
          Bu(
            Hc,
            Hc,
            (t, e, n) => (
              (t.position.isEqual(e.position) && n.aIsStrong) ||
                (t.position = t.position._getTransformedByInsertOperation(e)),
              [t]
            ),
          ),
          Bu(Hc, qc, (t, e) => ((t.position = t.position._getTransformedByMoveOperation(e)), [t])),
          Bu(Hc, Uc, (t, e) => ((t.position = t.position._getTransformedBySplitOperation(e)), [t])),
          Bu(Hc, Wc, (t, e) => ((t.position = t.position._getTransformedByMergeOperation(e)), [t])),
          Bu(
            jc,
            Hc,
            (t, e) => (
              t.oldRange && (t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0]),
              t.newRange && (t.newRange = t.newRange._getTransformedByInsertOperation(e)[0]),
              [t]
            ),
          ),
          Bu(jc, jc, (t, e, n) => {
            if (t.name == e.name) {
              if (!n.aIsStrong) return [new ml(0)];
              t.oldRange = e.newRange ? e.newRange.clone() : null;
            }
            return [t];
          }),
          Bu(
            jc,
            Wc,
            (t, e) => (
              t.oldRange && (t.oldRange = t.oldRange._getTransformedByMergeOperation(e)),
              t.newRange && (t.newRange = t.newRange._getTransformedByMergeOperation(e)),
              [t]
            ),
          ),
          Bu(jc, qc, (t, e, n) => {
            if (
              (t.oldRange && (t.oldRange = ba._createFromRanges(t.oldRange._getTransformedByMoveOperation(e))),
              t.newRange)
            ) {
              if (n.abRelation) {
                const o = ba._createFromRanges(t.newRange._getTransformedByMoveOperation(e));
                if ('left' == n.abRelation.side && e.targetPosition.isEqual(t.newRange.start))
                  return (t.newRange.start.path = n.abRelation.path), (t.newRange.end = o.end), [t];
                if ('right' == n.abRelation.side && e.targetPosition.isEqual(t.newRange.end))
                  return (t.newRange.start = o.start), (t.newRange.end.path = n.abRelation.path), [t];
              }
              t.newRange = ba._createFromRanges(t.newRange._getTransformedByMoveOperation(e));
            }
            return [t];
          }),
          Bu(jc, Uc, (t, e, n) => {
            if ((t.oldRange && (t.oldRange = t.oldRange._getTransformedBySplitOperation(e)), t.newRange)) {
              if (n.abRelation) {
                const o = t.newRange._getTransformedBySplitOperation(e);
                return (
                  t.newRange.start.isEqual(e.splitPosition) && n.abRelation.wasStartBeforeMergedElement
                    ? (t.newRange.start = ma._createAt(e.insertionPosition))
                    : t.newRange.start.isEqual(e.splitPosition) &&
                      !n.abRelation.wasInLeftElement &&
                      (t.newRange.start = ma._createAt(e.moveTargetPosition)),
                  t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasInRightElement
                    ? (t.newRange.end = ma._createAt(e.moveTargetPosition))
                    : t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasEndBeforeMergedElement
                    ? (t.newRange.end = ma._createAt(e.insertionPosition))
                    : (t.newRange.end = o.end),
                  [t]
                );
              }
              t.newRange = t.newRange._getTransformedBySplitOperation(e);
            }
            return [t];
          }),
          Bu(
            Wc,
            Hc,
            (t, e) => (
              t.sourcePosition.hasSameParentAs(e.position) && (t.howMany += e.howMany),
              (t.sourcePosition = t.sourcePosition._getTransformedByInsertOperation(e)),
              (t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e)),
              [t]
            ),
          ),
          Bu(Wc, Wc, (t, e, n) => {
            if (t.sourcePosition.isEqual(e.sourcePosition) && t.targetPosition.isEqual(e.targetPosition)) {
              if (n.bWasUndone) {
                const n = e.graveyardPosition.path.slice();
                return n.push(0), (t.sourcePosition = new ma(e.graveyardPosition.root, n)), (t.howMany = 0), [t];
              }
              return [new ml(0)];
            }
            if (
              t.sourcePosition.isEqual(e.sourcePosition) &&
              !t.targetPosition.isEqual(e.targetPosition) &&
              !n.bWasUndone &&
              'splitAtSource' != n.abRelation
            ) {
              const o = '$graveyard' == t.targetPosition.root.rootName,
                i = '$graveyard' == e.targetPosition.root.rootName,
                r = o && !i;
              if ((i && !o) || (!r && n.aIsStrong)) {
                const n = e.targetPosition._getTransformedByMergeOperation(e),
                  o = t.targetPosition._getTransformedByMergeOperation(e);
                return [new qc(n, t.howMany, o, 0)];
              }
              return [new ml(0)];
            }
            return (
              t.sourcePosition.hasSameParentAs(e.targetPosition) && (t.howMany += e.howMany),
              (t.sourcePosition = t.sourcePosition._getTransformedByMergeOperation(e)),
              (t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e)),
              (t.graveyardPosition.isEqual(e.graveyardPosition) && n.aIsStrong) ||
                (t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)),
              [t]
            );
          }),
          Bu(Wc, qc, (t, e, n) => {
            const o = ba._createFromPositionAndShift(e.sourcePosition, e.howMany);
            return 'remove' == e.type &&
              !n.bWasUndone &&
              !n.forceWeakRemove &&
              t.deletionPosition.hasSameParentAs(e.sourcePosition) &&
              o.containsPosition(t.sourcePosition)
              ? [new ml(0)]
              : (t.sourcePosition.hasSameParentAs(e.targetPosition) && (t.howMany += e.howMany),
                t.sourcePosition.hasSameParentAs(e.sourcePosition) && (t.howMany -= e.howMany),
                (t.sourcePosition = t.sourcePosition._getTransformedByMoveOperation(e)),
                (t.targetPosition = t.targetPosition._getTransformedByMoveOperation(e)),
                t.graveyardPosition.isEqual(e.targetPosition) ||
                  (t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)),
                [t]);
          }),
          Bu(Wc, Uc, (t, e, n) => {
            if (
              (e.graveyardPosition &&
                ((t.graveyardPosition = t.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1)),
                t.deletionPosition.isEqual(e.graveyardPosition) && (t.howMany = e.howMany)),
              t.targetPosition.isEqual(e.splitPosition))
            ) {
              const o = 0 != e.howMany,
                i = e.graveyardPosition && t.deletionPosition.isEqual(e.graveyardPosition);
              if (o || i || 'mergeTargetNotMoved' == n.abRelation)
                return (t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e)), [t];
            }
            if (t.sourcePosition.isEqual(e.splitPosition)) {
              if ('mergeSourceNotMoved' == n.abRelation)
                return (t.howMany = 0), (t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e)), [t];
              if ('mergeSameElement' == n.abRelation || t.sourcePosition.offset > 0)
                return (
                  (t.sourcePosition = e.moveTargetPosition.clone()),
                  (t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e)),
                  [t]
                );
            }
            return (
              t.sourcePosition.hasSameParentAs(e.splitPosition) && (t.howMany = e.splitPosition.offset),
              (t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e)),
              (t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e)),
              [t]
            );
          }),
          Bu(qc, Hc, (t, e) => {
            const n = ba
              ._createFromPositionAndShift(t.sourcePosition, t.howMany)
              ._getTransformedByInsertOperation(e, !1)[0];
            return (
              (t.sourcePosition = n.start),
              (t.howMany = n.end.offset - n.start.offset),
              t.targetPosition.isEqual(e.position) ||
                (t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e)),
              [t]
            );
          }),
          Bu(qc, qc, (t, e, n) => {
            const o = ba._createFromPositionAndShift(t.sourcePosition, t.howMany),
              i = ba._createFromPositionAndShift(e.sourcePosition, e.howMany);
            let r,
              s = n.aIsStrong,
              a = !n.aIsStrong;
            if (
              ('insertBefore' == n.abRelation || 'insertAfter' == n.baRelation
                ? (a = !0)
                : ('insertAfter' != n.abRelation && 'insertBefore' != n.baRelation) || (a = !1),
              (r =
                t.targetPosition.isEqual(e.targetPosition) && a
                  ? t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany)
                  : t.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)),
              Mu(t, e) && Mu(e, t))
            )
              return [e.getReversed()];
            if (o.containsPosition(e.targetPosition) && o.containsRange(i, !0))
              return (
                (o.start = o.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)),
                (o.end = o.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)),
                Nu([o], r)
              );
            if (i.containsPosition(t.targetPosition) && i.containsRange(o, !0))
              return (
                (o.start = o.start._getCombined(e.sourcePosition, e.getMovedRangeStart())),
                (o.end = o.end._getCombined(e.sourcePosition, e.getMovedRangeStart())),
                Nu([o], r)
              );
            const c = bo(t.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
            if ('prefix' == c || 'extension' == c)
              return (
                (o.start = o.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)),
                (o.end = o.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)),
                Nu([o], r)
              );
            'remove' != t.type || 'remove' == e.type || n.aWasUndone || n.forceWeakRemove
              ? 'remove' == t.type || 'remove' != e.type || n.bWasUndone || n.forceWeakRemove || (s = !1)
              : (s = !0);
            const l = [],
              d = o.getDifference(i);
            for (const t of d) {
              (t.start = t.start._getTransformedByDeletion(e.sourcePosition, e.howMany)),
                (t.end = t.end._getTransformedByDeletion(e.sourcePosition, e.howMany));
              const n = 'same' == bo(t.start.getParentPath(), e.getMovedRangeStart().getParentPath()),
                o = t._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, n);
              l.push(...o);
            }
            const h = o.getIntersection(i);
            return (
              null !== h &&
                s &&
                ((h.start = h.start._getCombined(e.sourcePosition, e.getMovedRangeStart())),
                (h.end = h.end._getCombined(e.sourcePosition, e.getMovedRangeStart())),
                0 === l.length
                  ? l.push(h)
                  : 1 == l.length
                  ? i.start.isBefore(o.start) || i.start.isEqual(o.start)
                    ? l.unshift(h)
                    : l.push(h)
                  : l.splice(1, 0, h)),
              0 === l.length ? [new ml(t.baseVersion)] : Nu(l, r)
            );
          }),
          Bu(qc, Uc, (t, e, n) => {
            let o = t.targetPosition.clone();
            (t.targetPosition.isEqual(e.insertionPosition) &&
              e.graveyardPosition &&
              'moveTargetAfter' != n.abRelation) ||
              (o = t.targetPosition._getTransformedBySplitOperation(e));
            const i = ba._createFromPositionAndShift(t.sourcePosition, t.howMany);
            if (i.end.isEqual(e.insertionPosition))
              return e.graveyardPosition || t.howMany++, (t.targetPosition = o), [t];
            if (i.start.hasSameParentAs(e.splitPosition) && i.containsPosition(e.splitPosition)) {
              let t = new ba(e.splitPosition, i.end);
              t = t._getTransformedBySplitOperation(e);
              return Nu([new ba(i.start, e.splitPosition), t], o);
            }
            t.targetPosition.isEqual(e.splitPosition) && 'insertAtSource' == n.abRelation && (o = e.moveTargetPosition),
              t.targetPosition.isEqual(e.insertionPosition) &&
                'insertBetween' == n.abRelation &&
                (o = t.targetPosition);
            const r = [i._getTransformedBySplitOperation(e)];
            if (e.graveyardPosition) {
              const o = i.start.isEqual(e.graveyardPosition) || i.containsPosition(e.graveyardPosition);
              t.howMany > 1 && o && !n.aWasUndone && r.push(ba._createFromPositionAndShift(e.insertionPosition, 1));
            }
            return Nu(r, o);
          }),
          Bu(qc, Wc, (t, e, n) => {
            const o = ba._createFromPositionAndShift(t.sourcePosition, t.howMany);
            if (e.deletionPosition.hasSameParentAs(t.sourcePosition) && o.containsPosition(e.sourcePosition))
              if ('remove' != t.type || n.forceWeakRemove) {
                if (1 == t.howMany)
                  return n.bWasUndone
                    ? ((t.sourcePosition = e.graveyardPosition.clone()),
                      (t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e)),
                      [t])
                    : [new ml(0)];
              } else if (!n.aWasUndone) {
                const n = [];
                let o = e.graveyardPosition.clone(),
                  i = e.targetPosition._getTransformedByMergeOperation(e);
                t.howMany > 1 &&
                  (n.push(new qc(t.sourcePosition, t.howMany - 1, t.targetPosition, 0)),
                  (o = o._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1)),
                  (i = i._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1)));
                const r = e.deletionPosition._getCombined(t.sourcePosition, t.targetPosition),
                  s = new qc(o, 1, r, 0),
                  a = s.getMovedRangeStart().path.slice();
                a.push(0);
                const c = new ma(s.targetPosition.root, a);
                i = i._getTransformedByMove(o, r, 1);
                const l = new qc(i, e.howMany, c, 0);
                return n.push(s), n.push(l), n;
              }
            const i = ba._createFromPositionAndShift(t.sourcePosition, t.howMany)._getTransformedByMergeOperation(e);
            return (
              (t.sourcePosition = i.start),
              (t.howMany = i.end.offset - i.start.offset),
              (t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e)),
              [t]
            );
          }),
          Bu($c, Hc, (t, e) => ((t.position = t.position._getTransformedByInsertOperation(e)), [t])),
          Bu($c, Wc, (t, e) =>
            t.position.isEqual(e.deletionPosition)
              ? ((t.position = e.graveyardPosition.clone()), (t.position.stickiness = 'toNext'), [t])
              : ((t.position = t.position._getTransformedByMergeOperation(e)), [t]),
          ),
          Bu($c, qc, (t, e) => ((t.position = t.position._getTransformedByMoveOperation(e)), [t])),
          Bu($c, $c, (t, e, n) => {
            if (t.position.isEqual(e.position)) {
              if (!n.aIsStrong) return [new ml(0)];
              t.oldName = e.newName;
            }
            return [t];
          }),
          Bu($c, Uc, (t, e) => {
            if ('same' == bo(t.position.path, e.splitPosition.getParentPath()) && !e.graveyardPosition) {
              const e = new $c(t.position.getShiftedBy(1), t.oldName, t.newName, 0);
              return [t, e];
            }
            return (t.position = t.position._getTransformedBySplitOperation(e)), [t];
          }),
          Bu(Gc, Gc, (t, e, n) => {
            if (t.root === e.root && t.key === e.key) {
              if (!n.aIsStrong || t.newValue === e.newValue) return [new ml(0)];
              t.oldValue = e.newValue;
            }
            return [t];
          }),
          Bu(
            Uc,
            Hc,
            (t, e) => (
              t.splitPosition.hasSameParentAs(e.position) &&
                t.splitPosition.offset < e.position.offset &&
                (t.howMany += e.howMany),
              (t.splitPosition = t.splitPosition._getTransformedByInsertOperation(e)),
              (t.insertionPosition = t.insertionPosition._getTransformedByInsertOperation(e)),
              [t]
            ),
          ),
          Bu(Uc, Wc, (t, e, n) => {
            if (!t.graveyardPosition && !n.bWasUndone && t.splitPosition.hasSameParentAs(e.sourcePosition)) {
              const n = e.graveyardPosition.path.slice();
              n.push(0);
              const o = new ma(e.graveyardPosition.root, n),
                i = Uc.getInsertionPosition(new ma(e.graveyardPosition.root, n)),
                r = new Uc(o, 0, i, null, 0);
              return (
                (t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e)),
                (t.insertionPosition = Uc.getInsertionPosition(t.splitPosition)),
                (t.graveyardPosition = r.insertionPosition.clone()),
                (t.graveyardPosition.stickiness = 'toNext'),
                [r, t]
              );
            }
            return (
              t.splitPosition.hasSameParentAs(e.deletionPosition) &&
                !t.splitPosition.isAfter(e.deletionPosition) &&
                t.howMany--,
              t.splitPosition.hasSameParentAs(e.targetPosition) && (t.howMany += e.howMany),
              (t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e)),
              (t.insertionPosition = Uc.getInsertionPosition(t.splitPosition)),
              t.graveyardPosition && (t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)),
              [t]
            );
          }),
          Bu(Uc, qc, (t, e, n) => {
            const o = ba._createFromPositionAndShift(e.sourcePosition, e.howMany);
            if (t.graveyardPosition) {
              const i = o.start.isEqual(t.graveyardPosition) || o.containsPosition(t.graveyardPosition);
              if (!n.bWasUndone && i) {
                const n = t.splitPosition._getTransformedByMoveOperation(e),
                  o = t.graveyardPosition._getTransformedByMoveOperation(e),
                  i = o.path.slice();
                i.push(0);
                const r = new ma(o.root, i);
                return [new qc(n, t.howMany, r, 0)];
              }
              t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e);
            }
            const i = t.splitPosition.isEqual(e.targetPosition);
            if (i && ('insertAtSource' == n.baRelation || 'splitBefore' == n.abRelation))
              return (
                (t.howMany += e.howMany),
                (t.splitPosition = t.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany)),
                (t.insertionPosition = Uc.getInsertionPosition(t.splitPosition)),
                [t]
              );
            if (i && n.abRelation && n.abRelation.howMany) {
              const { howMany: e, offset: o } = n.abRelation;
              return (t.howMany += e), (t.splitPosition = t.splitPosition.getShiftedBy(o)), [t];
            }
            if (t.splitPosition.hasSameParentAs(e.sourcePosition) && o.containsPosition(t.splitPosition)) {
              const n = e.howMany - (t.splitPosition.offset - e.sourcePosition.offset);
              return (
                (t.howMany -= n),
                t.splitPosition.hasSameParentAs(e.targetPosition) &&
                  t.splitPosition.offset < e.targetPosition.offset &&
                  (t.howMany += e.howMany),
                (t.splitPosition = e.sourcePosition.clone()),
                (t.insertionPosition = Uc.getInsertionPosition(t.splitPosition)),
                [t]
              );
            }
            return (
              e.sourcePosition.isEqual(e.targetPosition) ||
                (t.splitPosition.hasSameParentAs(e.sourcePosition) &&
                  t.splitPosition.offset <= e.sourcePosition.offset &&
                  (t.howMany -= e.howMany),
                t.splitPosition.hasSameParentAs(e.targetPosition) &&
                  t.splitPosition.offset < e.targetPosition.offset &&
                  (t.howMany += e.howMany)),
              (t.splitPosition.stickiness = 'toNone'),
              (t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e)),
              (t.splitPosition.stickiness = 'toNext'),
              t.graveyardPosition
                ? (t.insertionPosition = t.insertionPosition._getTransformedByMoveOperation(e))
                : (t.insertionPosition = Uc.getInsertionPosition(t.splitPosition)),
              [t]
            );
          }),
          Bu(Uc, Uc, (t, e, n) => {
            if (t.splitPosition.isEqual(e.splitPosition)) {
              if (!t.graveyardPosition && !e.graveyardPosition) return [new ml(0)];
              if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition))
                return [new ml(0)];
              if ('splitBefore' == n.abRelation)
                return (
                  (t.howMany = 0), (t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e)), [t]
                );
            }
            if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) {
              const o = '$graveyard' == t.splitPosition.root.rootName,
                i = '$graveyard' == e.splitPosition.root.rootName,
                r = o && !i;
              if ((i && !o) || (!r && n.aIsStrong)) {
                const n = [];
                return (
                  e.howMany && n.push(new qc(e.moveTargetPosition, e.howMany, e.splitPosition, 0)),
                  t.howMany && n.push(new qc(t.splitPosition, t.howMany, t.moveTargetPosition, 0)),
                  n
                );
              }
              return [new ml(0)];
            }
            if (
              (t.graveyardPosition && (t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e)),
              t.splitPosition.isEqual(e.insertionPosition) && 'splitBefore' == n.abRelation)
            )
              return t.howMany++, [t];
            if (e.splitPosition.isEqual(t.insertionPosition) && 'splitBefore' == n.baRelation) {
              const n = e.insertionPosition.path.slice();
              n.push(0);
              const o = new ma(e.insertionPosition.root, n);
              return [t, new qc(t.insertionPosition, 1, o, 0)];
            }
            return (
              t.splitPosition.hasSameParentAs(e.splitPosition) &&
                t.splitPosition.offset < e.splitPosition.offset &&
                (t.howMany -= e.howMany),
              (t.splitPosition = t.splitPosition._getTransformedBySplitOperation(e)),
              (t.insertionPosition = Uc.getInsertionPosition(t.splitPosition)),
              [t]
            );
          });
        class Vu extends ms {
          constructor(t) {
            super(t), (this.domEventType = 'click');
          }
          onDomEvent(t) {
            this.fire(t.type, t);
          }
        }
        class Lu extends ms {
          constructor(t) {
            super(t), (this.domEventType = ['mousedown', 'mouseup', 'mouseover', 'mouseout']);
          }
          onDomEvent(t) {
            this.fire(t.type, t);
          }
        }
        class Ku {
          constructor(t) {
            this.document = t;
          }
          createDocumentFragment(t) {
            return new Xi(this.document, t);
          }
          createElement(t, e, n) {
            return new li(this.document, t, e, n);
          }
          createText(t) {
            return new _o(this.document, t);
          }
          clone(t, e = !1) {
            return t._clone(e);
          }
          appendChild(t, e) {
            return e._appendChild(t);
          }
          insertChild(t, e, n) {
            return n._insertChild(t, e);
          }
          removeChildren(t, e, n) {
            return n._removeChildren(t, e);
          }
          remove(t) {
            const e = t.parent;
            return e ? this.removeChildren(e.getChildIndex(t), 1, e) : [];
          }
          replace(t, e) {
            const n = t.parent;
            if (n) {
              const o = n.getChildIndex(t);
              return this.removeChildren(o, 1, n), this.insertChild(o, e, n), !0;
            }
            return !1;
          }
          unwrapElement(t) {
            const e = t.parent;
            if (e) {
              const n = e.getChildIndex(t);
              this.remove(t), this.insertChild(n, t.getChildren(), e);
            }
          }
          rename(t, e) {
            const n = new li(this.document, t, e.getAttributes(), e.getChildren());
            return this.replace(e, n) ? n : null;
          }
          setAttribute(t, e, n) {
            n._setAttribute(t, e);
          }
          removeAttribute(t, e) {
            e._removeAttribute(t);
          }
          addClass(t, e) {
            e._addClass(t);
          }
          removeClass(t, e) {
            e._removeClass(t);
          }
          setStyle(t, e, n) {
            le(t) && void 0 === n && (n = e), n._setStyle(t, e);
          }
          removeStyle(t, e) {
            e._removeStyle(t);
          }
          setCustomProperty(t, e, n) {
            n._setCustomProperty(t, e);
          }
          removeCustomProperty(t, e) {
            return e._removeCustomProperty(t);
          }
          createPositionAt(t, e) {
            return ki._createAt(t, e);
          }
          createPositionAfter(t) {
            return ki._createAfter(t);
          }
          createPositionBefore(t) {
            return ki._createBefore(t);
          }
          createRange(t, e) {
            return new bi(t, e);
          }
          createRangeOn(t) {
            return bi._createOn(t);
          }
          createRangeIn(t) {
            return bi._createIn(t);
          }
          createSelection(t, e, n) {
            return new _i(t, e, n);
          }
        }
        const qu = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i,
          Hu = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i,
          ju = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i,
          $u = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i,
          Gu = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i,
          Wu = new Set([
            'black',
            'silver',
            'gray',
            'white',
            'maroon',
            'red',
            'purple',
            'fuchsia',
            'green',
            'lime',
            'olive',
            'yellow',
            'navy',
            'blue',
            'teal',
            'aqua',
            'orange',
            'aliceblue',
            'antiquewhite',
            'aquamarine',
            'azure',
            'beige',
            'bisque',
            'blanchedalmond',
            'blueviolet',
            'brown',
            'burlywood',
            'cadetblue',
            'chartreuse',
            'chocolate',
            'coral',
            'cornflowerblue',
            'cornsilk',
            'crimson',
            'cyan',
            'darkblue',
            'darkcyan',
            'darkgoldenrod',
            'darkgray',
            'darkgreen',
            'darkgrey',
            'darkkhaki',
            'darkmagenta',
            'darkolivegreen',
            'darkorange',
            'darkorchid',
            'darkred',
            'darksalmon',
            'darkseagreen',
            'darkslateblue',
            'darkslategray',
            'darkslategrey',
            'darkturquoise',
            'darkviolet',
            'deeppink',
            'deepskyblue',
            'dimgray',
            'dimgrey',
            'dodgerblue',
            'firebrick',
            'floralwhite',
            'forestgreen',
            'gainsboro',
            'ghostwhite',
            'gold',
            'goldenrod',
            'greenyellow',
            'grey',
            'honeydew',
            'hotpink',
            'indianred',
            'indigo',
            'ivory',
            'khaki',
            'lavender',
            'lavenderblush',
            'lawngreen',
            'lemonchiffon',
            'lightblue',
            'lightcoral',
            'lightcyan',
            'lightgoldenrodyellow',
            'lightgray',
            'lightgreen',
            'lightgrey',
            'lightpink',
            'lightsalmon',
            'lightseagreen',
            'lightskyblue',
            'lightslategray',
            'lightslategrey',
            'lightsteelblue',
            'lightyellow',
            'limegreen',
            'linen',
            'magenta',
            'mediumaquamarine',
            'mediumblue',
            'mediumorchid',
            'mediumpurple',
            'mediumseagreen',
            'mediumslateblue',
            'mediumspringgreen',
            'mediumturquoise',
            'mediumvioletred',
            'midnightblue',
            'mintcream',
            'mistyrose',
            'moccasin',
            'navajowhite',
            'oldlace',
            'olivedrab',
            'orangered',
            'orchid',
            'palegoldenrod',
            'palegreen',
            'paleturquoise',
            'palevioletred',
            'papayawhip',
            'peachpuff',
            'peru',
            'pink',
            'plum',
            'powderblue',
            'rosybrown',
            'royalblue',
            'saddlebrown',
            'salmon',
            'sandybrown',
            'seagreen',
            'seashell',
            'sienna',
            'skyblue',
            'slateblue',
            'slategray',
            'slategrey',
            'snow',
            'springgreen',
            'steelblue',
            'tan',
            'thistle',
            'tomato',
            'turquoise',
            'violet',
            'wheat',
            'whitesmoke',
            'yellowgreen',
            'rebeccapurple',
            'currentcolor',
            'transparent',
          ]);
        function Uu(t) {
          return t.startsWith('#')
            ? qu.test(t)
            : t.startsWith('rgb')
            ? Hu.test(t) || ju.test(t)
            : t.startsWith('hsl')
            ? $u.test(t) || Gu.test(t)
            : Wu.has(t.toLowerCase());
        }
        const Ju = /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;
        function Yu(t) {
          return Ju.test(t);
        }
        const Qu = /^[+-]?[0-9]*([.][0-9]+)?%$/;
        const Xu = ['repeat-x', 'repeat-y', 'repeat', 'space', 'round', 'no-repeat'];
        const Zu = ['center', 'top', 'bottom', 'left', 'right'];
        function tp(t) {
          return Zu.includes(t);
        }
        const ep = ['fixed', 'scroll', 'local'];
        function np(t) {
          return ep.includes(t);
        }
        const op = /^url\(/;
        function ip(t) {
          return op.test(t);
        }
        function rp(t = '') {
          if ('' === t) return { top: void 0, right: void 0, bottom: void 0, left: void 0 };
          const e = lp(t),
            n = e[0],
            o = e[2] || n,
            i = e[1] || n;
          return { top: n, bottom: o, right: i, left: e[3] || i };
        }
        function sp(t) {
          return e => {
            const { top: n, right: o, bottom: i, left: r } = e,
              s = [];
            return (
              [n, o, r, i].every(t => !!t)
                ? s.push([t, ap(e)])
                : (n && s.push([t + '-top', n]),
                  o && s.push([t + '-right', o]),
                  i && s.push([t + '-bottom', i]),
                  r && s.push([t + '-left', r])),
              s
            );
          };
        }
        function ap({ top: t, right: e, bottom: n, left: o }) {
          const i = [];
          return (
            o !== e ? i.push(t, e, n, o) : n !== t ? i.push(t, e, n) : e !== t ? i.push(t, e) : i.push(t), i.join(' ')
          );
        }
        function cp(t) {
          return e => ({ path: t, value: rp(e) });
        }
        function lp(t) {
          return t
            .replace(/, /g, ',')
            .split(' ')
            .map(t => t.replace(/,/g, ', '));
        }
        function dp(t) {
          t.setNormalizer('background', hp),
            t.setNormalizer('background-color', t => ({ path: 'background.color', value: t })),
            t.setReducer('background', t => {
              const e = [];
              return e.push(['background-color', t.color]), e;
            });
        }
        function hp(t) {
          const e = {},
            n = lp(t);
          for (const t of n)
            (o = t),
              Xu.includes(o)
                ? ((e.repeat = e.repeat || []), e.repeat.push(t))
                : tp(t)
                ? ((e.position = e.position || []), e.position.push(t))
                : np(t)
                ? (e.attachment = t)
                : Uu(t)
                ? (e.color = t)
                : ip(t) && (e.image = t);
          var o;
          return { path: 'background', value: e };
        }
        function up(t) {
          t.setNormalizer('margin', cp('margin')),
            t.setNormalizer('margin-top', t => ({ path: 'margin.top', value: t })),
            t.setNormalizer('margin-right', t => ({ path: 'margin.right', value: t })),
            t.setNormalizer('margin-bottom', t => ({ path: 'margin.bottom', value: t })),
            t.setNormalizer('margin-left', t => ({ path: 'margin.left', value: t })),
            t.setReducer('margin', sp('margin')),
            t.setStyleRelation('margin', ['margin-top', 'margin-right', 'margin-bottom', 'margin-left']);
        }
        class pp extends Kl {
          constructor(t, e) {
            super(t), (this.view = e);
          }
          init() {
            const t = this.editor,
              e = this.view,
              n = t.editing.view,
              o = e.editable,
              i = n.document.getRoot();
            (e.editable.name = i.rootName), e.render();
            const r = o.element;
            this.setEditableElement(o.name, r),
              this.focusTracker.add(r),
              e.editable.bind('isFocused').to(this.focusTracker),
              n.attachDomRoot(r),
              this._initPlaceholder(),
              this._initToolbar(),
              this.fire('ready');
          }
          destroy() {
            const t = this.view;
            this.editor.editing.view.detachDomRoot(t.editable.name), t.destroy(), super.destroy();
          }
          _initToolbar() {
            const t = this.editor,
              e = this.view.toolbar;
            e.fillFromConfig(t.config.get('toolbar'), this.componentFactory),
              (function ({
                origin: t,
                originKeystrokeHandler: e,
                originFocusTracker: n,
                toolbar: o,
                beforeFocus: i,
                afterBlur: r,
              }) {
                n.add(o.element),
                  e.set('Alt+F10', (t, e) => {
                    n.isFocused && !o.focusTracker.isFocused && (i && i(), o.focus(), e());
                  }),
                  o.keystrokes.set('Esc', (e, n) => {
                    o.focusTracker.isFocused && (t.focus(), r && r(), n());
                  });
              })({
                origin: t.editing.view,
                originFocusTracker: this.focusTracker,
                originKeystrokeHandler: t.keystrokes,
                toolbar: e,
              });
          }
          _initPlaceholder() {
            const t = this.editor,
              e = t.editing.view,
              n = e.document.getRoot(),
              o = t.sourceElement,
              i =
                t.config.get('placeholder') ||
                (o && 'textarea' === o.tagName.toLowerCase() && o.getAttribute('placeholder'));
            i && vu({ view: e, element: n, text: i, isDirectHost: !1, keepOnFocus: !0 });
          }
        }
        class mp extends Mh {
          constructor(t, e, n = {}) {
            super(t),
              (this.toolbar = new wh(t, { shouldGroupWhenFull: n.shouldToolbarGroupWhenFull })),
              (this.editable = new qh(t, e, n.editableElement)),
              this.toolbar.extendTemplate({
                attributes: { class: ['ck-reset_all', 'ck-rounded-corners'], dir: t.uiLanguageDirection },
              });
          }
          render() {
            super.render(), this.registerChild([this.toolbar, this.editable]);
          }
        }
        class gp extends Nl {
          constructor(t, e) {
            super(e),
              oo(t) &&
                ((this.sourceElement = t),
                (function (t) {
                  const e = t.sourceElement;
                  if (e) {
                    if (e.ckeditorInstance) throw new c.a('editor-source-element-already-used', t);
                    (e.ckeditorInstance = t),
                      t.once('destroy', () => {
                        delete e.ckeditorInstance;
                      });
                  }
                })(this)),
              this.model.document.createRoot();
            const n = !this.config.get('toolbar.shouldNotGroupWhenFull'),
              o = new mp(this.locale, this.editing.view, {
                editableElement: this.sourceElement,
                shouldToolbarGroupWhenFull: n,
              });
            this.ui = new pp(this, o);
          }
          destroy() {
            const t = this.getData();
            return (
              this.ui.destroy(),
              super.destroy().then(() => {
                this.sourceElement && js(this.sourceElement, t);
              })
            );
          }
          static create(t, e = {}) {
            return new Promise(n => {
              const o = oo(t);
              if (o && 'TEXTAREA' === t.tagName) throw new c.a('editor-wrong-element', null);
              const i = new this(t, e);
              n(
                i
                  .initPlugins()
                  .then(() => {
                    i.ui.init();
                  })
                  .then(() => {
                    if (!o && e.initialData) throw new c.a('editor-create-initial-data', null);
                    const n =
                      void 0 !== e.initialData
                        ? e.initialData
                        : (function (t) {
                            return oo(t) ? ((e = t), e instanceof HTMLTextAreaElement ? e.value : e.innerHTML) : t;
                            var e;
                          })(t);
                    return i.data.init(n);
                  })
                  .then(() => i.fire('ready'))
                  .then(() => i),
              );
            });
          }
        }
        Yt(gp, ql);
        const fp = ['left', 'right', 'center', 'justify'];
        function kp(t) {
          return fp.includes(t);
        }
        function bp(t, e) {
          return 'rtl' == e.contentLanguageDirection ? 'right' === t : 'left' === t;
        }
        function wp(t) {
          const e = t
              .map(t => {
                let e;
                return (e = 'string' == typeof t ? { name: t } : t), e;
              })
              .filter(t => {
                const e = !!fp.includes(t.name);
                return e || Object(c.b)('alignment-config-name-not-recognized', { option: t }), e;
              }),
            n = e.filter(t => !!t.className).length;
          if (n && n < e.length) throw new c.a('alignment-config-classnames-are-missing', { configuredOptions: t });
          return (
            e.forEach((e, n, o) => {
              const i = o.slice(n + 1);
              if (i.some(t => t.name == e.name))
                throw new c.a('alignment-config-name-already-defined', { option: e, configuredOptions: t });
              if (e.className) {
                if (i.some(t => t.className == e.className))
                  throw new c.a('alignment-config-classname-already-defined', { option: e, configuredOptions: t });
              }
            }),
            e
          );
        }
        const Ap = 'alignment';
        class _p extends Zt {
          refresh() {
            const t = this.editor.locale,
              e = Gs(this.editor.model.document.selection.getSelectedBlocks());
            (this.isEnabled = !!e && this._canBeAligned(e)),
              this.isEnabled && e.hasAttribute('alignment')
                ? (this.value = e.getAttribute('alignment'))
                : (this.value = 'rtl' === t.contentLanguageDirection ? 'right' : 'left');
          }
          execute(t = {}) {
            const e = this.editor,
              n = e.locale,
              o = e.model,
              i = o.document,
              r = t.value;
            o.change(t => {
              const e = Array.from(i.selection.getSelectedBlocks()).filter(t => this._canBeAligned(t)),
                o = e[0].getAttribute('alignment');
              bp(r, n) || o === r || !r
                ? (function (t, e) {
                    for (const n of t) e.removeAttribute(Ap, n);
                  })(e, t)
                : (function (t, e, n) {
                    for (const o of t) e.setAttribute(Ap, n, o);
                  })(e, t, r);
            });
          }
          _canBeAligned(t) {
            return this.editor.model.schema.checkAttribute(t, Ap);
          }
        }
        class Cp extends Qt {
          static get pluginName() {
            return 'AlignmentEditing';
          }
          constructor(t) {
            super(t), t.config.define('alignment', { options: [...fp.map(t => ({ name: t }))] });
          }
          init() {
            const t = this.editor,
              e = t.locale,
              n = t.model.schema,
              o = wp(t.config.get('alignment.options')).filter(t => kp(t.name) && !bp(t.name, e)),
              i = o.some(t => !!t.className);
            n.extend('$block', { allowAttributes: 'alignment' }),
              t.model.schema.setAttributeProperties('alignment', { isFormatting: !0 }),
              i
                ? t.conversion.attributeToAttribute(
                    (function (t) {
                      const e = { model: { key: 'alignment', values: t.map(t => t.name) }, view: {} };
                      for (const n of t) e.view[n.name] = { key: 'class', value: n.className };
                      return e;
                    })(o),
                  )
                : t.conversion.for('downcast').attributeToAttribute(
                    (function (t) {
                      const e = { model: { key: 'alignment', values: t.map(t => t.name) }, view: {} };
                      for (const { name: n } of t) e.view[n] = { key: 'style', value: { 'text-align': n } };
                      return e;
                    })(o),
                  );
            const r = (function (t) {
              const e = [];
              for (const { name: n } of t)
                e.push({ view: { key: 'style', value: { 'text-align': n } }, model: { key: 'alignment', value: n } });
              return e;
            })(o);
            for (const e of r) t.conversion.for('upcast').attributeToAttribute(e);
            const s = (function (t) {
              const e = [];
              for (const { name: n } of t)
                e.push({ view: { key: 'align', value: n }, model: { key: 'alignment', value: n } });
              return e;
            })(o);
            for (const e of s) t.conversion.for('upcast').attributeToAttribute(e);
            t.commands.add('alignment', new _p(t));
          }
        }
        const vp = new Map([
          ['left', Jl],
          ['right', Ql],
          ['center', Yl],
          ['justify', Xl],
        ]);
        class yp extends Qt {
          get localizedOptionTitles() {
            const t = this.editor.t;
            return { left: t('Align left'), right: t('Align right'), center: t('Align center'), justify: t('Justify') };
          }
          static get pluginName() {
            return 'AlignmentUI';
          }
          init() {
            const t = this.editor,
              e = t.ui.componentFactory,
              n = t.t,
              o = wp(t.config.get('alignment.options'));
            o
              .map(t => t.name)
              .filter(kp)
              .forEach(t => this._addButton(t)),
              e.add('alignment', t => {
                const i = Ih(t),
                  r = o.map(t => e.create(`alignment:${t.name}`));
                zh(i, r),
                  i.buttonView.set({ label: n('Text alignment'), tooltip: !0 }),
                  (i.toolbarView.isVertical = !0),
                  (i.toolbarView.ariaLabel = n('Text alignment toolbar')),
                  i.extendTemplate({ attributes: { class: 'ck-alignment-dropdown' } });
                const s = 'rtl' === t.contentLanguageDirection ? vp.get('right') : vp.get('left');
                return (
                  i.buttonView.bind('icon').toMany(r, 'isOn', (...t) => {
                    const e = t.findIndex(t => t);
                    return e < 0 ? s : r[e].icon;
                  }),
                  i.bind('isEnabled').toMany(r, 'isEnabled', (...t) => t.some(t => t)),
                  i
                );
              });
          }
          _addButton(t) {
            const e = this.editor;
            e.ui.componentFactory.add(`alignment:${t}`, n => {
              const o = e.commands.get('alignment'),
                i = new jd(n);
              return (
                i.set({ label: this.localizedOptionTitles[t], icon: vp.get(t), tooltip: !0, isToggleable: !0 }),
                i.bind('isEnabled').to(o),
                i.bind('isOn').to(o, 'value', e => e === t),
                this.listenTo(i, 'execute', () => {
                  e.execute('alignment', { value: t }), e.editing.view.focus();
                }),
                i
              );
            });
          }
        }
        function xp(t, e, n, o) {
          let i,
            r = null;
          'function' == typeof o
            ? (i = o)
            : ((r = t.commands.get(o)),
              (i = () => {
                t.execute(o);
              })),
            t.model.document.on('change:data', (s, a) => {
              if ((r && !r.isEnabled) || !e.isEnabled) return;
              const c = Gs(t.model.document.selection.getRanges());
              if (!c.isCollapsed) return;
              if ('transparent' == a.type) return;
              const l = Array.from(t.model.document.differ.getChanges()),
                d = l[0];
              if (1 != l.length || 'insert' !== d.type || '$text' != d.name || 1 != d.length) return;
              const h = d.position.parent;
              if (h.is('element', 'codeBlock')) return;
              if (
                h.is('element', 'listItem') &&
                'function' != typeof o &&
                !['numberedList', 'bulletedList', 'todoList'].includes(o)
              )
                return;
              if (r && !0 === r.value) return;
              const u = h.getChild(0),
                p = t.model.createRangeOn(u);
              if (!p.containsRange(c) && !c.end.isEqual(p.end)) return;
              const m = n.exec(u.data.substr(0, c.end.offset));
              m &&
                t.model.enqueueChange(e => {
                  const n = e.createPositionAt(h, 0),
                    o = e.createPositionAt(h, m[0].length),
                    r = new Pa(n, o);
                  if (!1 !== i({ match: m })) {
                    e.remove(r);
                    const n = t.model.document.selection.getFirstRange(),
                      o = e.createRangeIn(h);
                    !h.isEmpty || o.isEqual(n) || o.containsRange(n, !0) || e.remove(h);
                  }
                  r.detach();
                });
            });
        }
        function Ep(t, e, n, o) {
          let i, r;
          n instanceof RegExp ? (i = n) : (r = n),
            (r =
              r ||
              (t => {
                let e;
                const n = [],
                  o = [];
                for (; null !== (e = i.exec(t)) && !(e && e.length < 4); ) {
                  let { index: t, 1: i, 2: r, 3: s } = e;
                  const a = i + r + s;
                  t += e[0].length - a.length;
                  const c = [t, t + i.length],
                    l = [t + i.length + r.length, t + i.length + r.length + s.length];
                  n.push(c), n.push(l), o.push([t + i.length, t + i.length + r.length]);
                }
                return { remove: n, format: o };
              })),
            t.model.document.on('change:data', (n, i) => {
              if ('transparent' == i.type || !e.isEnabled) return;
              const s = t.model,
                a = s.document.selection;
              if (!a.isCollapsed) return;
              const c = Array.from(s.document.differ.getChanges()),
                l = c[0];
              if (1 != c.length || 'insert' !== l.type || '$text' != l.name || 1 != l.length) return;
              const d = a.focus,
                h = d.parent,
                { text: u, range: p } = (function (t, e) {
                  let n = t.start;
                  return {
                    text: Array.from(t.getItems()).reduce(
                      (t, o) =>
                        (!o.is('$text') && !o.is('$textProxy')) || o.getAttribute('code')
                          ? ((n = e.createPositionAfter(o)), '')
                          : t + o.data,
                      '',
                    ),
                    range: e.createRange(n, t.end),
                  };
                })(s.createRange(s.createPositionAt(h, 0), d), s),
                m = r(u),
                g = Dp(p.start, m.format, s),
                f = Dp(p.start, m.remove, s);
              g.length &&
                f.length &&
                s.enqueueChange(t => {
                  if (!1 !== o(t, g)) for (const e of f.reverse()) t.remove(e);
                });
            });
        }
        function Dp(t, e, n) {
          return e
            .filter(t => void 0 !== t[0] && void 0 !== t[1])
            .map(e => n.createRange(t.getShiftedBy(e[0]), t.getShiftedBy(e[1])));
        }
        function Sp(t, e) {
          return (n, o) => {
            if (!t.commands.get(e).isEnabled) return !1;
            const i = t.model.schema.getValidRanges(o, e);
            for (const t of i) n.setAttribute(e, !0, t);
            n.removeSelectionAttribute(e);
          };
        }
        class Bp {
          constructor() {
            const t = new window.FileReader();
            (this._reader = t),
              (this._data = void 0),
              this.set('loaded', 0),
              (t.onprogress = t => {
                this.loaded = t.loaded;
              });
          }
          get error() {
            return this._reader.error;
          }
          get data() {
            return this._data;
          }
          read(t) {
            const e = this._reader;
            return (
              (this.total = t.size),
              new Promise((n, o) => {
                (e.onload = () => {
                  const t = e.result;
                  (this._data = t), n(t);
                }),
                  (e.onerror = () => {
                    o('error');
                  }),
                  (e.onabort = () => {
                    o('aborted');
                  }),
                  this._reader.readAsDataURL(t);
              })
            );
          }
          abort() {
            this._reader.abort();
          }
        }
        Yt(Bp, jt);
        class Tp extends Qt {
          static get pluginName() {
            return 'FileRepository';
          }
          static get requires() {
            return [Hl];
          }
          init() {
            (this.loaders = new co()),
              this.loaders.on('add', () => this._updatePendingAction()),
              this.loaders.on('remove', () => this._updatePendingAction()),
              (this._loadersMap = new Map()),
              (this._pendingAction = null),
              this.set('uploaded', 0),
              this.set('uploadTotal', null),
              this.bind('uploadedPercent').to(this, 'uploaded', this, 'uploadTotal', (t, e) => (e ? (t / e) * 100 : 0));
          }
          getLoader(t) {
            return this._loadersMap.get(t) || null;
          }
          createLoader(t) {
            if (!this.createUploadAdapter) return Object(c.b)('filerepository-no-upload-adapter'), null;
            const e = new Pp(Promise.resolve(t), this.createUploadAdapter);
            return (
              this.loaders.add(e),
              this._loadersMap.set(t, e),
              t instanceof Promise &&
                e.file
                  .then(t => {
                    this._loadersMap.set(t, e);
                  })
                  .catch(() => {}),
              e.on('change:uploaded', () => {
                let t = 0;
                for (const e of this.loaders) t += e.uploaded;
                this.uploaded = t;
              }),
              e.on('change:uploadTotal', () => {
                let t = 0;
                for (const e of this.loaders) e.uploadTotal && (t += e.uploadTotal);
                this.uploadTotal = t;
              }),
              e
            );
          }
          destroyLoader(t) {
            const e = t instanceof Pp ? t : this.getLoader(t);
            e._destroy(),
              this.loaders.remove(e),
              this._loadersMap.forEach((t, n) => {
                t === e && this._loadersMap.delete(n);
              });
          }
          _updatePendingAction() {
            const t = this.editor.plugins.get(Hl);
            if (this.loaders.length) {
              if (!this._pendingAction) {
                const e = this.editor.t,
                  n = t => `${e('Upload in progress')} ${parseInt(t)}%.`;
                (this._pendingAction = t.add(n(this.uploadedPercent))),
                  this._pendingAction.bind('message').to(this, 'uploadedPercent', n);
              }
            } else t.remove(this._pendingAction), (this._pendingAction = null);
          }
        }
        Yt(Tp, jt);
        class Pp {
          constructor(t, e) {
            (this.id = s()),
              (this._filePromiseWrapper = this._createFilePromiseWrapper(t)),
              (this._adapter = e(this)),
              (this._reader = new Bp()),
              this.set('status', 'idle'),
              this.set('uploaded', 0),
              this.set('uploadTotal', null),
              this.bind('uploadedPercent').to(this, 'uploaded', this, 'uploadTotal', (t, e) => (e ? (t / e) * 100 : 0)),
              this.set('uploadResponse', null);
          }
          get file() {
            return this._filePromiseWrapper
              ? this._filePromiseWrapper.promise.then(t => (this._filePromiseWrapper ? t : null))
              : Promise.resolve(null);
          }
          get data() {
            return this._reader.data;
          }
          read() {
            if ('idle' != this.status) throw new c.a('filerepository-read-wrong-status', this);
            return (
              (this.status = 'reading'),
              this.file
                .then(t => this._reader.read(t))
                .then(t => {
                  if ('reading' !== this.status) throw this.status;
                  return (this.status = 'idle'), t;
                })
                .catch(t => {
                  if ('aborted' === t) throw ((this.status = 'aborted'), 'aborted');
                  throw ((this.status = 'error'), this._reader.error ? this._reader.error : t);
                })
            );
          }
          upload() {
            if ('idle' != this.status) throw new c.a('filerepository-upload-wrong-status', this);
            return (
              (this.status = 'uploading'),
              this.file
                .then(() => this._adapter.upload())
                .then(t => ((this.uploadResponse = t), (this.status = 'idle'), t))
                .catch(t => {
                  if ('aborted' === this.status) throw 'aborted';
                  throw ((this.status = 'error'), t);
                })
            );
          }
          abort() {
            const t = this.status;
            (this.status = 'aborted'),
              this._filePromiseWrapper.isFulfilled
                ? 'reading' == t
                  ? this._reader.abort()
                  : 'uploading' == t && this._adapter.abort && this._adapter.abort()
                : (this._filePromiseWrapper.promise.catch(() => {}), this._filePromiseWrapper.rejecter('aborted')),
              this._destroy();
          }
          _destroy() {
            (this._filePromiseWrapper = void 0),
              (this._reader = void 0),
              (this._adapter = void 0),
              (this.uploadResponse = void 0);
          }
          _createFilePromiseWrapper(t) {
            const e = {};
            return (
              (e.promise = new Promise((n, o) => {
                (e.rejecter = o),
                  (e.isFulfilled = !1),
                  t
                    .then(t => {
                      (e.isFulfilled = !0), n(t);
                    })
                    .catch(t => {
                      (e.isFulfilled = !0), o(t);
                    });
              })),
              e
            );
          }
        }
        Yt(Pp, jt);
        class Ip {
          constructor(t) {
            this.loader = t;
          }
          upload() {
            return new Promise((t, e) => {
              const n = (this.reader = new window.FileReader());
              n.addEventListener('load', () => {
                t({ default: n.result });
              }),
                n.addEventListener('error', t => {
                  e(t);
                }),
                n.addEventListener('abort', () => {
                  e();
                }),
                this.loader.file.then(t => {
                  n.readAsDataURL(t);
                });
            });
          }
          abort() {
            this.reader.abort();
          }
        }
        function* zp(t, e) {
          for (const n of e) n && t.getAttributeProperties(n[0]).copyOnEnter && (yield n);
        }
        class Fp extends Zt {
          execute() {
            const t = this.editor.model,
              e = t.document;
            t.change(n => {
              !(function (t, e, n, o) {
                const i = n.isCollapsed,
                  r = n.getFirstRange(),
                  s = r.start.parent,
                  a = r.end.parent;
                if (o.isLimit(s) || o.isLimit(a)) return void (i || s != a || t.deleteContent(n));
                if (i) {
                  const t = zp(e.model.schema, n.getAttributes());
                  Rp(e, r.start), e.setSelectionAttribute(t);
                } else {
                  const o = !(r.start.isAtStart && r.end.isAtEnd),
                    i = s == a;
                  t.deleteContent(n, { leaveUnmerged: o }), o && (i ? Rp(e, n.focus) : e.setSelection(a, 0));
                }
              })(this.editor.model, n, e.selection, t.schema),
                this.fire('afterExecute', { writer: n });
            });
          }
        }
        function Rp(t, e) {
          t.split(e), t.setSelection(e.parent.nextSibling, 0);
        }
        class Op extends jr {
          constructor(t) {
            super(t);
            const e = this.document;
            e.on('keydown', (t, n) => {
              if (this.isEnabled && n.keyCode == Li.enter) {
                const o = new vi(e, 'enter', e.selection.getFirstRange());
                e.fire(o, new ps(e, n.domEvent, { isSoft: n.shiftKey })), o.stop.called && t.stop();
              }
            });
          }
          observe() {}
        }
        class Mp extends Qt {
          static get pluginName() {
            return 'Enter';
          }
          init() {
            const t = this.editor,
              e = t.editing.view,
              n = e.document;
            e.addObserver(Op),
              t.commands.add('enter', new Fp(t)),
              this.listenTo(
                n,
                'enter',
                (n, o) => {
                  o.preventDefault(), o.isSoft || (t.execute('enter'), e.scrollToTheSelection());
                },
                { priority: 'low' },
              );
          }
        }
        class Np extends Zt {
          execute() {
            const t = this.editor.model,
              e = t.document;
            t.change(n => {
              !(function (t, e, n) {
                const o = n.isCollapsed,
                  i = n.getFirstRange(),
                  r = i.start.parent,
                  s = i.end.parent,
                  a = r == s;
                if (o) {
                  const o = zp(t.schema, n.getAttributes());
                  Vp(t, e, i.end), e.removeSelectionAttribute(n.getAttributeKeys()), e.setSelectionAttribute(o);
                } else {
                  const o = !(i.start.isAtStart && i.end.isAtEnd);
                  t.deleteContent(n, { leaveUnmerged: o }), a ? Vp(t, e, n.focus) : o && e.setSelection(s, 0);
                }
              })(t, n, e.selection),
                this.fire('afterExecute', { writer: n });
            });
          }
          refresh() {
            const t = this.editor.model,
              e = t.document;
            this.isEnabled = (function (t, e) {
              if (e.rangeCount > 1) return !1;
              const n = e.anchor;
              if (!n || !t.checkChild(n, 'softBreak')) return !1;
              const o = e.getFirstRange(),
                i = o.start.parent,
                r = o.end.parent;
              if ((Lp(i, t) || Lp(r, t)) && i !== r) return !1;
              return !0;
            })(t.schema, e.selection);
          }
        }
        function Vp(t, e, n) {
          const o = e.createElement('softBreak');
          t.insertContent(o, n), e.setSelection(o, 'after');
        }
        function Lp(t, e) {
          return !t.is('rootElement') && (e.isLimit(t) || Lp(t.parent, e));
        }
        class Kp extends Qt {
          static get pluginName() {
            return 'ShiftEnter';
          }
          init() {
            const t = this.editor,
              e = t.model.schema,
              n = t.conversion,
              o = t.editing.view,
              i = o.document;
            e.register('softBreak', { allowWhere: '$text', isInline: !0 }),
              n.for('upcast').elementToElement({ model: 'softBreak', view: 'br' }),
              n
                .for('downcast')
                .elementToElement({ model: 'softBreak', view: (t, { writer: e }) => e.createEmptyElement('br') }),
              o.addObserver(Op),
              t.commands.add('shiftEnter', new Np(t)),
              this.listenTo(
                i,
                'enter',
                (e, n) => {
                  n.preventDefault(), n.isSoft && (t.execute('shiftEnter'), o.scrollToTheSelection());
                },
                { priority: 'low' },
              );
          }
        }
        class qp {
          constructor(t, e = 20) {
            (this.model = t),
              (this.size = 0),
              (this.limit = e),
              (this.isLocked = !1),
              (this._changeCallback = (t, e) => {
                'transparent' != e.type && e !== this._batch && this._reset(!0);
              }),
              (this._selectionChangeCallback = () => {
                this._reset();
              }),
              this.model.document.on('change', this._changeCallback),
              this.model.document.selection.on('change:range', this._selectionChangeCallback),
              this.model.document.selection.on('change:attribute', this._selectionChangeCallback);
          }
          get batch() {
            return this._batch || (this._batch = this.model.createBatch()), this._batch;
          }
          input(t) {
            (this.size += t), this.size >= this.limit && this._reset(!0);
          }
          lock() {
            this.isLocked = !0;
          }
          unlock() {
            this.isLocked = !1;
          }
          destroy() {
            this.model.document.off('change', this._changeCallback),
              this.model.document.selection.off('change:range', this._selectionChangeCallback),
              this.model.document.selection.off('change:attribute', this._selectionChangeCallback);
          }
          _reset(t) {
            (this.isLocked && !t) || ((this._batch = null), (this.size = 0));
          }
        }
        class Hp extends Zt {
          constructor(t, e) {
            super(t), (this._buffer = new qp(t.model, e)), (this._batches = new WeakSet());
          }
          get buffer() {
            return this._buffer;
          }
          destroy() {
            super.destroy(), this._buffer.destroy();
          }
          execute(t = {}) {
            const e = this.editor.model,
              n = e.document,
              o = t.text || '',
              i = o.length,
              r = t.range ? e.createSelection(t.range) : n.selection,
              s = t.resultRange;
            e.enqueueChange(this._buffer.batch, t => {
              this._buffer.lock(),
                this._batches.add(this._buffer.batch),
                e.deleteContent(r),
                o && e.insertContent(t.createText(o, n.selection.getAttributes()), r),
                s ? t.setSelection(s) : r.is('documentSelection') || t.setSelection(r),
                this._buffer.unlock(),
                this._buffer.input(i);
            });
          }
        }
        const jp = [
          qi('arrowUp'),
          qi('arrowRight'),
          qi('arrowDown'),
          qi('arrowLeft'),
          9,
          16,
          17,
          18,
          19,
          20,
          27,
          33,
          34,
          35,
          36,
          45,
          91,
          93,
          144,
          145,
          173,
          174,
          175,
          176,
          177,
          178,
          179,
          255,
        ];
        for (let t = 112; t <= 135; t++) jp.push(t);
        function $p(t) {
          return !(!t.ctrlKey && !t.metaKey) || jp.includes(t.keyCode);
        }
        function Gp(t) {
          if (t.newChildren.length - t.oldChildren.length != 1) return;
          const e = (function (t, e) {
            const n = [];
            let o,
              i = 0;
            return (
              t.forEach(t => {
                'equal' == t
                  ? (r(), i++)
                  : 'insert' == t
                  ? (s('insert') ? o.values.push(e[i]) : (r(), (o = { type: 'insert', index: i, values: [e[i]] })), i++)
                  : s('delete')
                  ? o.howMany++
                  : (r(), (o = { type: 'delete', index: i, howMany: 1 }));
              }),
              r(),
              n
            );
            function r() {
              o && (n.push(o), (o = null));
            }
            function s(t) {
              return o && o.type == t;
            }
          })(Cr(t.oldChildren, t.newChildren, Wp), t.newChildren);
          if (e.length > 1) return;
          const n = e[0];
          return n.values[0] && n.values[0].is('$text') ? n : void 0;
        }
        function Wp(t, e) {
          return t && t.is('$text') && e && e.is('$text') ? t.data === e.data : t === e;
        }
        class Up {
          constructor(t) {
            (this.editor = t), (this.editing = this.editor.editing);
          }
          handle(t, e) {
            if (
              (function (t) {
                if (0 == t.length) return !1;
                for (const e of t) if ('children' === e.type && !Gp(e)) return !0;
                return !1;
              })(t)
            )
              this._handleContainerChildrenMutations(t, e);
            else for (const n of t) this._handleTextMutation(n, e), this._handleTextNodeInsertion(n);
          }
          _handleContainerChildrenMutations(t, e) {
            const n = (function (t) {
              const e = t.map(t => t.node).reduce((t, e) => t.getCommonAncestor(e, { includeSelf: !0 }));
              if (!e) return;
              return e
                .getAncestors({ includeSelf: !0, parentFirst: !0 })
                .find(t => t.is('containerElement') || t.is('rootElement'));
            })(t);
            if (!n) return;
            const o = this.editor.editing.view.domConverter.mapViewToDom(n),
              i = new Or(this.editor.editing.view.document),
              r = this.editor.data.toModel(i.domToView(o)).getChild(0),
              s = this.editor.editing.mapper.toModelElement(n);
            if (!s) return;
            const a = Array.from(r.getChildren()),
              c = Array.from(s.getChildren()),
              l = a[a.length - 1],
              d = c[c.length - 1],
              h = l && l.is('element', 'softBreak'),
              u = d && !d.is('element', 'softBreak');
            h && u && a.pop();
            const p = this.editor.model.schema;
            if (!Jp(a, p) || !Jp(c, p)) return;
            const m = a
                .map(t => (t.is('$text') ? t.data : '@'))
                .join('')
                .replace(/\u00A0/g, ' '),
              g = c
                .map(t => (t.is('$text') ? t.data : '@'))
                .join('')
                .replace(/\u00A0/g, ' ');
            if (g === m) return;
            const f = Cr(g, m),
              { firstChangeAt: k, insertions: b, deletions: w } = Yp(f);
            let A = null;
            e && (A = this.editing.mapper.toModelRange(e.getFirstRange()));
            const _ = m.substr(k, b),
              C = this.editor.model.createRange(
                this.editor.model.createPositionAt(s, k),
                this.editor.model.createPositionAt(s, k + w),
              );
            this.editor.execute('input', { text: _, range: C, resultRange: A });
          }
          _handleTextMutation(t, e) {
            if ('text' != t.type) return;
            const n = t.newText.replace(/\u00A0/g, ' '),
              o = t.oldText.replace(/\u00A0/g, ' ');
            if (o === n) return;
            const i = Cr(o, n),
              { firstChangeAt: r, insertions: s, deletions: a } = Yp(i);
            let c = null;
            e && (c = this.editing.mapper.toModelRange(e.getFirstRange()));
            const l = this.editing.view.createPositionAt(t.node, r),
              d = this.editing.mapper.toModelPosition(l),
              h = this.editor.model.createRange(d, d.getShiftedBy(a)),
              u = n.substr(r, s);
            this.editor.execute('input', { text: u, range: h, resultRange: c });
          }
          _handleTextNodeInsertion(t) {
            if ('children' != t.type) return;
            const e = Gp(t),
              n = this.editing.view.createPositionAt(t.node, e.index),
              o = this.editing.mapper.toModelPosition(n),
              i = e.values[0].data;
            this.editor.execute('input', { text: i.replace(/\u00A0/g, ' '), range: this.editor.model.createRange(o) });
          }
        }
        function Jp(t, e) {
          return t.every(t => e.isInline(t));
        }
        function Yp(t) {
          let e = null,
            n = null;
          for (let o = 0; o < t.length; o++) {
            'equal' != t[o] && ((e = null === e ? o : e), (n = o));
          }
          let o = 0,
            i = 0;
          for (let r = e; r <= n; r++) 'insert' != t[r] && o++, 'delete' != t[r] && i++;
          return { insertions: i, deletions: o, firstChangeAt: e };
        }
        class Qp extends Qt {
          static get pluginName() {
            return 'Input';
          }
          init() {
            const t = this.editor,
              e = new Hp(t, t.config.get('typing.undoStep') || 20);
            t.commands.add('input', e),
              (function (t) {
                let e = null;
                const n = t.model,
                  o = t.editing.view,
                  i = t.commands.get('input');
                function r(t) {
                  const r = n.document,
                    a = o.document.isComposing,
                    c = e && e.isEqual(r.selection);
                  (e = null),
                    i.isEnabled &&
                      ($p(t) ||
                        r.selection.isCollapsed ||
                        (a && 229 === t.keyCode) ||
                        (!a && 229 === t.keyCode && c) ||
                        s());
                }
                function s() {
                  const t = i.buffer;
                  t.lock();
                  const e = t.batch;
                  i._batches.add(e),
                    n.enqueueChange(e, () => {
                      n.deleteContent(n.document.selection);
                    }),
                    t.unlock();
                }
                Mi.isAndroid
                  ? o.document.on('beforeinput', (t, e) => r(e), { priority: 'lowest' })
                  : o.document.on('keydown', (t, e) => r(e), { priority: 'lowest' }),
                  o.document.on(
                    'compositionstart',
                    function () {
                      const t = n.document,
                        e = 1 !== t.selection.rangeCount || t.selection.getFirstRange().isFlat;
                      t.selection.isCollapsed || e || s();
                    },
                    { priority: 'lowest' },
                  ),
                  o.document.on(
                    'compositionend',
                    () => {
                      e = n.createSelection(n.document.selection);
                    },
                    { priority: 'lowest' },
                  );
              })(t),
              (function (t) {
                t.editing.view.document.on('mutations', (e, n, o) => {
                  new Up(t).handle(n, o);
                });
              })(t);
          }
          isInput(t) {
            return this.editor.commands.get('input')._batches.has(t);
          }
        }
        class Xp extends Zt {
          constructor(t, e) {
            super(t), (this.direction = e), (this._buffer = new qp(t.model, t.config.get('typing.undoStep')));
          }
          get buffer() {
            return this._buffer;
          }
          execute(t = {}) {
            const e = this.editor.model,
              n = e.document;
            e.enqueueChange(this._buffer.batch, o => {
              this._buffer.lock();
              const i = o.createSelection(t.selection || n.selection),
                r = t.sequence || 1,
                s = i.isCollapsed;
              if (
                (i.isCollapsed && e.modifySelection(i, { direction: this.direction, unit: t.unit }),
                this._shouldEntireContentBeReplacedWithParagraph(r))
              )
                return void this._replaceEntireContentWithParagraph(o);
              if (this._shouldReplaceFirstBlockWithParagraph(i, r))
                return void this.editor.execute('paragraph', { selection: i });
              if (i.isCollapsed) return;
              let a = 0;
              i
                .getFirstRange()
                .getMinimalFlatRanges()
                .forEach(t => {
                  a += Ai(t.getWalker({ singleCharacters: !0, ignoreElementEnd: !0, shallow: !0 }));
                }),
                e.deleteContent(i, { doNotResetEntireContent: s, direction: this.direction }),
                this._buffer.input(a),
                o.setSelection(i),
                this._buffer.unlock();
            });
          }
          _shouldEntireContentBeReplacedWithParagraph(t) {
            if (t > 1) return !1;
            const e = this.editor.model,
              n = e.document.selection,
              o = e.schema.getLimitElement(n);
            if (!(n.isCollapsed && n.containsEntireContent(o))) return !1;
            if (!e.schema.checkChild(o, 'paragraph')) return !1;
            const i = o.getChild(0);
            return !i || 'paragraph' !== i.name;
          }
          _replaceEntireContentWithParagraph(t) {
            const e = this.editor.model,
              n = e.document.selection,
              o = e.schema.getLimitElement(n),
              i = t.createElement('paragraph');
            t.remove(t.createRangeIn(o)), t.insert(i, o), t.setSelection(i, 0);
          }
          _shouldReplaceFirstBlockWithParagraph(t, e) {
            const n = this.editor.model;
            if (e > 1 || 'backward' != this.direction) return !1;
            if (!t.isCollapsed) return !1;
            const o = t.getFirstPosition(),
              i = n.schema.getLimitElement(o),
              r = i.getChild(0);
            return (
              o.parent == r &&
              !!t.containsEntireContent(r) &&
              !!n.schema.checkChild(i, 'paragraph') &&
              'paragraph' != r.name
            );
          }
        }
        class Zp extends jr {
          constructor(t) {
            super(t);
            const e = t.document;
            let n = 0;
            function o(t, n, o) {
              const i = new vi(e, 'delete', e.selection.getFirstRange());
              e.fire(i, new ps(e, n, o)), i.stop.called && t.stop();
            }
            e.on('keyup', (t, e) => {
              (e.keyCode != Li.delete && e.keyCode != Li.backspace) || (n = 0);
            }),
              e.on('keydown', (t, e) => {
                const i = {};
                if (e.keyCode == Li.delete) (i.direction = 'forward'), (i.unit = 'character');
                else {
                  if (e.keyCode != Li.backspace) return;
                  (i.direction = 'backward'), (i.unit = 'codePoint');
                }
                const r = Mi.isMac ? e.altKey : e.ctrlKey;
                (i.unit = r ? 'word' : i.unit), (i.sequence = ++n), o(t, e.domEvent, i);
              }),
              Mi.isAndroid &&
                e.on('beforeinput', (e, n) => {
                  if ('deleteContentBackward' != n.domEvent.inputType) return;
                  const i = { unit: 'codepoint', direction: 'backward', sequence: 1 },
                    r = n.domTarget.ownerDocument.defaultView.getSelection();
                  r.anchorNode == r.focusNode &&
                    r.anchorOffset + 1 != r.focusOffset &&
                    (i.selectionToRemove = t.domConverter.domSelectionToView(r)),
                    o(e, n.domEvent, i);
                });
          }
          observe() {}
        }
        class tm extends Qt {
          static get pluginName() {
            return 'Delete';
          }
          init() {
            const t = this.editor,
              e = t.editing.view,
              n = e.document;
            e.addObserver(Zp);
            const o = new Xp(t, 'forward');
            if (
              (t.commands.add('deleteForward', o),
              t.commands.add('forwardDelete', o),
              t.commands.add('delete', new Xp(t, 'backward')),
              this.listenTo(
                n,
                'delete',
                (n, o) => {
                  const i = { unit: o.unit, sequence: o.sequence };
                  if (o.selectionToRemove) {
                    const e = t.model.createSelection(),
                      n = [];
                    for (const e of o.selectionToRemove.getRanges()) n.push(t.editing.mapper.toModelRange(e));
                    e.setTo(n), (i.selection = e);
                  }
                  t.execute('forward' == o.direction ? 'deleteForward' : 'delete', i),
                    o.preventDefault(),
                    e.scrollToTheSelection();
                },
                { priority: 'low' },
              ),
              Mi.isAndroid)
            ) {
              let t = null;
              this.listenTo(
                n,
                'delete',
                (e, n) => {
                  const o = n.domTarget.ownerDocument.defaultView.getSelection();
                  t = {
                    anchorNode: o.anchorNode,
                    anchorOffset: o.anchorOffset,
                    focusNode: o.focusNode,
                    focusOffset: o.focusOffset,
                  };
                },
                { priority: 'lowest' },
              ),
                this.listenTo(n, 'keyup', (e, n) => {
                  if (t) {
                    const e = n.domTarget.ownerDocument.defaultView.getSelection();
                    e.collapse(t.anchorNode, t.anchorOffset), e.extend(t.focusNode, t.focusOffset), (t = null);
                  }
                });
            }
          }
        }
        class em extends Qt {
          static get requires() {
            return [Qp, tm];
          }
          static get pluginName() {
            return 'Typing';
          }
        }
        function nm(t, e) {
          let n = t.start;
          return {
            text: Array.from(t.getItems()).reduce(
              (t, o) => (o.is('$text') || o.is('$textProxy') ? t + o.data : ((n = e.createPositionAfter(o)), '')),
              '',
            ),
            range: e.createRange(n, t.end),
          };
        }
        class om {
          constructor(t, e) {
            (this.model = t),
              (this.testCallback = e),
              (this.hasMatch = !1),
              this.set('isEnabled', !0),
              this.on('change:isEnabled', () => {
                this.isEnabled
                  ? this._startListening()
                  : (this.stopListening(t.document.selection), this.stopListening(t.document));
              }),
              this._startListening();
          }
          _startListening() {
            const t = this.model.document;
            this.listenTo(t.selection, 'change:range', (e, { directChange: n }) => {
              n &&
                (t.selection.isCollapsed
                  ? this._evaluateTextBeforeSelection('selection')
                  : this.hasMatch && (this.fire('unmatched'), (this.hasMatch = !1)));
            }),
              this.listenTo(t, 'change:data', (t, e) => {
                'transparent' != e.type && this._evaluateTextBeforeSelection('data', { batch: e });
              });
          }
          _evaluateTextBeforeSelection(t, e = {}) {
            const n = this.model,
              o = n.document.selection,
              i = n.createRange(n.createPositionAt(o.focus.parent, 0), o.focus),
              { text: r, range: s } = nm(i, n),
              a = this.testCallback(r);
            if ((!a && this.hasMatch && this.fire('unmatched'), (this.hasMatch = !!a), a)) {
              const n = Object.assign(e, { text: r, range: s });
              'object' == typeof a && Object.assign(n, a), this.fire(`matched:${t}`, n);
            }
          }
        }
        Yt(om, jt);
        class im extends Qt {
          static get pluginName() {
            return 'TwoStepCaretMovement';
          }
          constructor(t) {
            super(t), (this.attributes = new Set()), (this._overrideUid = null);
          }
          init() {
            const t = this.editor,
              e = t.model,
              n = t.editing.view,
              o = t.locale,
              i = e.document.selection;
            this.listenTo(
              n.document,
              'arrowKey',
              (t, e) => {
                if (!i.isCollapsed) return;
                if (e.shiftKey || e.altKey || e.ctrlKey) return;
                const n = e.keyCode == Li.arrowright,
                  r = e.keyCode == Li.arrowleft;
                if (!n && !r) return;
                const s = o.contentLanguageDirection;
                let a = !1;
                (a =
                  ('ltr' === s && n) || ('rtl' === s && r)
                    ? this._handleForwardMovement(e)
                    : this._handleBackwardMovement(e)),
                  !0 === a && t.stop();
              },
              { context: '$text', priority: 'highest' },
            ),
              (this._isNextGravityRestorationSkipped = !1),
              this.listenTo(i, 'change:range', (t, e) => {
                this._isNextGravityRestorationSkipped
                  ? (this._isNextGravityRestorationSkipped = !1)
                  : this._isGravityOverridden &&
                    ((!e.directChange && cm(i.getFirstPosition(), this.attributes)) || this._restoreGravity());
              });
          }
          registerAttribute(t) {
            this.attributes.add(t);
          }
          _handleForwardMovement(t) {
            const e = this.attributes,
              n = this.editor.model.document.selection,
              o = n.getFirstPosition();
            return (
              !this._isGravityOverridden &&
              (!o.isAtStart || !rm(n, e)) &&
              (cm(o, e) ? (am(t), this._overrideGravity(), !0) : void 0)
            );
          }
          _handleBackwardMovement(t) {
            const e = this.attributes,
              n = this.editor.model,
              o = n.document.selection,
              i = o.getFirstPosition();
            return this._isGravityOverridden
              ? (am(t), this._restoreGravity(), sm(n, e, i), !0)
              : i.isAtStart
              ? !!rm(o, e) && (am(t), sm(n, e, i), !0)
              : (function (t, e) {
                  return cm(t.getShiftedBy(-1), e);
                })(i, e)
              ? i.isAtEnd && !rm(o, e) && cm(i, e)
                ? (am(t), sm(n, e, i), !0)
                : ((this._isNextGravityRestorationSkipped = !0), this._overrideGravity(), !1)
              : void 0;
          }
          get _isGravityOverridden() {
            return !!this._overrideUid;
          }
          _overrideGravity() {
            this._overrideUid = this.editor.model.change(t => t.overrideSelectionGravity());
          }
          _restoreGravity() {
            this.editor.model.change(t => {
              t.restoreSelectionGravity(this._overrideUid), (this._overrideUid = null);
            });
          }
        }
        function rm(t, e) {
          for (const n of e) if (t.hasAttribute(n)) return !0;
          return !1;
        }
        function sm(t, e, n) {
          const o = n.nodeBefore;
          t.change(t => {
            o ? t.setSelectionAttribute(o.getAttributes()) : t.removeSelectionAttribute(e);
          });
        }
        function am(t) {
          t.preventDefault();
        }
        function cm(t, e) {
          const { nodeBefore: n, nodeAfter: o } = t;
          for (const t of e) {
            const e = n ? n.getAttribute(t) : void 0;
            if ((o ? o.getAttribute(t) : void 0) !== e) return !0;
          }
          return !1;
        }
        var lm = /[\\^$.*+?()[\]{}|]/g,
          dm = RegExp(lm.source);
        var hm = function (t) {
          return (t = Vo(t)) && dm.test(t) ? t.replace(lm, '\\$&') : t;
        };
        const um = {
            copyright: { from: '(c)', to: '©' },
            registeredTrademark: { from: '(r)', to: '®' },
            trademark: { from: '(tm)', to: '™' },
            oneHalf: { from: '1/2', to: '½' },
            oneThird: { from: '1/3', to: '⅓' },
            twoThirds: { from: '2/3', to: '⅔' },
            oneForth: { from: '1/4', to: '¼' },
            threeQuarters: { from: '3/4', to: '¾' },
            lessThanOrEqual: { from: '<=', to: '≤' },
            greaterThanOrEqual: { from: '>=', to: '≥' },
            notEqual: { from: '!=', to: '≠' },
            arrowLeft: { from: '<-', to: '←' },
            arrowRight: { from: '->', to: '→' },
            horizontalEllipsis: { from: '...', to: '…' },
            enDash: { from: /(^| )(--)( )$/, to: [null, '–', null] },
            emDash: { from: /(^| )(---)( )$/, to: [null, '—', null] },
            quotesPrimary: { from: bm('"'), to: [null, '“', null, '”'] },
            quotesSecondary: { from: bm("'"), to: [null, '‘', null, '’'] },
            quotesPrimaryEnGb: { from: bm("'"), to: [null, '‘', null, '’'] },
            quotesSecondaryEnGb: { from: bm('"'), to: [null, '“', null, '”'] },
            quotesPrimaryPl: { from: bm('"'), to: [null, '„', null, '”'] },
            quotesSecondaryPl: { from: bm("'"), to: [null, '‚', null, '’'] },
          },
          pm = {
            symbols: ['copyright', 'registeredTrademark', 'trademark'],
            mathematical: [
              'oneHalf',
              'oneThird',
              'twoThirds',
              'oneForth',
              'threeQuarters',
              'lessThanOrEqual',
              'greaterThanOrEqual',
              'notEqual',
              'arrowLeft',
              'arrowRight',
            ],
            typography: ['horizontalEllipsis', 'enDash', 'emDash'],
            quotes: ['quotesPrimary', 'quotesSecondary'],
          },
          mm = ['symbols', 'mathematical', 'typography', 'quotes'];
        function gm(t) {
          return 'string' == typeof t ? new RegExp(`(${hm(t)})$`) : t;
        }
        function fm(t) {
          return 'string' == typeof t ? () => [t] : t instanceof Array ? () => t : t;
        }
        function km(t) {
          return (t.textNode ? t.textNode : t.nodeAfter).getAttributes();
        }
        function bm(t) {
          return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`);
        }
        function wm(t, e, n, o) {
          return o.createRange(Am(t, e, n, !0, o), Am(t, e, n, !1, o));
        }
        function Am(t, e, n, o, i) {
          let r = t.textNode || (o ? t.nodeBefore : t.nodeAfter),
            s = null;
          for (; r && r.getAttribute(e) == n; ) (s = r), (r = o ? r.previousSibling : r.nextSibling);
          return s ? i.createPositionAt(s, o ? 'before' : 'after') : t;
        }
        class _m extends Zt {
          refresh() {
            (this.value = this._getValue()), (this.isEnabled = this._checkEnabled());
          }
          execute(t = {}) {
            const e = this.editor.model,
              n = e.schema,
              o = e.document.selection,
              i = Array.from(o.getSelectedBlocks()),
              r = void 0 === t.forceValue ? !this.value : t.forceValue;
            e.change(t => {
              if (r) {
                const e = i.filter(t => Cm(t) || ym(n, t));
                this._applyQuote(t, e);
              } else this._removeQuote(t, i.filter(Cm));
            });
          }
          _getValue() {
            const t = Gs(this.editor.model.document.selection.getSelectedBlocks());
            return !(!t || !Cm(t));
          }
          _checkEnabled() {
            if (this.value) return !0;
            const t = this.editor.model.document.selection,
              e = this.editor.model.schema,
              n = Gs(t.getSelectedBlocks());
            return !!n && ym(e, n);
          }
          _removeQuote(t, e) {
            vm(t, e)
              .reverse()
              .forEach(e => {
                if (e.start.isAtStart && e.end.isAtEnd) return void t.unwrap(e.start.parent);
                if (e.start.isAtStart) {
                  const n = t.createPositionBefore(e.start.parent);
                  return void t.move(e, n);
                }
                e.end.isAtEnd || t.split(e.end);
                const n = t.createPositionAfter(e.end.parent);
                t.move(e, n);
              });
          }
          _applyQuote(t, e) {
            const n = [];
            vm(t, e)
              .reverse()
              .forEach(e => {
                let o = Cm(e.start);
                o || ((o = t.createElement('blockQuote')), t.wrap(e, o)), n.push(o);
              }),
              n.reverse().reduce((e, n) => (e.nextSibling == n ? (t.merge(t.createPositionAfter(e)), e) : n));
          }
        }
        function Cm(t) {
          return 'blockQuote' == t.parent.name ? t.parent : null;
        }
        function vm(t, e) {
          let n,
            o = 0;
          const i = [];
          for (; o < e.length; ) {
            const r = e[o],
              s = e[o + 1];
            n || (n = t.createPositionBefore(r)),
              (s && r.nextSibling == s) || (i.push(t.createRange(n, t.createPositionAfter(r))), (n = null)),
              o++;
          }
          return i;
        }
        function ym(t, e) {
          const n = t.checkChild(e.parent, 'blockQuote'),
            o = t.checkChild(['$root', 'blockQuote'], e);
          return n && o;
        }
        class xm extends Qt {
          static get pluginName() {
            return 'BlockQuoteEditing';
          }
          static get requires() {
            return [Mp, tm];
          }
          init() {
            const t = this.editor,
              e = t.model.schema;
            t.commands.add('blockQuote', new _m(t)),
              e.register('blockQuote', { allowWhere: '$block', allowContentOf: '$root' }),
              t.conversion.elementToElement({ model: 'blockQuote', view: 'blockquote' }),
              t.model.document.registerPostFixer(n => {
                const o = t.model.document.differ.getChanges();
                for (const t of o)
                  if ('insert' == t.type) {
                    const o = t.position.nodeAfter;
                    if (!o) continue;
                    if (o.is('element', 'blockQuote') && o.isEmpty) return n.remove(o), !0;
                    if (o.is('element', 'blockQuote') && !e.checkChild(t.position, o)) return n.unwrap(o), !0;
                    if (o.is('element')) {
                      const t = n.createRangeIn(o);
                      for (const o of t.getItems())
                        if (o.is('element', 'blockQuote') && !e.checkChild(n.createPositionBefore(o), o))
                          return n.unwrap(o), !0;
                    }
                  } else if ('remove' == t.type) {
                    const e = t.position.parent;
                    if (e.is('element', 'blockQuote') && e.isEmpty) return n.remove(e), !0;
                  }
                return !1;
              });
            const n = this.editor.editing.view.document,
              o = t.model.document.selection,
              i = t.commands.get('blockQuote');
            this.listenTo(
              n,
              'enter',
              (e, n) => {
                if (!o.isCollapsed || !i.value) return;
                o.getLastPosition().parent.isEmpty &&
                  (t.execute('blockQuote'), t.editing.view.scrollToTheSelection(), n.preventDefault(), e.stop());
              },
              { context: 'blockquote' },
            ),
              this.listenTo(
                n,
                'delete',
                (e, n) => {
                  if ('backward' != n.direction || !o.isCollapsed || !i.value) return;
                  const r = o.getLastPosition().parent;
                  r.isEmpty &&
                    !r.previousSibling &&
                    (t.execute('blockQuote'), t.editing.view.scrollToTheSelection(), n.preventDefault(), e.stop());
                },
                { context: 'blockquote' },
              );
          }
        }
        var Em = n(35),
          Dm = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Em.a, Dm), Em.a.locals;
        class Sm extends Qt {
          static get pluginName() {
            return 'BlockQuoteUI';
          }
          init() {
            const t = this.editor,
              e = t.t;
            t.ui.componentFactory.add('blockQuote', n => {
              const o = t.commands.get('blockQuote'),
                i = new jd(n);
              return (
                i.set({ label: e('Block quote'), icon: id, tooltip: !0, isToggleable: !0 }),
                i.bind('isOn', 'isEnabled').to(o, 'value', 'isEnabled'),
                this.listenTo(i, 'execute', () => {
                  t.execute('blockQuote'), t.editing.view.focus();
                }),
                i
              );
            });
          }
        }
        class Bm extends Zt {
          constructor(t, e) {
            super(t), (this.attributeKey = e);
          }
          refresh() {
            const t = this.editor.model,
              e = t.document;
            (this.value = this._getValueFromFirstAllowedNode()),
              (this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey));
          }
          execute(t = {}) {
            const e = this.editor.model,
              n = e.document.selection,
              o = void 0 === t.forceValue ? !this.value : t.forceValue;
            e.change(t => {
              if (n.isCollapsed)
                o ? t.setSelectionAttribute(this.attributeKey, !0) : t.removeSelectionAttribute(this.attributeKey);
              else {
                const i = e.schema.getValidRanges(n.getRanges(), this.attributeKey);
                for (const e of i)
                  o ? t.setAttribute(this.attributeKey, o, e) : t.removeAttribute(this.attributeKey, e);
              }
            });
          }
          _getValueFromFirstAllowedNode() {
            const t = this.editor.model,
              e = t.schema,
              n = t.document.selection;
            if (n.isCollapsed) return n.hasAttribute(this.attributeKey);
            for (const t of n.getRanges())
              for (const n of t.getItems())
                if (e.checkAttribute(n, this.attributeKey)) return n.hasAttribute(this.attributeKey);
            return !1;
          }
        }
        const Tm = 'bold';
        class Pm extends Qt {
          static get pluginName() {
            return 'BoldEditing';
          }
          init() {
            const t = this.editor;
            t.model.schema.extend('$text', { allowAttributes: Tm }),
              t.model.schema.setAttributeProperties(Tm, { isFormatting: !0, copyOnEnter: !0 }),
              t.conversion.attributeToElement({
                model: Tm,
                view: 'strong',
                upcastAlso: [
                  'b',
                  t => {
                    const e = t.getStyle('font-weight');
                    return e
                      ? 'bold' == e || Number(e) >= 600
                        ? { name: !0, styles: ['font-weight'] }
                        : void 0
                      : null;
                  },
                ],
              }),
              t.commands.add(Tm, new Bm(t, Tm)),
              t.keystrokes.set('CTRL+B', Tm);
          }
        }
        const Im = 'bold';
        class zm extends Qt {
          static get pluginName() {
            return 'BoldUI';
          }
          init() {
            const t = this.editor,
              e = t.t;
            t.ui.componentFactory.add(Im, n => {
              const o = t.commands.get(Im),
                i = new jd(n);
              return (
                i.set({
                  label: e('Bold'),
                  icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>',
                  keystroke: 'CTRL+B',
                  tooltip: !0,
                  isToggleable: !0,
                }),
                i.bind('isOn', 'isEnabled').to(o, 'value', 'isEnabled'),
                this.listenTo(i, 'execute', () => {
                  t.execute(Im), t.editing.view.focus();
                }),
                i
              );
            });
          }
        }
        class Fm {
          constructor(t) {
            (this.files = (function (t) {
              const e = t.files ? Array.from(t.files) : [],
                n = t.items ? Array.from(t.items) : [];
              if (e.length) return e;
              return n.filter(t => 'file' === t.kind).map(t => t.getAsFile());
            })(t)),
              (this._native = t);
          }
          get types() {
            return this._native.types;
          }
          getData(t) {
            return this._native.getData(t);
          }
          setData(t, e) {
            this._native.setData(t, e);
          }
          set effectAllowed(t) {
            this._native.effectAllowed = t;
          }
          get effectAllowed() {
            return this._native.effectAllowed;
          }
          set dropEffect(t) {
            this._native.dropEffect = t;
          }
          get dropEffect() {
            return this._native.dropEffect;
          }
          get isCanceled() {
            return 'none' == this._native.dropEffect || !!this._native.mozUserCancelled;
          }
        }
        class Rm extends ms {
          constructor(t) {
            super(t);
            const e = this.document;
            function n(t) {
              return (n, o) => {
                o.preventDefault();
                const r = o.dropRange ? [o.dropRange] : null,
                  s = new i(e, t);
                e.fire(s, { dataTransfer: o.dataTransfer, method: n.name, targetRanges: r, target: o.target }),
                  s.stop.called && o.stopPropagation();
              };
            }
            (this.domEventType = [
              'paste',
              'copy',
              'cut',
              'drop',
              'dragover',
              'dragstart',
              'dragend',
              'dragenter',
              'dragleave',
            ]),
              this.listenTo(e, 'paste', n('clipboardInput'), { priority: 'low' }),
              this.listenTo(e, 'drop', n('clipboardInput'), { priority: 'low' }),
              this.listenTo(e, 'dragover', n('dragging'), { priority: 'low' });
          }
          onDomEvent(t) {
            const e = { dataTransfer: new Fm(t.clipboardData ? t.clipboardData : t.dataTransfer) };
            ('drop' != t.type && 'dragover' != t.type) ||
              (e.dropRange = (function (t, e) {
                const n = e.target.ownerDocument,
                  o = e.clientX,
                  i = e.clientY;
                let r;
                n.caretRangeFromPoint && n.caretRangeFromPoint(o, i)
                  ? (r = n.caretRangeFromPoint(o, i))
                  : e.rangeParent && ((r = n.createRange()), r.setStart(e.rangeParent, e.rangeOffset), r.collapse(!0));
                if (r) return t.domConverter.domRangeToView(r);
                return null;
              })(this.view, t)),
              this.fire(t.type, t, e);
          }
        }
        const Om = ['figcaption', 'li'];
        function Mm(t) {
          let e = '';
          if (t.is('$text') || t.is('$textProxy')) e = t.data;
          else if (t.is('element', 'img') && t.hasAttribute('alt')) e = t.getAttribute('alt');
          else if (t.is('element', 'br')) e = '\n';
          else {
            let n = null;
            for (const o of t.getChildren()) {
              const t = Mm(o);
              n &&
                (n.is('containerElement') || o.is('containerElement')) &&
                (Om.includes(n.name) || Om.includes(o.name) ? (e += '\n') : (e += '\n\n')),
                (e += t),
                (n = o);
            }
          }
          return e;
        }
        class Nm extends Qt {
          static get pluginName() {
            return 'ClipboardPipeline';
          }
          init() {
            this.editor.editing.view.addObserver(Rm), this._setupPasteDrop(), this._setupCopyCut();
          }
          _setupPasteDrop() {
            const t = this.editor,
              e = t.model,
              n = t.editing.view,
              o = n.document;
            this.listenTo(
              o,
              'clipboardInput',
              e => {
                t.isReadOnly && e.stop();
              },
              { priority: 'highest' },
            ),
              this.listenTo(
                o,
                'clipboardInput',
                (t, e) => {
                  const o = e.dataTransfer;
                  let r = e.content || '';
                  var s;
                  r ||
                    (o.getData('text/html')
                      ? (r = (function (t) {
                          return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t, e) =>
                            1 == e.length ? ' ' : e,
                          );
                        })(o.getData('text/html')))
                      : o.getData('text/plain') &&
                        (((s = (s = o.getData('text/plain'))
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/\r?\n\r?\n/g, '</p><p>')
                          .replace(/\r?\n/g, '<br>')
                          .replace(/^\s/, '&nbsp;')
                          .replace(/\s$/, '&nbsp;')
                          .replace(/\s\s/g, ' &nbsp;')).includes('</p><p>') ||
                          s.includes('<br>')) &&
                          (s = `<p>${s}</p>`),
                        (r = s)),
                    (r = this.editor.data.htmlProcessor.toView(r)));
                  const a = new i(this, 'inputTransformation');
                  this.fire(a, { content: r, dataTransfer: o, targetRanges: e.targetRanges, method: e.method }),
                    a.stop.called && t.stop(),
                    n.scrollToTheSelection();
                },
                { priority: 'low' },
              ),
              this.listenTo(
                this,
                'inputTransformation',
                (t, n) => {
                  if (n.content.isEmpty) return;
                  const o = this.editor.data.toModel(n.content, '$clipboardHolder');
                  0 != o.childCount &&
                    (t.stop(),
                    e.change(() => {
                      this.fire('contentInsertion', {
                        content: o,
                        method: n.method,
                        dataTransfer: n.dataTransfer,
                        targetRanges: n.targetRanges,
                      });
                    }));
                },
                { priority: 'low' },
              ),
              this.listenTo(
                this,
                'contentInsertion',
                (t, n) => {
                  n.resultRange = e.insertContent(n.content);
                },
                { priority: 'low' },
              );
          }
          _setupCopyCut() {
            const t = this.editor,
              e = t.model.document,
              n = t.editing.view.document;
            function o(o, i) {
              const r = i.dataTransfer;
              i.preventDefault();
              const s = t.data.toView(t.model.getSelectedContent(e.selection));
              n.fire('clipboardOutput', { dataTransfer: r, content: s, method: o.name });
            }
            this.listenTo(n, 'copy', o, { priority: 'low' }),
              this.listenTo(
                n,
                'cut',
                (e, n) => {
                  t.isReadOnly ? n.preventDefault() : o(e, n);
                },
                { priority: 'low' },
              ),
              this.listenTo(
                n,
                'clipboardOutput',
                (n, o) => {
                  o.content.isEmpty ||
                    (o.dataTransfer.setData('text/html', this.editor.data.htmlProcessor.toData(o.content)),
                    o.dataTransfer.setData('text/plain', Mm(o.content))),
                    'cut' == o.method && t.model.deleteContent(e.selection);
                },
                { priority: 'low' },
              );
          }
        }
        class Vm {
          constructor() {
            this._stack = [];
          }
          add(t, e) {
            const n = this._stack,
              o = n[0];
            this._insertDescriptor(t);
            const i = n[0];
            o === i || Lm(o, i) || this.fire('change:top', { oldDescriptor: o, newDescriptor: i, writer: e });
          }
          remove(t, e) {
            const n = this._stack,
              o = n[0];
            this._removeDescriptor(t);
            const i = n[0];
            o === i || Lm(o, i) || this.fire('change:top', { oldDescriptor: o, newDescriptor: i, writer: e });
          }
          _insertDescriptor(t) {
            const e = this._stack,
              n = e.findIndex(e => e.id === t.id);
            if (Lm(t, e[n])) return;
            n > -1 && e.splice(n, 1);
            let o = 0;
            for (; e[o] && Km(e[o], t); ) o++;
            e.splice(o, 0, t);
          }
          _removeDescriptor(t) {
            const e = this._stack,
              n = e.findIndex(e => e.id === t);
            n > -1 && e.splice(n, 1);
          }
        }
        function Lm(t, e) {
          return t && e && t.priority == e.priority && qm(t.classes) == qm(e.classes);
        }
        function Km(t, e) {
          return t.priority > e.priority || (!(t.priority < e.priority) && qm(t.classes) > qm(e.classes));
        }
        function qm(t) {
          return Array.isArray(t) ? t.sort().join(',') : t;
        }
        Yt(Vm, h);
        var Hm =
          '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>';
        const jm = 'ck-widget_selected';
        function $m(t) {
          return !!t.is('element') && !!t.getCustomProperty('widget');
        }
        function Gm(t, e, n = {}) {
          if (!t.is('containerElement')) throw new c.a('widget-to-widget-wrong-element-type', null, { element: t });
          return (
            e.setAttribute('contenteditable', 'false', t),
            e.addClass('ck-widget', t),
            e.setCustomProperty('widget', !0, t),
            (t.getFillerOffset = tg),
            n.label &&
              (function (t, e, n) {
                n.setCustomProperty('widgetLabel', e, t);
              })(t, n.label, e),
            n.hasSelectionHandle &&
              (function (t, e) {
                const n = e.createUIElement('div', { class: 'ck ck-widget__selection-handle' }, function (t) {
                  const e = this.toDomElement(t),
                    n = new Nd();
                  return n.set('content', Hm), n.render(), e.appendChild(n.element), e;
                });
                e.insert(e.createPositionAt(t, 0), n), e.addClass(['ck-widget_with-selection-handle'], t);
              })(t, e),
            Jm(t, e, Wm, Um),
            t
          );
        }
        function Wm(t, e, n) {
          if ((e.classes && n.addClass(ho(e.classes), t), e.attributes))
            for (const o in e.attributes) n.setAttribute(o, e.attributes[o], t);
        }
        function Um(t, e, n) {
          if ((e.classes && n.removeClass(ho(e.classes), t), e.attributes))
            for (const o in e.attributes) n.removeAttribute(o, t);
        }
        function Jm(t, e, n, o) {
          const i = new Vm();
          i.on('change:top', (e, i) => {
            i.oldDescriptor && o(t, i.oldDescriptor, i.writer), i.newDescriptor && n(t, i.newDescriptor, i.writer);
          }),
            e.setCustomProperty('addHighlight', (t, e, n) => i.add(e, n), t),
            e.setCustomProperty('removeHighlight', (t, e, n) => i.remove(e, n), t);
        }
        function Ym(t) {
          const e = t.getCustomProperty('widgetLabel');
          return e ? ('function' == typeof e ? e() : e) : '';
        }
        function Qm(t, e) {
          return (
            e.addClass(['ck-editor__editable', 'ck-editor__nested-editable'], t),
            e.setAttribute('contenteditable', t.isReadOnly ? 'false' : 'true', t),
            t.on('change:isReadOnly', (n, o, i) => {
              e.setAttribute('contenteditable', i ? 'false' : 'true', t);
            }),
            t.on('change:isFocused', (n, o, i) => {
              i
                ? e.addClass('ck-editor__nested-editable_focused', t)
                : e.removeClass('ck-editor__nested-editable_focused', t);
            }),
            t
          );
        }
        function Xm(t, e) {
          const n = t.getSelectedElement();
          if (n) {
            const o = og(t);
            if (o) return e.createPositionAt(n, o);
            if (e.schema.isBlock(n)) return e.createPositionAfter(n);
          }
          const o = t.getSelectedBlocks().next().value;
          if (o) {
            if (o.isEmpty) return e.createPositionAt(o, 0);
            const n = e.createPositionAfter(o);
            return t.focus.isTouching(n) ? n : e.createPositionBefore(o);
          }
          return t.focus;
        }
        function Zm(t, e) {
          const n = t.getSelectedElement();
          return !!n && e.isObject(n);
        }
        function tg() {
          return null;
        }
        const eg = 'widget-type-around';
        function ng(t, e, n) {
          return t && $m(t) && !n.isInline(e);
        }
        function og(t) {
          return t.getAttribute(eg);
        }
        var ig = n(36),
          rg = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(ig.a, rg), ig.a.locals;
        const sg = ['before', 'after'],
          ag = new DOMParser().parseFromString(
            '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>',
            'image/svg+xml',
          ).firstChild,
          cg = 'ck-widget__type-around_disabled';
        class lg extends Qt {
          static get pluginName() {
            return 'WidgetTypeAround';
          }
          static get requires() {
            return [Mp, tm];
          }
          constructor(t) {
            super(t), (this._currentFakeCaretModelElement = null);
          }
          init() {
            const t = this.editor,
              e = t.editing.view;
            this.on('change:isEnabled', (n, o, i) => {
              e.change(t => {
                for (const n of e.document.roots) i ? t.removeClass(cg, n) : t.addClass(cg, n);
              }),
                i ||
                  t.model.change(t => {
                    t.removeSelectionAttribute(eg);
                  });
            }),
              this._enableTypeAroundUIInjection(),
              this._enableInsertingParagraphsOnButtonClick(),
              this._enableInsertingParagraphsOnEnterKeypress(),
              this._enableInsertingParagraphsOnTypingKeystroke(),
              this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(),
              this._enableDeleteIntegration(),
              this._enableInsertContentIntegration(),
              this._enableDeleteContentIntegration();
          }
          destroy() {
            this._currentFakeCaretModelElement = null;
          }
          _insertParagraph(t, e) {
            const n = this.editor,
              o = n.editing.view;
            n.execute('insertParagraph', { position: n.model.createPositionAt(t, e) }),
              o.focus(),
              o.scrollToTheSelection();
          }
          _listenToIfEnabled(t, e, n, o) {
            this.listenTo(
              t,
              e,
              (...t) => {
                this.isEnabled && n(...t);
              },
              o,
            );
          }
          _insertParagraphAccordingToFakeCaretPosition() {
            const t = this.editor.model.document.selection,
              e = og(t);
            if (!e) return !1;
            const n = t.getSelectedElement();
            return this._insertParagraph(n, e), !0;
          }
          _enableTypeAroundUIInjection() {
            const t = this.editor,
              e = t.model.schema,
              n = t.locale.t,
              o = { before: n('Insert paragraph before block'), after: n('Insert paragraph after block') };
            t.editing.downcastDispatcher.on(
              'insert',
              (t, n, i) => {
                const r = i.mapper.toViewElement(n.item);
                ng(r, n.item, e) &&
                  (function (t, e, n) {
                    const o = t.createUIElement(
                      'div',
                      { class: 'ck ck-reset_all ck-widget__type-around' },
                      function (t) {
                        const n = this.toDomElement(t);
                        return (
                          (function (t, e) {
                            for (const n of sg) {
                              const o = new gd({
                                tag: 'div',
                                attributes: {
                                  class: [
                                    'ck',
                                    'ck-widget__type-around__button',
                                    `ck-widget__type-around__button_${n}`,
                                  ],
                                  title: e[n],
                                },
                                children: [t.ownerDocument.importNode(ag, !0)],
                              });
                              t.appendChild(o.render());
                            }
                          })(n, e),
                          (function (t) {
                            const e = new gd({
                              tag: 'div',
                              attributes: { class: ['ck', 'ck-widget__type-around__fake-caret'] },
                            });
                            t.appendChild(e.render());
                          })(n),
                          n
                        );
                      },
                    );
                    t.insert(t.createPositionAt(n, 'end'), o);
                  })(i.writer, o, r);
              },
              { priority: 'low' },
            );
          }
          _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
            const t = this.editor,
              e = t.model,
              n = e.document.selection,
              o = e.schema,
              i = t.editing.view;
            function r(t) {
              return `ck-widget_type-around_show-fake-caret_${t}`;
            }
            this._listenToIfEnabled(
              i.document,
              'arrowKey',
              (t, e) => {
                this._handleArrowKeyPress(t, e);
              },
              { context: [$m, '$text'], priority: 'high' },
            ),
              this._listenToIfEnabled(n, 'change:range', (e, n) => {
                n.directChange &&
                  t.model.change(t => {
                    t.removeSelectionAttribute(eg);
                  });
              }),
              this._listenToIfEnabled(e.document, 'change:data', () => {
                const e = n.getSelectedElement();
                if (e) {
                  if (ng(t.editing.mapper.toViewElement(e), e, o)) return;
                }
                t.model.change(t => {
                  t.removeSelectionAttribute(eg);
                });
              }),
              this._listenToIfEnabled(t.editing.downcastDispatcher, 'selection', (t, e, n) => {
                const i = n.writer;
                if (this._currentFakeCaretModelElement) {
                  const t = n.mapper.toViewElement(this._currentFakeCaretModelElement);
                  t && (i.removeClass(sg.map(r), t), (this._currentFakeCaretModelElement = null));
                }
                const s = e.selection.getSelectedElement();
                if (!s) return;
                const a = n.mapper.toViewElement(s);
                if (!ng(a, s, o)) return;
                const c = og(e.selection);
                c && (i.addClass(r(c), a), (this._currentFakeCaretModelElement = s));
              }),
              this._listenToIfEnabled(t.ui.focusTracker, 'change:isFocused', (e, n, o) => {
                o ||
                  t.model.change(t => {
                    t.removeSelectionAttribute(eg);
                  });
              });
          }
          _handleArrowKeyPress(t, e) {
            const n = this.editor,
              o = n.model,
              i = o.document.selection,
              r = o.schema,
              s = n.editing.view,
              a = Gi(e.keyCode, n.locale.contentLanguageDirection),
              c = s.document.selection.getSelectedElement();
            let l;
            ng(c, n.editing.mapper.toModelElement(c), r)
              ? (l = this._handleArrowKeyPressOnSelectedWidget(a))
              : i.isCollapsed && (l = this._handleArrowKeyPressWhenSelectionNextToAWidget(a)),
              l && (e.preventDefault(), t.stop());
          }
          _handleArrowKeyPressOnSelectedWidget(t) {
            const e = this.editor.model,
              n = og(e.document.selection);
            return e.change(e => {
              if (!n) return e.setSelectionAttribute(eg, t ? 'after' : 'before'), !0;
              if (!(n === (t ? 'after' : 'before'))) return e.removeSelectionAttribute(eg), !0;
              return !1;
            });
          }
          _handleArrowKeyPressWhenSelectionNextToAWidget(t) {
            const e = this.editor,
              n = e.model,
              o = n.schema,
              i = e.plugins.get('Widget'),
              r = i._getObjectElementNextToSelection(t);
            return (
              !!ng(e.editing.mapper.toViewElement(r), r, o) &&
              (n.change(e => {
                i._setSelectionOverElement(r), e.setSelectionAttribute(eg, t ? 'before' : 'after');
              }),
              !0)
            );
          }
          _enableInsertingParagraphsOnButtonClick() {
            const t = this.editor,
              e = t.editing.view;
            this._listenToIfEnabled(e.document, 'mousedown', (n, o) => {
              const i = o.domTarget.closest('.ck-widget__type-around__button');
              if (!i) return;
              const r = (function (t) {
                  return t.classList.contains('ck-widget__type-around__button_before') ? 'before' : 'after';
                })(i),
                s = (function (t, e) {
                  const n = t.closest('.ck-widget');
                  return e.mapDomToView(n);
                })(i, e.domConverter),
                a = t.editing.mapper.toModelElement(s);
              this._insertParagraph(a, r), o.preventDefault(), n.stop();
            });
          }
          _enableInsertingParagraphsOnEnterKeypress() {
            const t = this.editor,
              e = t.model.document.selection,
              n = t.editing.view;
            this._listenToIfEnabled(
              n.document,
              'enter',
              (n, o) => {
                if ('atTarget' != n.eventPhase) return;
                const i = e.getSelectedElement(),
                  r = t.editing.mapper.toViewElement(i),
                  s = t.model.schema;
                let a;
                this._insertParagraphAccordingToFakeCaretPosition()
                  ? (a = !0)
                  : ng(r, i, s) && (this._insertParagraph(i, o.isSoft ? 'before' : 'after'), (a = !0)),
                  a && (o.preventDefault(), n.stop());
              },
              { context: $m },
            );
          }
          _enableInsertingParagraphsOnTypingKeystroke() {
            const t = this.editor.editing.view,
              e = [Li.enter, Li.delete, Li.backspace];
            this._listenToIfEnabled(
              t.document,
              'keydown',
              (t, n) => {
                e.includes(n.keyCode) || $p(n) || this._insertParagraphAccordingToFakeCaretPosition();
              },
              { priority: 'high' },
            );
          }
          _enableDeleteIntegration() {
            const t = this.editor,
              e = t.editing.view,
              n = t.model,
              o = n.schema;
            this._listenToIfEnabled(
              e.document,
              'delete',
              (e, i) => {
                if ('atTarget' != e.eventPhase) return;
                const r = og(n.document.selection);
                if (!r) return;
                const s = i.direction,
                  a = n.document.selection.getSelectedElement(),
                  c = 'forward' == s;
                if (('before' === r) === c) t.execute('delete', { selection: n.createSelection(a, 'on') });
                else {
                  const e = o.getNearestSelectionRange(n.createPositionAt(a, r), s);
                  if (e)
                    if (e.isCollapsed) {
                      const i = n.createSelection(e.start);
                      if ((n.modifySelection(i, { direction: s }), i.focus.isEqual(e.start))) {
                        const t = (function (t, e) {
                          let n = e;
                          for (const o of e.getAncestors({ parentFirst: !0 })) {
                            if (o.childCount > 1 || t.isLimit(o)) break;
                            n = o;
                          }
                          return n;
                        })(o, e.start.parent);
                        n.deleteContent(n.createSelection(t, 'on'), { doNotAutoparagraph: !0 });
                      } else
                        n.change(n => {
                          n.setSelection(e), t.execute(c ? 'deleteForward' : 'delete');
                        });
                    } else
                      n.change(n => {
                        n.setSelection(e), t.execute(c ? 'deleteForward' : 'delete');
                      });
                }
                i.preventDefault(), e.stop();
              },
              { context: $m },
            );
          }
          _enableInsertContentIntegration() {
            const t = this.editor,
              e = this.editor.model,
              n = e.document.selection;
            this._listenToIfEnabled(
              t.model,
              'insertContent',
              (t, [o, i]) => {
                if (i && !i.is('documentSelection')) return;
                const r = og(n);
                return r
                  ? (t.stop(),
                    e.change(t => {
                      const i = n.getSelectedElement(),
                        s = e.createPositionAt(i, r),
                        a = t.createSelection(s),
                        c = e.insertContent(o, a);
                      return t.setSelection(a), c;
                    }))
                  : void 0;
              },
              { priority: 'high' },
            );
          }
          _enableDeleteContentIntegration() {
            const t = this.editor,
              e = this.editor.model.document.selection;
            this._listenToIfEnabled(
              t.model,
              'deleteContent',
              (t, [n]) => {
                if (n && !n.is('documentSelection')) return;
                og(e) && t.stop();
              },
              { priority: 'high' },
            );
          }
        }
        var dg = n(37),
          hg = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(dg.a, hg), dg.a.locals;
        function ug(t) {
          const e = t.model;
          return (n, o) => {
            const i = o.keyCode == Li.arrowup,
              r = o.keyCode == Li.arrowdown,
              s = o.shiftKey,
              a = e.document.selection;
            if (!i && !r) return;
            const c = r;
            if (
              s &&
              (function (t, e) {
                return !t.isCollapsed && t.isBackward == e;
              })(a, c)
            )
              return;
            const l = (function (t, e, n) {
              const o = t.model;
              if (n) {
                const t = e.isCollapsed ? e.focus : e.getLastPosition(),
                  n = pg(o, t, 'forward');
                if (!n) return null;
                const i = o.createRange(t, n),
                  r = mg(o.schema, i, 'backward');
                return r && t.isBefore(r) ? o.createRange(t, r) : null;
              }
              {
                const t = e.isCollapsed ? e.focus : e.getFirstPosition(),
                  n = pg(o, t, 'backward');
                if (!n) return null;
                const i = o.createRange(n, t),
                  r = mg(o.schema, i, 'forward');
                return r && t.isAfter(r) ? o.createRange(r, t) : null;
              }
            })(t, a, c);
            l &&
              !l.isCollapsed &&
              (function (t, e, n) {
                const o = t.model,
                  i = t.view.domConverter;
                if (n) {
                  const t = o.createSelection(e.start);
                  o.modifySelection(t),
                    t.focus.isAtEnd || e.start.isEqual(t.focus) || (e = o.createRange(t.focus, e.end));
                }
                const r = t.mapper.toViewRange(e),
                  s = i.viewRangeToDom(r),
                  a = Vs.getDomRangeRects(s);
                let c;
                for (const t of a)
                  if (void 0 !== c) {
                    if (Math.round(t.top) >= c) return !1;
                    c = Math.max(c, Math.round(t.bottom));
                  } else c = Math.round(t.bottom);
                return !0;
              })(t, l, c) &&
              (e.change(t => {
                const n = c ? l.end : l.start;
                if (s) {
                  const o = e.createSelection(a.anchor);
                  o.setFocus(n), t.setSelection(o);
                } else t.setSelection(n);
              }),
              n.stop(),
              o.preventDefault(),
              o.stopPropagation());
          };
        }
        function pg(t, e, n) {
          const o = t.schema,
            i = t.createRangeIn(e.root),
            r = 'forward' == n ? 'elementStart' : 'elementEnd';
          for (const { previousPosition: t, item: s, type: a } of i.getWalker({ startPosition: e, direction: n })) {
            if (o.isLimit(s) && !o.isInline(s)) return t;
            if (a == r && o.isBlock(s)) return null;
          }
          return null;
        }
        function mg(t, e, n) {
          const o = 'backward' == n ? e.end : e.start;
          if (t.checkChild(o, '$text')) return o;
          for (const { nextPosition: o } of e.getWalker({ direction: n })) if (t.checkChild(o, '$text')) return o;
        }
        class gg extends Qt {
          static get pluginName() {
            return 'Widget';
          }
          static get requires() {
            return [lg, tm];
          }
          init() {
            const t = this.editor.editing.view,
              e = t.document;
            (this._previouslySelected = new Set()),
              this.editor.editing.downcastDispatcher.on(
                'selection',
                (t, e, n) => {
                  this._clearPreviouslySelectedWidgets(n.writer);
                  const o = n.writer,
                    i = o.document.selection,
                    r = i.getSelectedElement();
                  let s = null;
                  for (const t of i.getRanges())
                    for (const e of t) {
                      const t = e.item;
                      $m(t) &&
                        !fg(t, s) &&
                        (o.addClass(jm, t),
                        this._previouslySelected.add(t),
                        (s = t),
                        t == r && o.setSelection(i.getRanges(), { fake: !0, label: Ym(r) }));
                    }
                },
                { priority: 'low' },
              ),
              t.addObserver(Lu),
              this.listenTo(e, 'mousedown', (...t) => this._onMousedown(...t)),
              this.listenTo(
                e,
                'arrowKey',
                (...t) => {
                  this._handleSelectionChangeOnArrowKeyPress(...t);
                },
                { context: [$m, '$text'] },
              ),
              this.listenTo(
                e,
                'arrowKey',
                (...t) => {
                  this._preventDefaultOnArrowKeyPress(...t);
                },
                { context: '$root' },
              ),
              this.listenTo(e, 'arrowKey', ug(this.editor.editing), { context: '$text' }),
              this.listenTo(
                e,
                'delete',
                (t, e) => {
                  this._handleDelete('forward' == e.direction) && (e.preventDefault(), t.stop());
                },
                { context: '$root' },
              );
          }
          _onMousedown(t, e) {
            const n = this.editor,
              o = n.editing.view,
              i = o.document;
            let r = e.target;
            if (
              (function (t) {
                for (; t; ) {
                  if (t.is('editableElement') && !t.is('rootElement')) return !0;
                  if ($m(t)) return !1;
                  t = t.parent;
                }
                return !1;
              })(r)
            ) {
              if ((Mi.isSafari || Mi.isGecko) && e.domEvent.detail >= 3) {
                const t = n.editing.mapper,
                  o = r.is('attributeElement') ? r.findAncestor(t => !t.is('attributeElement')) : r,
                  i = t.toModelElement(o);
                e.preventDefault(),
                  this.editor.model.change(t => {
                    t.setSelection(i, 'in');
                  });
              }
              return;
            }
            if (!$m(r) && ((r = r.findAncestor($m)), !r)) return;
            Mi.isAndroid && e.preventDefault(), i.isFocused || o.focus();
            const s = n.editing.mapper.toModelElement(r);
            this._setSelectionOverElement(s);
          }
          _handleSelectionChangeOnArrowKeyPress(t, e) {
            const n = e.keyCode,
              o = this.editor.model,
              i = o.schema,
              r = o.document.selection,
              s = r.getSelectedElement(),
              a = Gi(n, this.editor.locale.contentLanguageDirection);
            if (s && i.isObject(s)) {
              const n = a ? r.getLastPosition() : r.getFirstPosition(),
                s = i.getNearestSelectionRange(n, a ? 'forward' : 'backward');
              return void (
                s &&
                (o.change(t => {
                  t.setSelection(s);
                }),
                e.preventDefault(),
                t.stop())
              );
            }
            if (!r.isCollapsed) return;
            const c = this._getObjectElementNextToSelection(a);
            c && i.isObject(c) && (this._setSelectionOverElement(c), e.preventDefault(), t.stop());
          }
          _preventDefaultOnArrowKeyPress(t, e) {
            const n = this.editor.model,
              o = n.schema,
              i = n.document.selection.getSelectedElement();
            i && o.isObject(i) && (e.preventDefault(), t.stop());
          }
          _handleDelete(t) {
            if (this.editor.isReadOnly) return;
            const e = this.editor.model.document.selection;
            if (!e.isCollapsed) return;
            const n = this._getObjectElementNextToSelection(t);
            return n
              ? (this.editor.model.change(t => {
                  let o = e.anchor.parent;
                  for (; o.isEmpty; ) {
                    const e = o;
                    (o = e.parent), t.remove(e);
                  }
                  this._setSelectionOverElement(n);
                }),
                !0)
              : void 0;
          }
          _setSelectionOverElement(t) {
            this.editor.model.change(e => {
              e.setSelection(e.createRangeOn(t));
            });
          }
          _getObjectElementNextToSelection(t) {
            const e = this.editor.model,
              n = e.schema,
              o = e.document.selection,
              i = e.createSelection(o);
            e.modifySelection(i, { direction: t ? 'forward' : 'backward' });
            const r = t ? i.focus.nodeBefore : i.focus.nodeAfter;
            return r && n.isObject(r) ? r : null;
          }
          _clearPreviouslySelectedWidgets(t) {
            for (const e of this._previouslySelected) t.removeClass(jm, e);
            this._previouslySelected.clear();
          }
        }
        function fg(t, e) {
          return !!e && Array.from(t.getAncestors()).includes(e);
        }
        var kg = function (t, e, n) {
            var o = !0,
              i = !0;
            if ('function' != typeof t) throw new TypeError('Expected a function');
            return (
              w(n) && ((o = 'leading' in n ? !!n.leading : o), (i = 'trailing' in n ? !!n.trailing : i)),
              Ss(t, e, { leading: o, maxWait: e, trailing: i })
            );
          },
          bg = n(38),
          wg = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(bg.a, wg), bg.a.locals;
        class Ag extends Qt {
          static get pluginName() {
            return 'DragDrop';
          }
          static get requires() {
            return [Nm, gg];
          }
          init() {
            const t = this.editor,
              e = t.editing.view;
            (this._draggedRange = null),
              (this._draggingUid = ''),
              (this._draggableElement = null),
              (this._updateDropMarkerThrottled = kg(t => this._updateDropMarker(t), 40)),
              (this._removeDropMarkerDelayed = vg(() => this._removeDropMarker(), 40)),
              (this._clearDraggableAttributesDelayed = vg(() => this._clearDraggableAttributes(), 40)),
              e.addObserver(Rm),
              e.addObserver(Lu),
              this._setupDragging(),
              this._setupContentInsertionIntegration(),
              this._setupClipboardInputIntegration(),
              this._setupDropMarker(),
              this._setupDraggableAttributeHandling(),
              this.listenTo(t, 'change:isReadOnly', (t, e, n) => {
                n ? this.forceDisabled('readOnlyMode') : this.clearForceDisabled('readOnlyMode');
              }),
              this.on('change:isEnabled', (t, e, n) => {
                n || this._finalizeDragging(!1);
              }),
              Mi.isAndroid && this.forceDisabled('noAndroidSupport');
          }
          destroy() {
            return (
              this._draggedRange && (this._draggedRange.detach(), (this._draggedRange = null)),
              this._updateDropMarkerThrottled.cancel(),
              this._removeDropMarkerDelayed.cancel(),
              this._clearDraggableAttributesDelayed.cancel(),
              super.destroy()
            );
          }
          _setupDragging() {
            const t = this.editor,
              e = t.model,
              n = e.document,
              o = t.editing.view,
              i = o.document;
            this.listenTo(
              i,
              'dragstart',
              (o, r) => {
                const a = n.selection;
                if (r.target && r.target.is('editableElement')) return void r.preventDefault();
                const c = r.target ? yg(r.target) : null;
                if (c) {
                  const n = t.editing.mapper.toModelElement(c);
                  this._draggedRange = Pa.fromRange(e.createRangeOn(n));
                } else if (!i.selection.isCollapsed) {
                  const t = i.selection.getSelectedElement();
                  (t && $m(t)) || (this._draggedRange = Pa.fromRange(a.getFirstRange()));
                }
                if (!this._draggedRange) return void r.preventDefault();
                (this._draggingUid = s()),
                  (r.dataTransfer.effectAllowed = this.isEnabled ? 'copyMove' : 'copy'),
                  r.dataTransfer.setData('application/ckeditor5-dragging-uid', this._draggingUid);
                const l = e.createSelection(this._draggedRange.toRange()),
                  d = t.data.toView(e.getSelectedContent(l));
                i.fire('clipboardOutput', { dataTransfer: r.dataTransfer, content: d, method: o.name }),
                  this.isEnabled ||
                    (this._draggedRange.detach(), (this._draggedRange = null), (this._draggingUid = ''));
              },
              { priority: 'low' },
            ),
              this.listenTo(
                i,
                'dragend',
                (t, e) => {
                  this._finalizeDragging(!e.dataTransfer.isCanceled && 'move' == e.dataTransfer.dropEffect);
                },
                { priority: 'low' },
              ),
              this.listenTo(i, 'dragenter', () => {
                this.isEnabled && o.focus();
              }),
              this.listenTo(i, 'dragleave', () => {
                this._removeDropMarkerDelayed();
              }),
              this.listenTo(
                i,
                'dragging',
                (e, n) => {
                  if (!this.isEnabled) return void (n.dataTransfer.dropEffect = 'none');
                  this._removeDropMarkerDelayed.cancel();
                  const o = _g(t, n.targetRanges, n.target);
                  this._draggedRange || (n.dataTransfer.dropEffect = 'copy'),
                    Mi.isGecko ||
                      ('copy' == n.dataTransfer.effectAllowed
                        ? (n.dataTransfer.dropEffect = 'copy')
                        : ['all', 'copyMove'].includes(n.dataTransfer.effectAllowed) &&
                          (n.dataTransfer.dropEffect = 'move')),
                    o && this._updateDropMarkerThrottled(o);
                },
                { priority: 'low' },
              );
          }
          _setupClipboardInputIntegration() {
            const t = this.editor,
              e = t.editing.view.document;
            this.listenTo(
              e,
              'clipboardInput',
              (e, n) => {
                if ('drop' != n.method) return;
                const o = _g(t, n.targetRanges, n.target);
                if ((this._removeDropMarker(), !o)) return this._finalizeDragging(!1), void e.stop();
                this._draggedRange &&
                  this._draggingUid != n.dataTransfer.getData('application/ckeditor5-dragging-uid') &&
                  (this._draggedRange.detach(), (this._draggedRange = null), (this._draggingUid = ''));
                if ('move' == Cg(n.dataTransfer) && this._draggedRange && this._draggedRange.containsRange(o, !0))
                  return this._finalizeDragging(!1), void e.stop();
                n.targetRanges = [t.editing.mapper.toViewRange(o)];
              },
              { priority: 'high' },
            );
          }
          _setupContentInsertionIntegration() {
            const t = this.editor.plugins.get(Nm);
            t.on(
              'contentInsertion',
              (t, e) => {
                if (!this.isEnabled || 'drop' !== e.method) return;
                const n = e.targetRanges.map(t => this.editor.editing.mapper.toModelRange(t));
                this.editor.model.change(t => t.setSelection(n));
              },
              { priority: 'high' },
            ),
              t.on(
                'contentInsertion',
                (t, e) => {
                  if (!this.isEnabled || 'drop' !== e.method) return;
                  const n = 'move' == Cg(e.dataTransfer),
                    o = !e.resultRange || !e.resultRange.isCollapsed;
                  this._finalizeDragging(o && n);
                },
                { priority: 'lowest' },
              );
          }
          _setupDraggableAttributeHandling() {
            const t = this.editor,
              e = t.editing.view,
              n = e.document;
            this.listenTo(n, 'mousedown', (o, i) => {
              if (Mi.isAndroid || !i) return;
              this._clearDraggableAttributesDelayed.cancel();
              let r = yg(i.target);
              if (Mi.isBlink && !t.isReadOnly && !r && !n.selection.isCollapsed) {
                const t = n.selection.getSelectedElement();
                (t && $m(t)) || (r = n.selection.editableElement);
              }
              r &&
                (e.change(t => {
                  t.setAttribute('draggable', 'true', r);
                }),
                (this._draggableElement = t.editing.mapper.toModelElement(r)));
            }),
              this.listenTo(n, 'mouseup', () => {
                Mi.isAndroid || this._clearDraggableAttributesDelayed();
              });
          }
          _clearDraggableAttributes() {
            const t = this.editor.editing;
            t.view.change(e => {
              this._draggableElement &&
                '$graveyard' != this._draggableElement.root.rootName &&
                e.removeAttribute('draggable', t.mapper.toViewElement(this._draggableElement)),
                (this._draggableElement = null);
            });
          }
          _setupDropMarker() {
            const t = this.editor;
            t.conversion
              .for('editingDowncast')
              .markerToHighlight({ model: 'drop-target', view: { classes: ['ck-clipboard-drop-target-range'] } }),
              t.conversion.for('editingDowncast').markerToElement({
                model: 'drop-target',
                view: (e, { writer: n }) => {
                  if (t.model.schema.checkChild(e.markerRange.start, '$text'))
                    return n.createUIElement('span', { class: 'ck ck-clipboard-drop-target-position' }, function (t) {
                      const e = this.toDomElement(t);
                      return (e.innerHTML = '&NoBreak;<span></span>&NoBreak;'), e;
                    });
                },
              });
          }
          _updateDropMarker(t) {
            const e = this.editor,
              n = e.model.markers;
            e.model.change(e => {
              n.has('drop-target')
                ? n.get('drop-target').getRange().isEqual(t) || e.updateMarker('drop-target', { range: t })
                : e.addMarker('drop-target', { range: t, usingOperation: !1, affectsData: !1 });
            });
          }
          _removeDropMarker() {
            const t = this.editor.model;
            this._removeDropMarkerDelayed.cancel(),
              this._updateDropMarkerThrottled.cancel(),
              t.markers.has('drop-target') &&
                t.change(t => {
                  t.removeMarker('drop-target');
                });
          }
          _finalizeDragging(t) {
            const e = this.editor.model;
            this._removeDropMarker(),
              this._clearDraggableAttributes(),
              (this._draggingUid = ''),
              this._draggedRange &&
                (t &&
                  this.isEnabled &&
                  e.deleteContent(e.createSelection(this._draggedRange), { doNotAutoparagraph: !0 }),
                this._draggedRange.detach(),
                (this._draggedRange = null));
          }
        }
        function _g(t, e, n) {
          const o = t.model,
            i = t.editing.mapper;
          let r = null;
          const s = e ? e[0].start : null;
          if (
            (n.is('uiElement') && (n = n.parent),
            (r = (function (t, e) {
              const n = t.model,
                o = t.editing.mapper;
              if ($m(e)) return n.createRangeOn(o.toModelElement(e));
              if (!e.is('editableElement')) {
                const t = e.findAncestor(t => $m(t) || t.is('editableElement'));
                if ($m(t)) return n.createRangeOn(o.toModelElement(t));
              }
              return null;
            })(t, n)),
            r)
          )
            return r;
          const a = (function (t, e) {
              const n = t.editing.mapper,
                o = t.editing.view,
                i = n.toModelElement(e);
              if (i) return i;
              const r = o.createPositionBefore(e),
                s = n.findMappedViewAncestor(r);
              return n.toModelElement(s);
            })(t, n),
            c = s ? i.toModelPosition(s) : null;
          return c
            ? ((r = (function (t, e, n) {
                const o = t.model;
                if (!o.schema.checkChild(n, '$block')) return null;
                const i = o.createPositionAt(n, 0),
                  r = e.path.slice(0, i.path.length),
                  s = o.createPositionFromPath(e.root, r).nodeAfter;
                if (s && o.schema.isObject(s)) return o.createRangeOn(s);
                return null;
              })(t, c, a)),
              r ||
                ((r = o.schema.getNearestSelectionRange(c, Mi.isGecko ? 'forward' : 'backward')),
                r ||
                  (function (t, e) {
                    const n = t.model;
                    for (; e; ) {
                      if (n.schema.isObject(e)) return n.createRangeOn(e);
                      e = e.parent;
                    }
                  })(t, c.parent)))
            : (function (t, e) {
                const n = t.model,
                  o = n.schema,
                  i = n.createPositionAt(e, 0);
                return o.getNearestSelectionRange(i, 'forward');
              })(t, a);
        }
        function Cg(t) {
          return Mi.isGecko ? t.dropEffect : ['all', 'copyMove'].includes(t.effectAllowed) ? 'move' : 'copy';
        }
        function vg(t, e) {
          let n;
          function o(...i) {
            o.cancel(), (n = setTimeout(() => t(...i), e));
          }
          return (
            (o.cancel = () => {
              clearTimeout(n);
            }),
            o
          );
        }
        function yg(t) {
          if (t.is('editableElement')) return null;
          if (t.hasClass('ck-widget__selection-handle')) return t.findAncestor($m);
          if ($m(t)) return t;
          const e = t.findAncestor(t => $m(t) || t.is('editableElement'));
          return $m(e) ? e : null;
        }
        class xg extends Qt {
          static get pluginName() {
            return 'PastePlainText';
          }
          static get requires() {
            return [Nm];
          }
          init() {
            const t = this.editor,
              e = t.model,
              n = t.editing.view,
              o = n.document,
              i = e.document.selection;
            let r = !1;
            n.addObserver(Rm),
              this.listenTo(o, 'keydown', (t, e) => {
                r = e.shiftKey;
              }),
              t.plugins.get(Nm).on('contentInsertion', (t, n) => {
                (r ||
                  (function (t, e) {
                    if (t.childCount > 1) return !1;
                    const n = t.getChild(0);
                    if (e.isObject(n)) return !1;
                    return 0 == [...n.getAttributeKeys()].length;
                  })(n.content, e.schema)) &&
                  e.change(t => {
                    const o = Array.from(i.getAttributes()).filter(
                      ([t]) => e.schema.getAttributeProperties(t).isFormatting,
                    );
                    i.isCollapsed || e.deleteContent(i, { doNotAutoparagraph: !0 }), o.push(...i.getAttributes());
                    const r = t.createRangeIn(n.content);
                    for (const e of r.getItems()) e.is('$textProxy') && t.setAttributes(o, e);
                  });
              });
          }
        }
        class Eg extends Qt {
          static get pluginName() {
            return 'Clipboard';
          }
          static get requires() {
            return [Nm, Ag, xg];
          }
        }
        class Dg extends Zt {
          execute() {
            const t = this.editor.model,
              e = t.document.selection;
            let n = t.schema.getLimitElement(e);
            if (e.containsEntireContent(n) || !Sg(t.schema, n))
              do {
                if (((n = n.parent), !n)) return;
              } while (!Sg(t.schema, n));
            t.change(t => {
              t.setSelection(n, 'in');
            });
          }
        }
        function Sg(t, e) {
          return t.isLimit(e) && (t.checkChild(e, '$text') || t.checkChild(e, 'paragraph'));
        }
        const Bg = Hi('Ctrl+A');
        class Tg extends Qt {
          static get pluginName() {
            return 'SelectAllEditing';
          }
          init() {
            const t = this.editor,
              e = t.editing.view.document;
            t.commands.add('selectAll', new Dg(t)),
              this.listenTo(e, 'keydown', (e, n) => {
                qi(n) === Bg && (t.execute('selectAll'), n.preventDefault());
              });
          }
        }
        class Pg extends Qt {
          static get pluginName() {
            return 'SelectAllUI';
          }
          init() {
            const t = this.editor;
            t.ui.componentFactory.add('selectAll', e => {
              const n = t.commands.get('selectAll'),
                o = new jd(e),
                i = e.t;
              return (
                o.set({
                  label: i('Select all'),
                  icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>',
                  keystroke: 'Ctrl+A',
                  tooltip: !0,
                }),
                o.bind('isOn', 'isEnabled').to(n, 'value', 'isEnabled'),
                this.listenTo(o, 'execute', () => {
                  t.execute('selectAll'), t.editing.view.focus();
                }),
                o
              );
            });
          }
        }
        class Ig extends Qt {
          static get requires() {
            return [Tg, Pg];
          }
          static get pluginName() {
            return 'SelectAll';
          }
        }
        class zg extends Zt {
          constructor(t) {
            super(t),
              (this._stack = []),
              (this._createdBatches = new WeakSet()),
              this.refresh(),
              this.listenTo(t.data, 'set', () => this.clearStack());
          }
          refresh() {
            this.isEnabled = this._stack.length > 0;
          }
          addBatch(t) {
            const e = this.editor.model.document.selection,
              n = { ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [], isBackward: e.isBackward };
            this._stack.push({ batch: t, selection: n }), this.refresh();
          }
          clearStack() {
            (this._stack = []), this.refresh();
          }
          _restoreSelection(t, e, n) {
            const o = this.editor.model,
              i = o.document,
              r = [],
              s = t.map(t => t.getTransformedByOperations(n)),
              a = s.flat();
            for (const t of s) {
              const e = t.filter(t => t.root != i.graveyard).filter(t => !Rg(t, a));
              e.length && (Fg(e), r.push(e[0]));
            }
            r.length &&
              o.change(t => {
                t.setSelection(r, { backward: e });
              });
          }
          _undo(t, e) {
            const n = this.editor.model,
              o = n.document;
            this._createdBatches.add(e);
            const i = t.operations.slice().filter(t => t.isDocumentOperation);
            i.reverse();
            for (const t of i) {
              const i = t.baseVersion + 1,
                r = Array.from(o.history.getOperations(i)),
                s = Iu([t.getReversed()], r, {
                  useRelations: !0,
                  document: this.editor.model.document,
                  padWithNoOps: !1,
                  forceWeakRemove: !0,
                }).operationsA;
              for (const i of s) e.addOperation(i), n.applyOperation(i), o.history.setOperationAsUndone(t, i);
            }
          }
        }
        function Fg(t) {
          t.sort((t, e) => (t.start.isBefore(e.start) ? -1 : 1));
          for (let e = 1; e < t.length; e++) {
            const n = t[e - 1].getJoined(t[e], !0);
            n && (e--, t.splice(e, 2, n));
          }
        }
        function Rg(t, e) {
          return e.some(e => e !== t && e.containsRange(t, !0));
        }
        class Og extends zg {
          execute(t = null) {
            const e = t ? this._stack.findIndex(e => e.batch == t) : this._stack.length - 1,
              n = this._stack.splice(e, 1)[0],
              o = this.editor.model.createBatch('transparent');
            this.editor.model.enqueueChange(o, () => {
              this._undo(n.batch, o);
              const t = this.editor.model.document.history.getOperations(n.batch.baseVersion);
              this._restoreSelection(n.selection.ranges, n.selection.isBackward, t), this.fire('revert', n.batch, o);
            }),
              this.refresh();
          }
        }
        class Mg extends zg {
          execute() {
            const t = this._stack.pop(),
              e = this.editor.model.createBatch('transparent');
            this.editor.model.enqueueChange(e, () => {
              const n = t.batch.operations[t.batch.operations.length - 1].baseVersion + 1,
                o = this.editor.model.document.history.getOperations(n);
              this._restoreSelection(t.selection.ranges, t.selection.isBackward, o), this._undo(t.batch, e);
            }),
              this.refresh();
          }
        }
        class Ng extends Qt {
          static get pluginName() {
            return 'UndoEditing';
          }
          constructor(t) {
            super(t), (this._batchRegistry = new WeakSet());
          }
          init() {
            const t = this.editor;
            (this._undoCommand = new Og(t)),
              (this._redoCommand = new Mg(t)),
              t.commands.add('undo', this._undoCommand),
              t.commands.add('redo', this._redoCommand),
              this.listenTo(
                t.model,
                'applyOperation',
                (t, e) => {
                  const n = e[0];
                  if (!n.isDocumentOperation) return;
                  const o = n.batch,
                    i = this._redoCommand._createdBatches.has(o),
                    r = this._undoCommand._createdBatches.has(o);
                  this._batchRegistry.has(o) ||
                    ('transparent' == o.type && !i && !r) ||
                    (i
                      ? this._undoCommand.addBatch(o)
                      : r || (this._undoCommand.addBatch(o), this._redoCommand.clearStack()),
                    this._batchRegistry.add(o));
                },
                { priority: 'highest' },
              ),
              this.listenTo(this._undoCommand, 'revert', (t, e, n) => {
                this._redoCommand.addBatch(n);
              }),
              t.keystrokes.set('CTRL+Z', 'undo'),
              t.keystrokes.set('CTRL+Y', 'redo'),
              t.keystrokes.set('CTRL+SHIFT+Z', 'redo');
          }
        }
        var Vg =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>',
          Lg =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
        class Kg extends Qt {
          static get pluginName() {
            return 'UndoUI';
          }
          init() {
            const t = this.editor,
              e = t.locale,
              n = t.t,
              o = 'ltr' == e.uiLanguageDirection ? Vg : Lg,
              i = 'ltr' == e.uiLanguageDirection ? Lg : Vg;
            this._addButton('undo', n('Undo'), 'CTRL+Z', o), this._addButton('redo', n('Redo'), 'CTRL+Y', i);
          }
          _addButton(t, e, n, o) {
            const i = this.editor;
            i.ui.componentFactory.add(t, r => {
              const s = i.commands.get(t),
                a = new jd(r);
              return (
                a.set({ label: e, icon: o, keystroke: n, tooltip: !0 }),
                a.bind('isEnabled').to(s, 'isEnabled'),
                this.listenTo(a, 'execute', () => {
                  i.execute(t), i.editing.view.focus();
                }),
                a
              );
            });
          }
        }
        class qg extends Qt {
          static get requires() {
            return [Ng, Kg];
          }
          static get pluginName() {
            return 'Undo';
          }
        }
        class Hg extends Zt {
          constructor(t, e) {
            super(t), (this.attributeKey = e);
          }
          refresh() {
            const t = this.editor.model,
              e = t.document;
            (this.value = e.selection.getAttribute(this.attributeKey)),
              (this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey));
          }
          execute(t = {}) {
            const e = this.editor.model,
              n = e.document.selection,
              o = t.value;
            e.change(t => {
              if (n.isCollapsed)
                o ? t.setSelectionAttribute(this.attributeKey, o) : t.removeSelectionAttribute(this.attributeKey);
              else {
                const i = e.schema.getValidRanges(n.getRanges(), this.attributeKey);
                for (const e of i)
                  o ? t.setAttribute(this.attributeKey, o, e) : t.removeAttribute(this.attributeKey, e);
              }
            });
          }
        }
        class jg extends co {
          constructor(t) {
            super(t),
              this.set('isEmpty', !0),
              this.on('change', () => {
                this.set('isEmpty', 0 === this.length);
              });
          }
          add(t, e) {
            this.find(e => e.color === t.color) || super.add(t, e);
          }
          hasColor(t) {
            return !!this.find(e => e.color === t);
          }
        }
        Yt(jg, jt);
        var $g = n(39),
          Gg = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()($g.a, Gg), $g.a.locals;
        class Wg extends md {
          constructor(
            t,
            { colors: e, columns: n, removeButtonLabel: o, documentColorsLabel: i, documentColorsCount: r },
          ) {
            super(t),
              (this.items = this.createCollection()),
              (this.colorDefinitions = e),
              (this.focusTracker = new Ws()),
              (this.keystrokes = new Us()),
              this.set('selectedColor'),
              (this.removeButtonLabel = o),
              (this.columns = n),
              (this.documentColors = new jg()),
              (this.documentColorsCount = r),
              (this._focusCycler = new Yd({
                focusables: this.items,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: { focusPrevious: 'arrowup', focusNext: 'arrowdown' },
              })),
              (this._documentColorsLabel = i),
              this.setTemplate({ tag: 'div', attributes: { class: ['ck', 'ck-color-table'] }, children: this.items }),
              this.items.add(this._removeColorButton());
          }
          updateDocumentColors(t, e) {
            const n = t.document,
              o = this.documentColorsCount;
            this.documentColors.clear();
            for (const i of n.getRootNames()) {
              const r = n.getRoot(i),
                s = t.createRangeIn(r);
              for (const t of s.getItems())
                if (
                  t.is('$textProxy') &&
                  t.hasAttribute(e) &&
                  (this._addColorToDocumentColors(t.getAttribute(e)), this.documentColors.length >= o)
                )
                  return;
            }
          }
          updateSelectedColors() {
            const t = this.documentColorsGrid,
              e = this.staticColorsGrid,
              n = this.selectedColor;
            (e.selectedColor = n), t && (t.selectedColor = n);
          }
          render() {
            super.render();
            for (const t of this.items) this.focusTracker.add(t.element);
            this.keystrokes.listenTo(this.element);
          }
          appendGrids() {
            if (
              !this.staticColorsGrid &&
              ((this.staticColorsGrid = this._createStaticColorsGrid()),
              this.items.add(this.staticColorsGrid),
              this.documentColorsCount)
            ) {
              const t = gd.bind(this.documentColors, this.documentColors),
                e = new Lh(this.locale);
              (e.text = this._documentColorsLabel),
                e.extendTemplate({
                  attributes: { class: ['ck', 'ck-color-grid__label', t.if('isEmpty', 'ck-hidden')] },
                }),
                this.items.add(e),
                (this.documentColorsGrid = this._createDocumentColorsGrid()),
                this.items.add(this.documentColorsGrid);
            }
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          focusLast() {
            this._focusCycler.focusLast();
          }
          _removeColorButton() {
            const t = new jd();
            return (
              t.set({ withText: !0, icon: Gl, tooltip: !0, label: this.removeButtonLabel }),
              (t.class = 'ck-color-table__remove-color'),
              t.on('execute', () => {
                this.fire('execute', { value: null });
              }),
              t
            );
          }
          _createStaticColorsGrid() {
            const t = new th(this.locale, { colorDefinitions: this.colorDefinitions, columns: this.columns });
            return t.delegate('execute').to(this), t;
          }
          _createDocumentColorsGrid() {
            const t = gd.bind(this.documentColors, this.documentColors),
              e = new th(this.locale, { columns: this.columns });
            return (
              e.delegate('execute').to(this),
              e.extendTemplate({ attributes: { class: t.if('isEmpty', 'ck-hidden') } }),
              e.items.bindTo(this.documentColors).using(t => {
                const e = new Jd();
                return (
                  e.set({ color: t.color, hasBorder: t.options && t.options.hasBorder }),
                  t.label && e.set({ label: t.label, tooltip: !0 }),
                  e.on('execute', () => {
                    this.fire('execute', { value: t.color });
                  }),
                  e
                );
              }),
              this.documentColors.on('change:isEmpty', (t, n, o) => {
                o && (e.selectedColor = null);
              }),
              e
            );
          }
          _addColorToDocumentColors(t) {
            const e = this.colorDefinitions.find(e => e.color === t);
            e
              ? this.documentColors.add(Object.assign({}, e))
              : this.documentColors.add({ color: t, label: t, options: { hasBorder: !1 } });
          }
        }
        const Ug = 'fontSize',
          Jg = 'fontFamily',
          Yg = 'fontColor',
          Qg = 'fontBackgroundColor';
        function Xg(t, e) {
          const n = { model: { key: t, values: [] }, view: {}, upcastAlso: {} };
          for (const t of e)
            n.model.values.push(t.model),
              (n.view[t.model] = t.view),
              t.upcastAlso && (n.upcastAlso[t.model] = t.upcastAlso);
          return n;
        }
        function Zg(t) {
          return e => e.getStyle(t).replace(/\s/g, '');
        }
        function tf(t) {
          return (e, { writer: n }) => n.createAttributeElement('span', { style: `${t}:${e}` }, { priority: 7 });
        }
        class ef extends Hg {
          constructor(t) {
            super(t, Qg);
          }
        }
        class nf extends Qt {
          static get pluginName() {
            return 'FontBackgroundColorEditing';
          }
          constructor(t) {
            super(t),
              t.config.define(Qg, {
                colors: [
                  { color: 'hsl(0, 0%, 0%)', label: 'Black' },
                  { color: 'hsl(0, 0%, 30%)', label: 'Dim grey' },
                  { color: 'hsl(0, 0%, 60%)', label: 'Grey' },
                  { color: 'hsl(0, 0%, 90%)', label: 'Light grey' },
                  { color: 'hsl(0, 0%, 100%)', label: 'White', hasBorder: !0 },
                  { color: 'hsl(0, 75%, 60%)', label: 'Red' },
                  { color: 'hsl(30, 75%, 60%)', label: 'Orange' },
                  { color: 'hsl(60, 75%, 60%)', label: 'Yellow' },
                  { color: 'hsl(90, 75%, 60%)', label: 'Light green' },
                  { color: 'hsl(120, 75%, 60%)', label: 'Green' },
                  { color: 'hsl(150, 75%, 60%)', label: 'Aquamarine' },
                  { color: 'hsl(180, 75%, 60%)', label: 'Turquoise' },
                  { color: 'hsl(210, 75%, 60%)', label: 'Light blue' },
                  { color: 'hsl(240, 75%, 60%)', label: 'Blue' },
                  { color: 'hsl(270, 75%, 60%)', label: 'Purple' },
                ],
                columns: 5,
              }),
              t.data.addStyleProcessorRules(dp),
              t.conversion.for('upcast').elementToAttribute({
                view: { name: 'span', styles: { 'background-color': /[\s\S]+/ } },
                model: { key: Qg, value: Zg('background-color') },
              }),
              t.conversion.for('downcast').attributeToElement({ model: Qg, view: tf('background-color') }),
              t.commands.add(Qg, new ef(t)),
              t.model.schema.extend('$text', { allowAttributes: Qg }),
              t.model.schema.setAttributeProperties(Qg, { isFormatting: !0, copyOnEnter: !0 });
          }
        }
        class of extends Qt {
          constructor(t, { commandName: e, icon: n, componentName: o, dropdownLabel: i }) {
            super(t),
              (this.commandName = e),
              (this.componentName = o),
              (this.icon = n),
              (this.dropdownLabel = i),
              (this.columns = t.config.get(`${this.componentName}.columns`)),
              (this.colorTableView = void 0);
          }
          init() {
            const t = this.editor,
              e = t.locale,
              n = e.t,
              o = t.commands.get(this.commandName);
            const i = (function (t, e) {
                const n = t.t,
                  o = {
                    Black: n('Black'),
                    'Dim grey': n('Dim grey'),
                    Grey: n('Grey'),
                    'Light grey': n('Light grey'),
                    White: n('White'),
                    Red: n('Red'),
                    Orange: n('Orange'),
                    Yellow: n('Yellow'),
                    'Light green': n('Light green'),
                    Green: n('Green'),
                    Aquamarine: n('Aquamarine'),
                    Turquoise: n('Turquoise'),
                    'Light blue': n('Light blue'),
                    Blue: n('Blue'),
                    Purple: n('Purple'),
                  };
                return e.map(t => {
                  const e = o[t.label];
                  return e && e != t.label && (t.label = e), t;
                });
              })(
                e,
                t.config
                  .get(this.componentName)
                  .colors.map(Ud)
                  .filter(t => !!t),
              ),
              r = t.config.get(`${this.componentName}.documentColors`);
            t.ui.componentFactory.add(this.componentName, e => {
              const s = Ih(e);
              return (
                (this.colorTableView = (function ({
                  dropdownView: t,
                  colors: e,
                  columns: n,
                  removeButtonLabel: o,
                  documentColorsLabel: i,
                  documentColorsCount: r,
                }) {
                  const s = t.locale,
                    a = new Wg(s, {
                      colors: e,
                      columns: n,
                      removeButtonLabel: o,
                      documentColorsLabel: i,
                      documentColorsCount: r,
                    });
                  return (t.colorTableView = a), t.panelView.children.add(a), a.delegate('execute').to(t, 'execute'), a;
                })({
                  dropdownView: s,
                  colors: i.map(t => ({ label: t.label, color: t.model, options: { hasBorder: t.hasBorder } })),
                  columns: this.columns,
                  removeButtonLabel: n('Remove color'),
                  documentColorsLabel: 0 !== r ? n('Document colors') : void 0,
                  documentColorsCount: void 0 === r ? this.columns : r,
                })),
                this.colorTableView.bind('selectedColor').to(o, 'value'),
                s.buttonView.set({ label: this.dropdownLabel, icon: this.icon, tooltip: !0 }),
                s.extendTemplate({ attributes: { class: 'ck-color-ui-dropdown' } }),
                s.bind('isEnabled').to(o),
                s.on('execute', (e, n) => {
                  t.execute(this.commandName, n), t.editing.view.focus();
                }),
                s.on('change:isOpen', (e, n, o) => {
                  s.colorTableView.appendGrids(),
                    o &&
                      (0 !== r && this.colorTableView.updateDocumentColors(t.model, this.componentName),
                      this.colorTableView.updateSelectedColors());
                }),
                s
              );
            });
          }
        }
        class rf extends of {
          constructor(t) {
            const e = t.locale.t;
            super(t, {
              commandName: Qg,
              componentName: Qg,
              icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z"/></svg>',
              dropdownLabel: e('Font Background Color'),
            });
          }
          static get pluginName() {
            return 'FontBackgroundColorUI';
          }
        }
        class sf extends Hg {
          constructor(t) {
            super(t, Yg);
          }
        }
        class af extends Qt {
          static get pluginName() {
            return 'FontColorEditing';
          }
          constructor(t) {
            super(t),
              t.config.define(Yg, {
                colors: [
                  { color: 'hsl(0, 0%, 0%)', label: 'Black' },
                  { color: 'hsl(0, 0%, 30%)', label: 'Dim grey' },
                  { color: 'hsl(0, 0%, 60%)', label: 'Grey' },
                  { color: 'hsl(0, 0%, 90%)', label: 'Light grey' },
                  { color: 'hsl(0, 0%, 100%)', label: 'White', hasBorder: !0 },
                  { color: 'hsl(0, 75%, 60%)', label: 'Red' },
                  { color: 'hsl(30, 75%, 60%)', label: 'Orange' },
                  { color: 'hsl(60, 75%, 60%)', label: 'Yellow' },
                  { color: 'hsl(90, 75%, 60%)', label: 'Light green' },
                  { color: 'hsl(120, 75%, 60%)', label: 'Green' },
                  { color: 'hsl(150, 75%, 60%)', label: 'Aquamarine' },
                  { color: 'hsl(180, 75%, 60%)', label: 'Turquoise' },
                  { color: 'hsl(210, 75%, 60%)', label: 'Light blue' },
                  { color: 'hsl(240, 75%, 60%)', label: 'Blue' },
                  { color: 'hsl(270, 75%, 60%)', label: 'Purple' },
                ],
                columns: 5,
              }),
              t.conversion.for('upcast').elementToAttribute({
                view: { name: 'span', styles: { color: /[\s\S]+/ } },
                model: { key: Yg, value: Zg('color') },
              }),
              t.conversion.for('upcast').elementToAttribute({
                view: { name: 'font', attributes: { color: /^#?\w+$/ } },
                model: { key: Yg, value: t => t.getAttribute('color') },
              }),
              t.conversion.for('downcast').attributeToElement({ model: Yg, view: tf('color') }),
              t.commands.add(Yg, new sf(t)),
              t.model.schema.extend('$text', { allowAttributes: Yg }),
              t.model.schema.setAttributeProperties(Yg, { isFormatting: !0, copyOnEnter: !0 });
          }
        }
        class cf extends of {
          constructor(t) {
            const e = t.locale.t;
            super(t, {
              commandName: Yg,
              componentName: Yg,
              icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3 10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>',
              dropdownLabel: e('Font Color'),
            });
          }
          static get pluginName() {
            return 'FontColorUI';
          }
        }
        class lf extends Hg {
          constructor(t) {
            super(t, Jg);
          }
        }
        function df(t) {
          return t.map(hf).filter(t => !!t);
        }
        function hf(t) {
          return 'object' == typeof t
            ? t
            : 'default' === t
            ? { title: 'Default', model: void 0 }
            : 'string' == typeof t
            ? (function (t) {
                const e = t.replace(/"|'/g, '').split(','),
                  n = e[0],
                  o = e.map(uf).join(', ');
                return { title: n, model: o, view: { name: 'span', styles: { 'font-family': o }, priority: 7 } };
              })(t)
            : void 0;
        }
        function uf(t) {
          return (t = t.trim()).indexOf(' ') > 0 && (t = `'${t}'`), t;
        }
        class pf extends Qt {
          static get pluginName() {
            return 'FontFamilyEditing';
          }
          constructor(t) {
            super(t),
              t.config.define(Jg, {
                options: [
                  'default',
                  'Arial, Helvetica, sans-serif',
                  'Courier New, Courier, monospace',
                  'Georgia, serif',
                  'Lucida Sans Unicode, Lucida Grande, sans-serif',
                  'Tahoma, Geneva, sans-serif',
                  'Times New Roman, Times, serif',
                  'Trebuchet MS, Helvetica, sans-serif',
                  'Verdana, Geneva, sans-serif',
                ],
                supportAllValues: !1,
              });
          }
          init() {
            const t = this.editor;
            t.model.schema.extend('$text', { allowAttributes: Jg }),
              t.model.schema.setAttributeProperties(Jg, { isFormatting: !0, copyOnEnter: !0 });
            const e = df(t.config.get('fontFamily.options')).filter(t => t.model),
              n = Xg(Jg, e);
            t.config.get('fontFamily.supportAllValues')
              ? (this._prepareAnyValueConverters(), this._prepareCompatibilityConverter())
              : t.conversion.attributeToElement(n),
              t.commands.add(Jg, new lf(t));
          }
          _prepareAnyValueConverters() {
            const t = this.editor;
            t.conversion.for('downcast').attributeToElement({
              model: Jg,
              view: (t, { writer: e }) =>
                e.createAttributeElement('span', { style: 'font-family:' + t }, { priority: 7 }),
            }),
              t.conversion.for('upcast').elementToAttribute({
                model: { key: Jg, value: t => t.getStyle('font-family') },
                view: { name: 'span', styles: { 'font-family': /.*/ } },
              });
          }
          _prepareCompatibilityConverter() {
            this.editor.conversion.for('upcast').elementToAttribute({
              view: { name: 'font', attributes: { face: /.*/ } },
              model: { key: Jg, value: t => t.getAttribute('face') },
            });
          }
        }
        class mf extends Qt {
          static get pluginName() {
            return 'FontFamilyUI';
          }
          init() {
            const t = this.editor,
              e = t.t,
              n = this._getLocalizedOptions(),
              o = t.commands.get(Jg);
            t.ui.componentFactory.add(Jg, i => {
              const r = Ih(i);
              return (
                Fh(
                  r,
                  (function (t, e) {
                    const n = new co();
                    for (const o of t) {
                      const t = {
                        type: 'button',
                        model: new Zh({ commandName: Jg, commandParam: o.model, label: o.title, withText: !0 }),
                      };
                      t.model
                        .bind('isOn')
                        .to(
                          e,
                          'value',
                          t =>
                            t === o.model ||
                            (!(!t || !o.model) &&
                              t.split(',')[0].replace(/'/g, '').toLowerCase() === o.model.toLowerCase()),
                        ),
                        o.view &&
                          o.view.styles &&
                          t.model.set('labelStyle', `font-family: ${o.view.styles['font-family']}`),
                        n.add(t);
                    }
                    return n;
                  })(n, o),
                ),
                r.buttonView.set({
                  label: e('Font Family'),
                  icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.03 3h6.149a.75.75 0 1 1 0 1.5h-5.514L11.03 3zm1.27 3h4.879a.75.75 0 1 1 0 1.5h-4.244L12.3 6zm1.27 3h3.609a.75.75 0 1 1 0 1.5h-2.973L13.57 9zm-2.754 2.5L8.038 4.785 5.261 11.5h5.555zm.62 1.5H4.641l-1.666 4.028H1.312l5.789-14h1.875l5.789 14h-1.663L11.436 13z"/></svg>',
                  tooltip: !0,
                }),
                r.extendTemplate({ attributes: { class: 'ck-font-family-dropdown' } }),
                r.bind('isEnabled').to(o),
                this.listenTo(r, 'execute', e => {
                  t.execute(e.source.commandName, { value: e.source.commandParam }), t.editing.view.focus();
                }),
                r
              );
            });
          }
          _getLocalizedOptions() {
            const t = this.editor,
              e = t.t;
            return df(t.config.get(Jg).options).map(t => ('Default' === t.title && (t.title = e('Default')), t));
          }
        }
        class gf extends Hg {
          constructor(t) {
            super(t, Ug);
          }
        }
        function ff(t) {
          return t
            .map(t =>
              (function (t) {
                if (((e = t), 'object' == typeof e && e.title && e.model && e.view)) return bf(t);
                var e;
                const n = (function (t) {
                  return kf[t] || kf[t.model];
                })(t);
                if (n) return bf(n);
                if ('default' === t) return { model: void 0, title: 'Default' };
                if (
                  (function (t) {
                    let e;
                    if ('object' == typeof t) {
                      if (!t.model) throw new c.a('font-size-invalid-definition', null, t);
                      e = parseFloat(t.model);
                    } else e = parseFloat(t);
                    return isNaN(e);
                  })(t)
                )
                  return;
                return (function (t) {
                  ('number' != typeof t && 'string' != typeof t) ||
                    (t = { title: String(t), model: `${parseFloat(t)}px` });
                  return (t.view = { name: 'span', styles: { 'font-size': t.model } }), bf(t);
                })(t);
              })(t),
            )
            .filter(t => !!t);
        }
        const kf = {
          get tiny() {
            return { title: 'Tiny', model: 'tiny', view: { name: 'span', classes: 'text-tiny', priority: 7 } };
          },
          get small() {
            return { title: 'Small', model: 'small', view: { name: 'span', classes: 'text-small', priority: 7 } };
          },
          get big() {
            return { title: 'Big', model: 'big', view: { name: 'span', classes: 'text-big', priority: 7 } };
          },
          get huge() {
            return { title: 'Huge', model: 'huge', view: { name: 'span', classes: 'text-huge', priority: 7 } };
          },
        };
        function bf(t) {
          return t.view.priority || (t.view.priority = 7), t;
        }
        const wf = ['x-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large', 'xxx-large'];
        class Af extends Qt {
          static get pluginName() {
            return 'FontSizeEditing';
          }
          constructor(t) {
            super(t),
              t.config.define(Ug, { options: ['tiny', 'small', 'default', 'big', 'huge'], supportAllValues: !1 });
          }
          init() {
            const t = this.editor;
            t.model.schema.extend('$text', { allowAttributes: Ug }),
              t.model.schema.setAttributeProperties(Ug, { isFormatting: !0, copyOnEnter: !0 });
            const e = t.config.get('fontSize.supportAllValues'),
              n = ff(this.editor.config.get('fontSize.options')).filter(t => t.model),
              o = Xg(Ug, n);
            e
              ? (this._prepareAnyValueConverters(o), this._prepareCompatibilityConverter())
              : t.conversion.attributeToElement(o),
              t.commands.add(Ug, new gf(t));
          }
          _prepareAnyValueConverters(t) {
            const e = this.editor,
              n = t.model.values.filter(t => {
                return !Yu(String(t)) && ((e = String(t)), !Qu.test(e));
                var e;
              });
            if (n.length) throw new c.a('font-size-invalid-use-of-named-presets', null, { presets: n });
            e.conversion.for('downcast').attributeToElement({
              model: Ug,
              view: (t, { writer: e }) => {
                if (t) return e.createAttributeElement('span', { style: 'font-size:' + t }, { priority: 7 });
              },
            }),
              e.conversion.for('upcast').elementToAttribute({
                model: { key: Ug, value: t => t.getStyle('font-size') },
                view: { name: 'span', styles: { 'font-size': /.*/ } },
              });
          }
          _prepareCompatibilityConverter() {
            this.editor.conversion.for('upcast').elementToAttribute({
              view: { name: 'font', attributes: { size: /^[+-]?\d{1,3}$/ } },
              model: {
                key: Ug,
                value: t => {
                  const e = t.getAttribute('size'),
                    n = '-' === e[0] || '+' === e[0];
                  let o = parseInt(e, 10);
                  n && (o = 3 + o);
                  const i = wf.length - 1,
                    r = Math.min(Math.max(o, 0), i);
                  return wf[r];
                },
              },
            });
          }
        }
        var _f = n(40),
          Cf = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(_f.a, Cf), _f.a.locals;
        class vf extends Qt {
          static get pluginName() {
            return 'FontSizeUI';
          }
          init() {
            const t = this.editor,
              e = t.t,
              n = this._getLocalizedOptions(),
              o = t.commands.get(Ug);
            t.ui.componentFactory.add(Ug, i => {
              const r = Ih(i);
              return (
                Fh(
                  r,
                  (function (t, e) {
                    const n = new co();
                    for (const o of t) {
                      const t = {
                        type: 'button',
                        model: new Zh({
                          commandName: Ug,
                          commandParam: o.model,
                          label: o.title,
                          class: 'ck-fontsize-option',
                          withText: !0,
                        }),
                      };
                      o.view && o.view.styles && t.model.set('labelStyle', `font-size:${o.view.styles['font-size']}`),
                        o.view && o.view.classes && t.model.set('class', `${t.model.class} ${o.view.classes}`),
                        t.model.bind('isOn').to(e, 'value', t => t === o.model),
                        n.add(t);
                    }
                    return n;
                  })(n, o),
                ),
                r.buttonView.set({
                  label: e('Font Size'),
                  icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z"/></svg>',
                  tooltip: !0,
                }),
                r.extendTemplate({ attributes: { class: ['ck-font-size-dropdown'] } }),
                r.bind('isEnabled').to(o),
                this.listenTo(r, 'execute', e => {
                  t.execute(e.source.commandName, { value: e.source.commandParam }), t.editing.view.focus();
                }),
                r
              );
            });
          }
          _getLocalizedOptions() {
            const t = this.editor,
              e = t.t,
              n = { Default: e('Default'), Tiny: e('Tiny'), Small: e('Small'), Big: e('Big'), Huge: e('Huge') };
            return ff(t.config.get(Ug).options).map(t => {
              const e = n[t.title];
              return e && e != t.title && (t = Object.assign({}, t, { title: e })), t;
            });
          }
        }
        class yf extends Zt {
          refresh() {
            const t = this.editor.model,
              e = Gs(t.document.selection.getSelectedBlocks());
            (this.value = !!e && e.is('element', 'paragraph')), (this.isEnabled = !!e && xf(e, t.schema));
          }
          execute(t = {}) {
            const e = this.editor.model,
              n = e.document;
            e.change(o => {
              const i = (t.selection || n.selection).getSelectedBlocks();
              for (const t of i) !t.is('element', 'paragraph') && xf(t, e.schema) && o.rename(t, 'paragraph');
            });
          }
        }
        function xf(t, e) {
          return e.checkChild(t.parent, 'paragraph') && !e.isObject(t);
        }
        class Ef extends Zt {
          execute(t) {
            const e = this.editor.model;
            let n = t.position;
            e.change(t => {
              const o = t.createElement('paragraph');
              if (!e.schema.checkChild(n.parent, o)) {
                const i = e.schema.findAllowedParent(n, o);
                if (!i) return;
                n = t.split(n, i).position;
              }
              e.insertContent(o, n), t.setSelection(o, 'in');
            });
          }
        }
        class Df extends Qt {
          static get pluginName() {
            return 'Paragraph';
          }
          init() {
            const t = this.editor,
              e = t.model;
            t.commands.add('paragraph', new yf(t)),
              t.commands.add('insertParagraph', new Ef(t)),
              e.schema.register('paragraph', { inheritAllFrom: '$block' }),
              t.conversion.elementToElement({ model: 'paragraph', view: 'p' }),
              t.conversion.for('upcast').elementToElement({
                model: (t, { writer: e }) =>
                  Df.paragraphLikeElements.has(t.name) ? (t.isEmpty ? null : e.createElement('paragraph')) : null,
                view: /.+/,
                converterPriority: 'low',
              });
          }
        }
        Df.paragraphLikeElements = new Set([
          'blockquote',
          'dd',
          'div',
          'dt',
          'h1',
          'h2',
          'h3',
          'h4',
          'h5',
          'h6',
          'li',
          'p',
          'td',
          'th',
        ]);
        var Sf = n(41),
          Bf = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Sf.a, Bf), Sf.a.locals;
        class Tf {
          constructor(t) {
            this.set('activeHandlePosition', null),
              this.set('proposedWidthPercents', null),
              this.set('proposedWidth', null),
              this.set('proposedHeight', null),
              this.set('proposedHandleHostWidth', null),
              this.set('proposedHandleHostHeight', null),
              (this._options = t),
              (this._referenceCoordinates = null);
          }
          begin(t, e, n) {
            const o = new Vs(e);
            (this.activeHandlePosition = (function (t) {
              const e = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];
              for (const n of e) if (t.classList.contains(Pf(n))) return n;
            })(t)),
              (this._referenceCoordinates = (function (t, e) {
                const n = new Vs(t),
                  o = e.split('-'),
                  i = { x: 'right' == o[1] ? n.right : n.left, y: 'bottom' == o[0] ? n.bottom : n.top };
                return (i.x += t.ownerDocument.defaultView.scrollX), (i.y += t.ownerDocument.defaultView.scrollY), i;
              })(
                e,
                (function (t) {
                  const e = t.split('-'),
                    n = { top: 'bottom', bottom: 'top', left: 'right', right: 'left' };
                  return `${n[e[0]]}-${n[e[1]]}`;
                })(this.activeHandlePosition),
              )),
              (this.originalWidth = o.width),
              (this.originalHeight = o.height),
              (this.aspectRatio = o.width / o.height);
            const i = n.style.width;
            i && i.match(/^\d+(\.\d*)?%$/)
              ? (this.originalWidthPercents = parseFloat(i))
              : (this.originalWidthPercents = (function (t, e) {
                  const n = t.parentElement,
                    o = parseFloat(n.ownerDocument.defaultView.getComputedStyle(n).width);
                  return (e.width / o) * 100;
                })(n, o));
          }
          update(t) {
            (this.proposedWidth = t.width),
              (this.proposedHeight = t.height),
              (this.proposedWidthPercents = t.widthPercents),
              (this.proposedHandleHostWidth = t.handleHostWidth),
              (this.proposedHandleHostHeight = t.handleHostHeight);
          }
        }
        function Pf(t) {
          return `ck-widget__resizer__handle-${t}`;
        }
        Yt(Tf, jt);
        class If {
          constructor(t) {
            (this._options = t),
              (this._domResizerWrapper = null),
              (this._viewResizerWrapper = null),
              this.set('isEnabled', !0),
              this.decorate('begin'),
              this.decorate('cancel'),
              this.decorate('commit'),
              this.decorate('updateSize'),
              this.on(
                'commit',
                t => {
                  this.state.proposedWidth || this.state.proposedWidthPercents || (this._cleanup(), t.stop());
                },
                { priority: 'high' },
              ),
              this.on('change:isEnabled', () => {
                this.isEnabled && this.redraw();
              });
          }
          attach() {
            const t = this,
              e = this._options.viewElement;
            this._options.editor.editing.view.change(n => {
              const o = n.createUIElement('div', { class: 'ck ck-reset_all ck-widget__resizer' }, function (e) {
                const n = this.toDomElement(e);
                return (
                  t._appendHandles(n),
                  t._appendSizeUI(n),
                  (t._domResizerWrapper = n),
                  t.on('change:isEnabled', (t, e, o) => {
                    n.style.display = o ? '' : 'none';
                  }),
                  (n.style.display = t.isEnabled ? '' : 'none'),
                  n
                );
              });
              n.insert(n.createPositionAt(e, 'end'), o),
                n.addClass('ck-widget_with-resizer', e),
                (this._viewResizerWrapper = o);
            });
          }
          begin(t) {
            (this.state = new Tf(this._options)),
              this._sizeUI.bindToState(this._options, this.state),
              (this._initialViewWidth = this._options.viewElement.getStyle('width')),
              this.state.begin(t, this._getHandleHost(), this._getResizeHost());
          }
          updateSize(t) {
            const e = this._proposeNewSize(t);
            this._options.editor.editing.view.change(t => {
              const n = this._options.unit || '%',
                o = ('%' === n ? e.widthPercents : e.width) + n;
              t.setStyle('width', o, this._options.viewElement);
            });
            const n = this._getHandleHost(),
              o = new Vs(n);
            (e.handleHostWidth = Math.round(o.width)), (e.handleHostHeight = Math.round(o.height));
            const i = new Vs(n);
            (e.width = Math.round(i.width)), (e.height = Math.round(i.height)), this.redraw(o), this.state.update(e);
          }
          commit() {
            const t = this._options.unit || '%',
              e = ('%' === t ? this.state.proposedWidthPercents : this.state.proposedWidth) + t;
            this._options.editor.editing.view.change(() => {
              this._cleanup(), this._options.onCommit(e);
            });
          }
          cancel() {
            this._cleanup();
          }
          destroy() {
            this.cancel();
          }
          redraw(t) {
            const e = this._domResizerWrapper;
            if (!((n = e) && n.ownerDocument && n.ownerDocument.contains(n))) return;
            var n;
            const o = e.parentElement,
              i = this._getHandleHost(),
              r = this._viewResizerWrapper,
              s = [r.getStyle('width'), r.getStyle('height'), r.getStyle('left'), r.getStyle('top')];
            let a;
            if (o.isSameNode(i)) {
              const e = t || new Vs(i);
              a = [e.width + 'px', e.height + 'px', void 0, void 0];
            } else a = [i.offsetWidth + 'px', i.offsetHeight + 'px', i.offsetLeft + 'px', i.offsetTop + 'px'];
            'same' !== bo(s, a) &&
              this._options.editor.editing.view.change(t => {
                t.setStyle({ width: a[0], height: a[1], left: a[2], top: a[3] }, r);
              });
          }
          containsHandle(t) {
            return this._domResizerWrapper.contains(t);
          }
          static isResizeHandle(t) {
            return t.classList.contains('ck-widget__resizer__handle');
          }
          _cleanup() {
            this._sizeUI.dismiss(), (this._sizeUI.isVisible = !1);
            this._options.editor.editing.view.change(t => {
              t.setStyle('width', this._initialViewWidth, this._options.viewElement);
            });
          }
          _proposeNewSize(t) {
            const e = this.state,
              n = { x: (o = t).pageX, y: o.pageY };
            var o;
            const i = !this._options.isCentered || this._options.isCentered(this),
              r = {
                x: e._referenceCoordinates.x - (n.x + e.originalWidth),
                y: n.y - e.originalHeight - e._referenceCoordinates.y,
              };
            i &&
              e.activeHandlePosition.endsWith('-right') &&
              (r.x = n.x - (e._referenceCoordinates.x + e.originalWidth)),
              i && (r.x *= 2);
            const s = { width: Math.abs(e.originalWidth + r.x), height: Math.abs(e.originalHeight + r.y) };
            (s.dominant = s.width / e.aspectRatio > s.height ? 'width' : 'height'), (s.max = s[s.dominant]);
            const a = { width: s.width, height: s.height };
            return (
              'width' == s.dominant ? (a.height = a.width / e.aspectRatio) : (a.width = a.height * e.aspectRatio),
              {
                width: Math.round(a.width),
                height: Math.round(a.height),
                widthPercents: Math.min(
                  Math.round((e.originalWidthPercents / e.originalWidth) * a.width * 100) / 100,
                  100,
                ),
              }
            );
          }
          _getResizeHost() {
            const t = this._domResizerWrapper.parentElement;
            return this._options.getResizeHost(t);
          }
          _getHandleHost() {
            const t = this._domResizerWrapper.parentElement;
            return this._options.getHandleHost(t);
          }
          _appendHandles(t) {
            const e = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];
            for (const o of e)
              t.appendChild(
                new gd({
                  tag: 'div',
                  attributes: { class: 'ck-widget__resizer__handle ' + ((n = o), `ck-widget__resizer__handle-${n}`) },
                }).render(),
              );
            var n;
          }
          _appendSizeUI(t) {
            const e = new zf();
            e.render(), (this._sizeUI = e), t.appendChild(e.element);
          }
        }
        Yt(If, jt);
        class zf extends md {
          constructor() {
            super();
            const t = this.bindTemplate;
            this.setTemplate({
              tag: 'div',
              attributes: {
                class: ['ck', 'ck-size-view', t.to('activeHandlePosition', t => (t ? `ck-orientation-${t}` : ''))],
                style: { display: t.if('isVisible', 'none', t => !t) },
              },
              children: [{ text: t.to('label') }],
            });
          }
          bindToState(t, e) {
            this.bind('isVisible').to(e, 'proposedWidth', e, 'proposedHeight', (t, e) => null !== t && null !== e),
              this.bind('label').to(
                e,
                'proposedHandleHostWidth',
                e,
                'proposedHandleHostHeight',
                e,
                'proposedWidthPercents',
                (e, n, o) => ('px' === t.unit ? `${e}×${n}` : `${o}%`),
              ),
              this.bind('activeHandlePosition').to(e);
          }
          dismiss() {
            this.unbind(), (this.isVisible = !1);
          }
        }
        var Ff = n(42),
          Rf = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Ff.a, Rf), Ff.a.locals;
        class Of extends Qt {
          static get pluginName() {
            return 'WidgetResize';
          }
          init() {
            this.set('visibleResizer', null), this.set('_activeResizer', null), (this._resizers = new Map());
            const t = Tr.window.document;
            this.editor.model.schema.setAttributeProperties('width', { isFormatting: !0 }),
              this.editor.editing.view.addObserver(Lu),
              (this._observer = Object.create(Kr)),
              this.listenTo(this.editor.editing.view.document, 'mousedown', this._mouseDownListener.bind(this), {
                priority: 'high',
              }),
              this._observer.listenTo(t, 'mousemove', this._mouseMoveListener.bind(this)),
              this._observer.listenTo(t, 'mouseup', this._mouseUpListener.bind(this));
            const e = () => {
              this.visibleResizer && this.visibleResizer.redraw();
            };
            (this._redrawFocusedResizerThrottled = kg(e, 200)),
              this.on('change:visibleResizer', e),
              this.editor.ui.on('update', this._redrawFocusedResizerThrottled),
              this._observer.listenTo(Tr.window, 'resize', this._redrawFocusedResizerThrottled);
            const n = this.editor.editing.view.document.selection;
            n.on('change', () => {
              const t = n.getSelectedElement();
              this.visibleResizer = this.getResizerByViewElement(t) || null;
            });
          }
          destroy() {
            this._observer.stopListening();
            for (const t of this._resizers.values()) t.destroy();
            this._redrawFocusedResizerThrottled.cancel();
          }
          attachTo(t) {
            const e = new If(t),
              n = this.editor.plugins;
            if ((e.attach(), n.has('WidgetToolbarRepository'))) {
              const t = n.get('WidgetToolbarRepository');
              e.on(
                'begin',
                () => {
                  t.forceDisabled('resize');
                },
                { priority: 'lowest' },
              ),
                e.on(
                  'cancel',
                  () => {
                    t.clearForceDisabled('resize');
                  },
                  { priority: 'highest' },
                ),
                e.on(
                  'commit',
                  () => {
                    t.clearForceDisabled('resize');
                  },
                  { priority: 'highest' },
                );
            }
            this._resizers.set(t.viewElement, e);
            const o = this.editor.editing.view.document.selection.getSelectedElement();
            return this.getResizerByViewElement(o) == e && (this.visibleResizer = e), e;
          }
          getResizerByViewElement(t) {
            return this._resizers.get(t);
          }
          _getResizerByHandle(t) {
            for (const e of this._resizers.values()) if (e.containsHandle(t)) return e;
          }
          _mouseDownListener(t, e) {
            const n = e.domTarget;
            If.isResizeHandle(n) &&
              ((this._activeResizer = this._getResizerByHandle(n)),
              this._activeResizer && (this._activeResizer.begin(n), t.stop(), e.preventDefault()));
          }
          _mouseMoveListener(t, e) {
            this._activeResizer && this._activeResizer.updateSize(e);
          }
          _mouseUpListener() {
            this._activeResizer && (this._activeResizer.commit(), (this._activeResizer = null));
          }
        }
        Yt(Of, jt);
        class Mf extends jr {
          observe(t) {
            this.listenTo(
              t,
              'load',
              (t, e) => {
                const n = e.target;
                this.checkShouldIgnoreEventFromTarget(n) || ('IMG' == n.tagName && this._fireEvents(e));
              },
              { useCapture: !0 },
            );
          }
          _fireEvents(t) {
            this.isEnabled && (this.document.fire('layoutChanged'), this.document.fire('imageLoaded', t));
          }
        }
        function Nf(t) {
          return !!t.getCustomProperty('image') && $m(t);
        }
        function Vf(t) {
          const e = t.getSelectedElement();
          return e && Nf(e) ? e : null;
        }
        function Lf(t) {
          return !!t && t.is('element', 'image');
        }
        function Kf(t, e = {}, n = null) {
          t.change(o => {
            const i = o.createElement('image', e),
              r = n || Xm(t.document.selection, t);
            t.insertContent(i, r), i.parent && o.setSelection(i, 'on');
          });
        }
        function qf(t) {
          const e = t.schema,
            n = t.document.selection;
          return (
            (function (t, e, n) {
              const o = (function (t, e) {
                const n = Xm(t, e).parent;
                if (n.isEmpty && !n.is('element', '$root')) return n.parent;
                return n;
              })(t, n);
              return e.checkChild(o, 'image');
            })(n, e, t) &&
            !Zm(n, e) &&
            (function (t) {
              return [...t.focus.getAncestors()].every(t => !t.is('element', 'image'));
            })(n)
          );
        }
        function Hf(t) {
          const e = [];
          for (const n of t.getChildren()) e.push(n), n.is('element') && e.push(...n.getChildren());
          return e.find(t => t.is('element', 'img'));
        }
        function jf(t) {
          return n => {
            n.on(`attribute:${t}:image`, e);
          };
          function e(t, e, n) {
            if (!n.consumable.consume(e.item, t.name)) return;
            const o = n.writer,
              i = Hf(n.mapper.toViewElement(e.item));
            o.setAttribute(e.attributeKey, e.attributeNewValue || '', i);
          }
        }
        class $f extends Zt {
          refresh() {
            this.isEnabled = qf(this.editor.model);
          }
          execute(t) {
            const e = this.editor.model;
            for (const n of ho(t.source)) Kf(e, { src: n });
          }
        }
        class Gf extends Qt {
          static get pluginName() {
            return 'ImageEditing';
          }
          init() {
            const t = this.editor,
              e = t.model.schema,
              n = t.t,
              o = t.conversion;
            t.editing.view.addObserver(Mf),
              e.register('image', {
                isObject: !0,
                isBlock: !0,
                allowWhere: '$block',
                allowAttributes: ['alt', 'src', 'srcset'],
              }),
              o.for('dataDowncast').elementToElement({ model: 'image', view: (t, { writer: e }) => Wf(e) }),
              o.for('editingDowncast').elementToElement({
                model: 'image',
                view: (t, { writer: e }) =>
                  (function (t, e, n) {
                    return (
                      e.setCustomProperty('image', !0, t),
                      Gm(t, e, {
                        label: function () {
                          const e = Hf(t).getAttribute('alt');
                          return e ? `${e} ${n}` : n;
                        },
                      })
                    );
                  })(Wf(e), e, n('image widget')),
              }),
              o
                .for('downcast')
                .add(jf('src'))
                .add(jf('alt'))
                .add(
                  (function () {
                    return e => {
                      e.on('attribute:srcset:image', t);
                    };
                    function t(t, e, n) {
                      if (!n.consumable.consume(e.item, t.name)) return;
                      const o = n.writer,
                        i = Hf(n.mapper.toViewElement(e.item));
                      if (null === e.attributeNewValue) {
                        const t = e.attributeOldValue;
                        t.data &&
                          (o.removeAttribute('srcset', i),
                          o.removeAttribute('sizes', i),
                          t.width && o.removeAttribute('width', i));
                      } else {
                        const t = e.attributeNewValue;
                        t.data &&
                          (o.setAttribute('srcset', t.data, i),
                          o.setAttribute('sizes', '100vw', i),
                          t.width && o.setAttribute('width', t.width, i));
                      }
                    }
                  })(),
                ),
              o
                .for('upcast')
                .elementToElement({
                  view: { name: 'img', attributes: { src: !0 } },
                  model: (t, { writer: e }) => e.createElement('image', { src: t.getAttribute('src') }),
                })
                .attributeToAttribute({ view: { name: 'img', key: 'alt' }, model: 'alt' })
                .attributeToAttribute({
                  view: { name: 'img', key: 'srcset' },
                  model: {
                    key: 'srcset',
                    value: t => {
                      const e = { data: t.getAttribute('srcset') };
                      return t.hasAttribute('width') && (e.width = t.getAttribute('width')), e;
                    },
                  },
                })
                .add(
                  (function () {
                    return e => {
                      e.on('element:figure', t);
                    };
                    function t(t, e, n) {
                      if (!n.consumable.test(e.viewItem, { name: !0, classes: 'image' })) return;
                      const o = Hf(e.viewItem);
                      if (!o || !o.hasAttribute('src') || !n.consumable.test(o, { name: !0 })) return;
                      const i = Gs(n.convertItem(o, e.modelCursor).modelRange.getItems());
                      i && (n.convertChildren(e.viewItem, i), n.updateConversionResult(i, e));
                    }
                  })(),
                );
            const i = new $f(t);
            t.commands.add('insertImage', i), t.commands.add('imageInsert', i);
          }
        }
        function Wf(t) {
          const e = t.createEmptyElement('img'),
            n = t.createContainerElement('figure', { class: 'image' });
          return t.insert(t.createPositionAt(n, 0), e), n;
        }
        class Uf extends Zt {
          refresh() {
            const t = this.editor.model.document.selection.getSelectedElement();
            (this.isEnabled = Lf(t)),
              Lf(t) && t.hasAttribute('alt') ? (this.value = t.getAttribute('alt')) : (this.value = !1);
          }
          execute(t) {
            const e = this.editor.model,
              n = e.document.selection.getSelectedElement();
            e.change(e => {
              e.setAttribute('alt', t.newValue, n);
            });
          }
        }
        class Jf extends Qt {
          static get pluginName() {
            return 'ImageTextAlternativeEditing';
          }
          init() {
            this.editor.commands.add('imageTextAlternative', new Uf(this.editor));
          }
        }
        var Yf = n(43),
          Qf = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 },
          Xf = (hd()(Yf.a, Qf), Yf.a.locals, n(44)),
          Zf = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Xf.a, Zf), Xf.a.locals;
        class tk extends md {
          constructor(t) {
            super(t);
            const e = this.locale.t;
            (this.focusTracker = new Ws()),
              (this.keystrokes = new Us()),
              (this.labeledInput = this._createLabeledInputView()),
              (this.saveButtonView = this._createButton(e('Save'), $l, 'ck-button-save')),
              (this.saveButtonView.type = 'submit'),
              (this.cancelButtonView = this._createButton(e('Cancel'), jl, 'ck-button-cancel', 'cancel')),
              (this._focusables = new ld()),
              (this._focusCycler = new Yd({
                focusables: this._focusables,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
              })),
              this.setTemplate({
                tag: 'form',
                attributes: { class: ['ck', 'ck-text-alternative-form', 'ck-responsive-form'], tabindex: '-1' },
                children: [this.labeledInput, this.saveButtonView, this.cancelButtonView],
              }),
              ad(this);
          }
          render() {
            super.render(),
              this.keystrokes.listenTo(this.element),
              cd({ view: this }),
              [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach(t => {
                this._focusables.add(t), this.focusTracker.add(t.element);
              });
          }
          _createButton(t, e, n, o) {
            const i = new jd(this.locale);
            return (
              i.set({ label: t, icon: e, tooltip: !0 }),
              i.extendTemplate({ attributes: { class: n } }),
              o && i.delegate('execute').to(this, o),
              i
            );
          }
          _createLabeledInputView() {
            const t = this.locale.t,
              e = new Yh(this.locale, Qh);
            return (e.label = t('Text alternative')), e;
          }
        }
        function ek(t) {
          const e = t.editing.view,
            n = iu.defaultPositions;
          return {
            target: e.domConverter.viewToDom(e.document.selection.getSelectedElement()),
            positions: [
              n.northArrowSouth,
              n.northArrowSouthWest,
              n.northArrowSouthEast,
              n.southArrowNorth,
              n.southArrowNorthWest,
              n.southArrowNorthEast,
            ],
          };
        }
        class nk extends Qt {
          static get requires() {
            return [pu];
          }
          static get pluginName() {
            return 'ImageTextAlternativeUI';
          }
          init() {
            this._createButton(), this._createForm();
          }
          destroy() {
            super.destroy(), this._form.destroy();
          }
          _createButton() {
            const t = this.editor,
              e = t.t;
            t.ui.componentFactory.add('imageTextAlternative', n => {
              const o = t.commands.get('imageTextAlternative'),
                i = new jd(n);
              return (
                i.set({ label: e('Change image text alternative'), icon: Wl, tooltip: !0 }),
                i.bind('isEnabled').to(o, 'isEnabled'),
                this.listenTo(i, 'execute', () => {
                  this._showForm();
                }),
                i
              );
            });
          }
          _createForm() {
            const t = this.editor,
              e = t.editing.view.document;
            (this._balloon = this.editor.plugins.get('ContextualBalloon')),
              (this._form = new tk(t.locale)),
              this._form.render(),
              this.listenTo(this._form, 'submit', () => {
                t.execute('imageTextAlternative', { newValue: this._form.labeledInput.fieldView.element.value }),
                  this._hideForm(!0);
              }),
              this.listenTo(this._form, 'cancel', () => {
                this._hideForm(!0);
              }),
              this._form.keystrokes.set('Esc', (t, e) => {
                this._hideForm(!0), e();
              }),
              this.listenTo(t.ui, 'update', () => {
                Vf(e.selection)
                  ? this._isVisible &&
                    (function (t) {
                      const e = t.plugins.get('ContextualBalloon');
                      if (Vf(t.editing.view.document.selection)) {
                        const n = ek(t);
                        e.updatePosition(n);
                      }
                    })(t)
                  : this._hideForm(!0);
              }),
              sd({
                emitter: this._form,
                activator: () => this._isVisible,
                contextElements: [this._balloon.view.element],
                callback: () => this._hideForm(),
              });
          }
          _showForm() {
            if (this._isVisible) return;
            const t = this.editor,
              e = t.commands.get('imageTextAlternative'),
              n = this._form.labeledInput;
            this._form.disableCssTransitions(),
              this._isInBalloon || this._balloon.add({ view: this._form, position: ek(t) }),
              (n.fieldView.value = n.fieldView.element.value = e.value || ''),
              this._form.labeledInput.fieldView.select(),
              this._form.enableCssTransitions();
          }
          _hideForm(t) {
            this._isInBalloon &&
              (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(),
              this._balloon.remove(this._form),
              t && this.editor.editing.view.focus());
          }
          get _isVisible() {
            return this._balloon.visibleView === this._form;
          }
          get _isInBalloon() {
            return this._balloon.hasView(this._form);
          }
        }
        class ok extends Qt {
          static get requires() {
            return [Jf, nk];
          }
          static get pluginName() {
            return 'ImageTextAlternative';
          }
        }
        var ik = n(45),
          rk = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(ik.a, rk), ik.a.locals;
        function sk(t) {
          for (const e of t.getChildren()) if (e && e.is('element', 'caption')) return e;
          return null;
        }
        function ak(t) {
          const e = t.parent;
          return 'figcaption' == t.name && e && 'figure' == e.name && e.hasClass('image') ? { name: !0 } : null;
        }
        class ck extends Qt {
          static get pluginName() {
            return 'ImageCaptionEditing';
          }
          init() {
            const t = this.editor,
              e = t.editing.view,
              n = t.model.schema,
              o = t.data,
              i = t.editing,
              r = t.t;
            n.isRegistered('caption')
              ? n.extend('caption', { allowIn: 'image' })
              : n.register('caption', { allowIn: 'image', allowContentOf: '$block', isLimit: !0 }),
              t.model.document.registerPostFixer(t => this._insertMissingModelCaptionElement(t)),
              t.conversion.for('upcast').elementToElement({ view: ak, model: 'caption' });
            o.downcastDispatcher.on(
              'insert:caption',
              lk(t => t.createContainerElement('figcaption'), !1),
            );
            const s = (function (t, e) {
              return n => {
                const o = n.createEditableElement('figcaption');
                return n.setCustomProperty('imageCaption', !0, o), vu({ view: t, element: o, text: e }), Qm(o, n);
              };
            })(e, r('Enter image caption'));
            i.downcastDispatcher.on('insert:caption', lk(s)),
              i.downcastDispatcher.on(
                'insert',
                this._fixCaptionVisibility(t => t.item),
                { priority: 'high' },
              ),
              i.downcastDispatcher.on(
                'remove',
                this._fixCaptionVisibility(t => t.position.parent),
                { priority: 'high' },
              ),
              e.document.registerPostFixer(t => this._updateCaptionVisibility(t));
          }
          _updateCaptionVisibility(t) {
            const e = this.editor.editing.mapper,
              n = this._lastSelectedCaption;
            let o;
            const i = this.editor.model.document.selection,
              r = i.getSelectedElement();
            if (r && r.is('element', 'image')) {
              const t = sk(r);
              o = e.toViewElement(t);
            }
            const s = dk(i.getFirstPosition().parent);
            if ((s && (o = e.toViewElement(s)), o && !this.editor.isReadOnly))
              return n
                ? (n === o || (hk(n, t), (this._lastSelectedCaption = o)), uk(o, t))
                : ((this._lastSelectedCaption = o), uk(o, t));
            if (n) {
              const e = hk(n, t);
              return (this._lastSelectedCaption = null), e;
            }
            return !1;
          }
          _fixCaptionVisibility(t) {
            return (e, n, o) => {
              const i = dk(t(n)),
                r = this.editor.editing.mapper,
                s = o.writer;
              if (i) {
                const t = r.toViewElement(i);
                t && (i.childCount ? s.removeClass('ck-hidden', t) : s.addClass('ck-hidden', t));
              }
            };
          }
          _insertMissingModelCaptionElement(t) {
            const e = this.editor.model,
              n = e.document.differ.getChanges(),
              o = [];
            for (const t of n)
              if ('insert' == t.type && '$text' != t.name) {
                const n = t.position.nodeAfter;
                if ((n.is('element', 'image') && !sk(n) && o.push(n), !n.is('element', 'image') && n.childCount))
                  for (const t of e.createRangeIn(n).getItems()) t.is('element', 'image') && !sk(t) && o.push(t);
              }
            for (const e of o) t.appendElement('caption', e);
            return !!o.length;
          }
        }
        function lk(t, e = !0) {
          return (n, o, i) => {
            const r = o.item;
            if ((r.childCount || e) && Lf(r.parent)) {
              if (!i.consumable.consume(o.item, 'insert')) return;
              const e = i.mapper.toViewElement(o.range.start.parent),
                n = t(i.writer),
                s = i.writer;
              r.childCount || s.addClass('ck-hidden', n),
                (function (t, e, n, o) {
                  const i = o.writer.createPositionAt(n, 'end');
                  o.writer.insert(i, t), o.mapper.bindElements(e, t);
                })(n, o.item, e, i);
            }
          };
        }
        function dk(t) {
          const e = t.getAncestors({ includeSelf: !0 }).find(t => 'caption' == t.name);
          return e && e.parent && 'image' == e.parent.name ? e : null;
        }
        function hk(t, e) {
          return !t.childCount && !t.hasClass('ck-hidden') && (e.addClass('ck-hidden', t), !0);
        }
        function uk(t, e) {
          return !!t.hasClass('ck-hidden') && (e.removeClass('ck-hidden', t), !0);
        }
        var pk = n(46),
          mk = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(pk.a, mk), pk.a.locals;
        class gk extends Zt {
          refresh() {
            const t = this.editor.model.document.selection.getSelectedElement();
            (this.isEnabled = Lf(t)),
              t && t.hasAttribute('width')
                ? (this.value = { width: t.getAttribute('width'), height: null })
                : (this.value = null);
          }
          execute(t) {
            const e = this.editor.model,
              n = e.document.selection.getSelectedElement();
            (this.value = { width: t.width, height: null }),
              n &&
                e.change(e => {
                  e.setAttribute('width', t.width, n);
                });
          }
        }
        class fk extends Qt {
          static get pluginName() {
            return 'ImageResizeEditing';
          }
          constructor(t) {
            super(t),
              t.config.define('image', {
                resizeUnit: '%',
                resizeOptions: [
                  { name: 'resizeImage:original', value: null, icon: 'original' },
                  { name: 'resizeImage:25', value: '25', icon: 'small' },
                  { name: 'resizeImage:50', value: '50', icon: 'medium' },
                  { name: 'resizeImage:75', value: '75', icon: 'large' },
                ],
              });
          }
          init() {
            const t = this.editor,
              e = new gk(t);
            this._registerSchema(),
              this._registerConverters(),
              t.commands.add('resizeImage', e),
              t.commands.add('imageResize', e);
          }
          _registerSchema() {
            this.editor.model.schema.extend('image', { allowAttributes: 'width' }),
              this.editor.model.schema.setAttributeProperties('width', { isFormatting: !0 });
          }
          _registerConverters() {
            const t = this.editor;
            t.conversion.for('downcast').add(t =>
              t.on('attribute:width:image', (t, e, n) => {
                if (!n.consumable.consume(e.item, t.name)) return;
                const o = n.writer,
                  i = n.mapper.toViewElement(e.item);
                null !== e.attributeNewValue
                  ? (o.setStyle('width', e.attributeNewValue, i), o.addClass('image_resized', i))
                  : (o.removeStyle('width', i), o.removeClass('image_resized', i));
              }),
            ),
              t.conversion.for('upcast').attributeToAttribute({
                view: { name: 'figure', styles: { width: /.+/ } },
                model: { key: 'width', value: t => t.getStyle('width') },
              });
          }
        }
        const kk = { small: ed, medium: nd, large: td, original: Zl };
        class bk extends Qt {
          static get requires() {
            return [fk];
          }
          static get pluginName() {
            return 'ImageResizeButtons';
          }
          constructor(t) {
            super(t), (this._resizeUnit = t.config.get('image.resizeUnit'));
          }
          init() {
            const t = this.editor,
              e = t.config.get('image.resizeOptions'),
              n = t.commands.get('resizeImage');
            this.bind('isEnabled').to(n);
            for (const t of e) this._registerImageResizeButton(t);
            this._registerImageResizeDropdown(e);
          }
          _registerImageResizeButton(t) {
            const e = this.editor,
              { name: n, value: o, icon: i } = t,
              r = o ? o + this._resizeUnit : null;
            e.ui.componentFactory.add(n, n => {
              const o = new jd(n),
                s = e.commands.get('resizeImage'),
                a = this._getOptionLabelValue(t, !0);
              if (!kk[i]) throw new c.a('imageresizebuttons-missing-icon', e, t);
              return (
                o.set({ label: a, icon: kk[i], tooltip: a, isToggleable: !0 }),
                o.bind('isEnabled').to(this),
                o.bind('isOn').to(s, 'value', wk(r)),
                this.listenTo(o, 'execute', () => {
                  e.execute('resizeImage', { width: r });
                }),
                o
              );
            });
          }
          _registerImageResizeDropdown(t) {
            const e = this.editor,
              n = e.t,
              o = t.find(t => !t.value),
              i = i => {
                const r = e.commands.get('resizeImage'),
                  s = Ih(i, nh),
                  a = s.buttonView;
                return (
                  a.set({
                    tooltip: n('Resize image'),
                    commandValue: o.value,
                    icon: kk.medium,
                    isToggleable: !0,
                    label: this._getOptionLabelValue(o),
                    withText: !0,
                    class: 'ck-resize-image-button',
                  }),
                  a.bind('label').to(r, 'value', t => (t && t.width ? t.width : this._getOptionLabelValue(o))),
                  s.bind('isOn').to(r),
                  s.bind('isEnabled').to(this),
                  Fh(s, this._getResizeDropdownListItemDefinitions(t, r)),
                  (s.listView.ariaLabel = n('Image resize list')),
                  this.listenTo(s, 'execute', t => {
                    e.execute(t.source.commandName, { width: t.source.commandValue }), e.editing.view.focus();
                  }),
                  s
                );
              };
            e.ui.componentFactory.add('resizeImage', i), e.ui.componentFactory.add('imageResize', i);
          }
          _getOptionLabelValue(t, e) {
            const n = this.editor.t;
            return t.label
              ? t.label
              : e
              ? t.value
                ? n('Resize image to %0', t.value + this._resizeUnit)
                : n('Resize image to the original size')
              : t.value
              ? t.value + this._resizeUnit
              : n('Original');
          }
          _getResizeDropdownListItemDefinitions(t, e) {
            const n = new co();
            return (
              t.map(t => {
                const o = t.value ? t.value + this._resizeUnit : null,
                  i = {
                    type: 'button',
                    model: new Zh({
                      commandName: 'resizeImage',
                      commandValue: o,
                      label: this._getOptionLabelValue(t),
                      withText: !0,
                      icon: null,
                    }),
                  };
                i.model.bind('isOn').to(e, 'value', wk(o)), n.add(i);
              }),
              n
            );
          }
        }
        function wk(t) {
          return e => (null === t && e === t) || (e && e.width === t);
        }
        class Ak extends Qt {
          static get requires() {
            return [Of];
          }
          static get pluginName() {
            return 'ImageResizeHandles';
          }
          init() {
            const t = this.editor.commands.get('resizeImage');
            this.bind('isEnabled').to(t), this._setupResizerCreator();
          }
          _setupResizerCreator() {
            const t = this.editor,
              e = t.editing.view;
            e.addObserver(Mf),
              this.listenTo(e.document, 'imageLoaded', (n, o) => {
                if (!o.target.matches('figure.image.ck-widget > img, figure.image.ck-widget > a > img')) return;
                const i = t.editing.view.domConverter.domToView(o.target).findAncestor('figure');
                let r = this.editor.plugins.get(Of).getResizerByViewElement(i);
                if (r) return void r.redraw();
                const s = t.editing.mapper.toModelElement(i);
                (r = t.plugins.get(Of).attachTo({
                  unit: t.config.get('image.resizeUnit'),
                  modelElement: s,
                  viewElement: i,
                  editor: t,
                  getHandleHost: t => t.querySelector('img'),
                  getResizeHost: t => t,
                  isCentered() {
                    const t = s.getAttribute('imageStyle');
                    return !t || 'full' == t || 'alignCenter' == t;
                  },
                  onCommit(e) {
                    t.execute('resizeImage', { width: e });
                  },
                })),
                  r.on('updateSize', () => {
                    i.hasClass('image_resized') ||
                      e.change(t => {
                        t.addClass('image_resized', i);
                      });
                  }),
                  r.bind('isEnabled').to(this);
              });
          }
        }
        var _k = n(47),
          Ck = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(_k.a, Ck), _k.a.locals;
        var vk = n(48),
          yk = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(vk.a, yk), vk.a.locals;
        class xk extends md {
          constructor(t) {
            super(t),
              (this.buttonView = new jd(t)),
              (this._fileInputView = new Ek(t)),
              this._fileInputView.bind('acceptedType').to(this),
              this._fileInputView.bind('allowMultipleFiles').to(this),
              this._fileInputView.delegate('done').to(this),
              this.setTemplate({
                tag: 'span',
                attributes: { class: 'ck-file-dialog-button' },
                children: [this.buttonView, this._fileInputView],
              }),
              this.buttonView.on('execute', () => {
                this._fileInputView.open();
              });
          }
          focus() {
            this.buttonView.focus();
          }
        }
        class Ek extends md {
          constructor(t) {
            super(t), this.set('acceptedType'), this.set('allowMultipleFiles', !1);
            const e = this.bindTemplate;
            this.setTemplate({
              tag: 'input',
              attributes: {
                class: ['ck-hidden'],
                type: 'file',
                tabindex: '-1',
                accept: e.to('acceptedType'),
                multiple: e.to('allowMultipleFiles'),
              },
              on: {
                change: e.to(() => {
                  this.element &&
                    this.element.files &&
                    this.element.files.length &&
                    this.fire('done', this.element.files),
                    (this.element.value = '');
                }),
              },
            });
          }
          open() {
            this.element.click();
          }
        }
        function Dk(t) {
          const e = t.map(t => t.replace('+', '\\+'));
          return new RegExp(`^image\\/(${e.join('|')})$`);
        }
        function Sk(t) {
          return new Promise((e, n) => {
            const o = t.getAttribute('src');
            fetch(o)
              .then(t => t.blob())
              .then(t => {
                const n = Bk(t, o),
                  i = n.replace('image/', ''),
                  r = new File([t], `image.${i}`, { type: n });
                e(r);
              })
              .catch(t =>
                t && 'TypeError' === t.name
                  ? (function (t) {
                      return (function (t) {
                        return new Promise((e, n) => {
                          const o = Tr.document.createElement('img');
                          o.addEventListener('load', () => {
                            const t = Tr.document.createElement('canvas');
                            (t.width = o.width), (t.height = o.height);
                            t.getContext('2d').drawImage(o, 0, 0), t.toBlob(t => (t ? e(t) : n()));
                          }),
                            o.addEventListener('error', () => n()),
                            (o.src = t);
                        });
                      })(t).then(e => {
                        const n = Bk(e, t),
                          o = n.replace('image/', '');
                        return new File([e], `image.${o}`, { type: n });
                      });
                    })(o)
                      .then(e)
                      .catch(n)
                  : n(t),
              );
          });
        }
        function Bk(t, e) {
          return t.type
            ? t.type
            : e.match(/data:(image\/\w+);base64/)
            ? e.match(/data:(image\/\w+);base64/)[1].toLowerCase()
            : 'image/jpeg';
        }
        class Tk extends Qt {
          static get pluginName() {
            return 'ImageUploadUI';
          }
          init() {
            const t = this.editor,
              e = t.t,
              n = n => {
                const o = new xk(n),
                  i = t.commands.get('uploadImage'),
                  r = t.config.get('image.upload.types'),
                  s = Dk(r);
                return (
                  o.set({ acceptedType: r.map(t => `image/${t}`).join(','), allowMultipleFiles: !0 }),
                  o.buttonView.set({ label: e('Insert image'), icon: Ul, tooltip: !0 }),
                  o.buttonView.bind('isEnabled').to(i),
                  o.on('done', (e, n) => {
                    const o = Array.from(n).filter(t => s.test(t.type));
                    o.length && t.execute('uploadImage', { file: o });
                  }),
                  o
                );
              };
            t.ui.componentFactory.add('uploadImage', n), t.ui.componentFactory.add('imageUpload', n);
          }
        }
        var Pk = n(49),
          Ik = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 },
          zk = (hd()(Pk.a, Ik), Pk.a.locals, n(50)),
          Fk = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 },
          Rk = (hd()(zk.a, Fk), zk.a.locals, n(51)),
          Ok = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Rk.a, Ok), Rk.a.locals;
        class Mk extends Qt {
          static get pluginName() {
            return 'ImageUploadProgress';
          }
          constructor(t) {
            super(t),
              (this.placeholder =
                'data:image/svg+xml;utf8,' +
                encodeURIComponent(
                  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 700 250"><rect rx="4"/></svg>',
                ));
          }
          init() {
            this.editor.editing.downcastDispatcher.on('attribute:uploadStatus:image', (...t) =>
              this.uploadStatusChange(...t),
            );
          }
          uploadStatusChange(t, e, n) {
            const o = this.editor,
              i = e.item,
              r = i.getAttribute('uploadId');
            if (!n.consumable.consume(e.item, t.name)) return;
            const s = o.plugins.get(Tp),
              a = r ? e.attributeNewValue : null,
              c = this.placeholder,
              l = o.editing.mapper.toViewElement(i),
              d = n.writer;
            if ('reading' == a) return Nk(l, d), void Vk(c, l, d);
            if ('uploading' == a) {
              const t = s.loaders.get(r);
              return (
                Nk(l, d),
                void (t
                  ? (Lk(l, d),
                    (function (t, e, n, o) {
                      const i = (function (t) {
                        const e = t.createUIElement('div', { class: 'ck-progress-bar' });
                        return t.setCustomProperty('progressBar', !0, e), e;
                      })(e);
                      e.insert(e.createPositionAt(t, 'end'), i),
                        n.on('change:uploadedPercent', (t, e, n) => {
                          o.change(t => {
                            t.setStyle('width', n + '%', i);
                          });
                        });
                    })(l, d, t, o.editing.view),
                    (function (t, e, n) {
                      if (n.data) {
                        const o = Hf(t);
                        e.setAttribute('src', n.data, o);
                      }
                    })(l, d, t))
                  : Vk(c, l, d))
              );
            }
            'complete' == a &&
              s.loaders.get(r) &&
              (function (t, e, n) {
                const o = e.createUIElement('div', { class: 'ck-image-upload-complete-icon' });
                e.insert(e.createPositionAt(t, 'end'), o),
                  setTimeout(() => {
                    n.change(t => t.remove(t.createRangeOn(o)));
                  }, 3e3);
              })(l, d, o.editing.view),
              (function (t, e) {
                qk(t, e, 'progressBar');
              })(l, d),
              Lk(l, d),
              (function (t, e) {
                e.removeClass('ck-appear', t);
              })(l, d);
          }
        }
        function Nk(t, e) {
          t.hasClass('ck-appear') || e.addClass('ck-appear', t);
        }
        function Vk(t, e, n) {
          e.hasClass('ck-image-upload-placeholder') || n.addClass('ck-image-upload-placeholder', e);
          const o = Hf(e);
          o.getAttribute('src') !== t && n.setAttribute('src', t, o),
            Kk(e, 'placeholder') ||
              n.insert(
                n.createPositionAfter(o),
                (function (t) {
                  const e = t.createUIElement('div', { class: 'ck-upload-placeholder-loader' });
                  return t.setCustomProperty('placeholder', !0, e), e;
                })(n),
              );
        }
        function Lk(t, e) {
          t.hasClass('ck-image-upload-placeholder') && e.removeClass('ck-image-upload-placeholder', t),
            qk(t, e, 'placeholder');
        }
        function Kk(t, e) {
          for (const n of t.getChildren()) if (n.getCustomProperty(e)) return n;
        }
        function qk(t, e, n) {
          const o = Kk(t, n);
          o && e.remove(e.createRangeOn(o));
        }
        class Hk extends Zt {
          refresh() {
            const t = this.editor.model.document.selection.getSelectedElement(),
              e = (t && 'image' === t.name) || !1;
            this.isEnabled = qf(this.editor.model) || e;
          }
          execute(t) {
            const e = this.editor,
              n = e.model,
              o = e.plugins.get(Tp);
            for (const e of ho(t.file)) jk(n, o, e);
          }
        }
        function jk(t, e, n) {
          const o = e.createLoader(n);
          o && Kf(t, { uploadId: o.id });
        }
        class $k extends Qt {
          static get requires() {
            return [Tp, Xh, Nm];
          }
          static get pluginName() {
            return 'ImageUploadEditing';
          }
          constructor(t) {
            super(t), t.config.define('image', { upload: { types: ['jpeg', 'png', 'gif', 'bmp', 'webp', 'tiff'] } });
          }
          init() {
            const t = this.editor,
              e = t.model.document,
              n = t.model.schema,
              o = t.conversion,
              i = t.plugins.get(Tp),
              r = Dk(t.config.get('image.upload.types'));
            n.extend('image', { allowAttributes: ['uploadId', 'uploadStatus'] });
            const s = new Hk(t);
            t.commands.add('uploadImage', s),
              t.commands.add('imageUpload', s),
              o.for('upcast').attributeToAttribute({ view: { name: 'img', key: 'uploadId' }, model: 'uploadId' }),
              this.listenTo(t.editing.view.document, 'clipboardInput', (e, n) => {
                if (((o = n.dataTransfer), Array.from(o.types).includes('text/html') && '' !== o.getData('text/html')))
                  return;
                var o;
                const i = Array.from(n.dataTransfer.files).filter(t => !!t && r.test(t.type));
                i.length &&
                  (e.stop(),
                  t.model.change(e => {
                    n.targetRanges && e.setSelection(n.targetRanges.map(e => t.editing.mapper.toModelRange(e))),
                      t.model.enqueueChange('default', () => {
                        t.execute('uploadImage', { file: i });
                      });
                  }));
              }),
              this.listenTo(t.plugins.get('ClipboardPipeline'), 'inputTransformation', (e, n) => {
                const o = Array.from(t.editing.view.createRangeIn(n.content))
                  .filter(t => {
                    return (
                      !(!(e = t.item).is('element', 'img') || !e.getAttribute('src')) &&
                      (e.getAttribute('src').match(/^data:image\/\w+;base64,/g) ||
                        e.getAttribute('src').match(/^blob:/g)) &&
                      !t.item.getAttribute('uploadProcessed')
                    );
                    var e;
                  })
                  .map(t => ({ promise: Sk(t.item), imageElement: t.item }));
                if (!o.length) return;
                const r = new Ku(t.editing.view.document);
                for (const t of o) {
                  r.setAttribute('uploadProcessed', !0, t.imageElement);
                  const e = i.createLoader(t.promise);
                  e && (r.setAttribute('src', '', t.imageElement), r.setAttribute('uploadId', e.id, t.imageElement));
                }
              }),
              t.editing.view.document.on('dragover', (t, e) => {
                e.preventDefault();
              }),
              e.on('change', () => {
                const n = e.differ.getChanges({ includeChangesInGraveyard: !0 });
                for (const e of n)
                  if ('insert' == e.type && '$text' != e.name) {
                    const n = e.position.nodeAfter,
                      o = '$graveyard' == e.position.root.rootName;
                    for (const e of Gk(t, n)) {
                      const t = e.getAttribute('uploadId');
                      if (!t) continue;
                      const n = i.loaders.get(t);
                      n && (o ? n.abort() : 'idle' == n.status && this._readAndUpload(n, e));
                    }
                  }
              }),
              this.on(
                'uploadComplete',
                (t, { imageElement: e, data: n }) => {
                  const o = n.urls ? n.urls : n;
                  this.editor.model.change(t => {
                    t.setAttribute('src', o.default, e), this._parseAndSetSrcsetAttributeOnImage(o, e, t);
                  });
                },
                { priority: 'low' },
              );
          }
          _readAndUpload(t, e) {
            const n = this.editor,
              o = n.model,
              i = n.locale.t,
              r = n.plugins.get(Tp),
              s = n.plugins.get(Xh);
            return (
              o.enqueueChange('transparent', t => {
                t.setAttribute('uploadStatus', 'reading', e);
              }),
              t
                .read()
                .then(() => {
                  const i = t.upload();
                  if (Mi.isSafari) {
                    const t = Hf(n.editing.mapper.toViewElement(e));
                    n.editing.view.once('render', () => {
                      if (!t.parent) return;
                      const e = n.editing.view.domConverter.mapViewToDom(t.parent);
                      if (!e) return;
                      const o = e.style.display;
                      (e.style.display = 'none'), (e._ckHack = e.offsetHeight), (e.style.display = o);
                    });
                  }
                  return (
                    o.enqueueChange('transparent', t => {
                      t.setAttribute('uploadStatus', 'uploading', e);
                    }),
                    i
                  );
                })
                .then(t => {
                  o.enqueueChange('transparent', n => {
                    n.setAttribute('uploadStatus', 'complete', e),
                      this.fire('uploadComplete', { data: t, imageElement: e });
                  }),
                    a();
                })
                .catch(n => {
                  if ('error' !== t.status && 'aborted' !== t.status) throw n;
                  'error' == t.status && n && s.showWarning(n, { title: i('Upload failed'), namespace: 'upload' }),
                    a(),
                    o.enqueueChange('transparent', t => {
                      t.remove(e);
                    });
                })
            );
            function a() {
              o.enqueueChange('transparent', t => {
                t.removeAttribute('uploadId', e), t.removeAttribute('uploadStatus', e);
              }),
                r.destroyLoader(t);
            }
          }
          _parseAndSetSrcsetAttributeOnImage(t, e, n) {
            let o = 0;
            const i = Object.keys(t)
              .filter(t => {
                const e = parseInt(t, 10);
                if (!isNaN(e)) return (o = Math.max(o, e)), !0;
              })
              .map(e => `${t[e]} ${e}w`)
              .join(', ');
            '' != i && n.setAttribute('srcset', { data: i, width: o }, e);
          }
        }
        function Gk(t, e) {
          return Array.from(t.model.createRangeOn(e))
            .filter(t => t.item.is('element', 'image'))
            .map(t => t.item);
        }
        class Wk extends Qt {
          static get pluginName() {
            return 'IndentEditing';
          }
          init() {
            const t = this.editor;
            t.commands.add('indent', new ee(t)), t.commands.add('outdent', new ee(t));
          }
        }
        var Uk =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>',
          Jk =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
        class Yk extends Qt {
          static get pluginName() {
            return 'IndentUI';
          }
          init() {
            const t = this.editor,
              e = t.locale,
              n = t.t,
              o = 'ltr' == e.uiLanguageDirection ? Uk : Jk,
              i = 'ltr' == e.uiLanguageDirection ? Jk : Uk;
            this._defineButton('indent', n('Increase indent'), o),
              this._defineButton('outdent', n('Decrease indent'), i);
          }
          _defineButton(t, e, n) {
            const o = this.editor;
            o.ui.componentFactory.add(t, i => {
              const r = o.commands.get(t),
                s = new jd(i);
              return (
                s.set({ label: e, icon: n, tooltip: !0 }),
                s.bind('isOn', 'isEnabled').to(r, 'value', 'isEnabled'),
                this.listenTo(s, 'execute', () => {
                  o.execute(t), o.editing.view.focus();
                }),
                s
              );
            });
          }
        }
        class Qk extends Zt {
          constructor(t, e) {
            super(t), (this._indentBehavior = e);
          }
          refresh() {
            const t = this.editor.model,
              e = Gs(t.document.selection.getSelectedBlocks());
            e && t.schema.checkAttribute(e, 'blockIndent')
              ? (this.isEnabled = this._indentBehavior.checkEnabled(e.getAttribute('blockIndent')))
              : (this.isEnabled = !1);
          }
          execute() {
            const t = this.editor.model,
              e = (function (t) {
                const e = t.document.selection,
                  n = t.schema;
                return Array.from(e.getSelectedBlocks()).filter(t => n.checkAttribute(t, 'blockIndent'));
              })(t);
            t.change(t => {
              for (const n of e) {
                const e = n.getAttribute('blockIndent'),
                  o = this._indentBehavior.getNextIndent(e);
                o ? t.setAttribute('blockIndent', o, n) : t.removeAttribute('blockIndent', n);
              }
            });
          }
        }
        class Xk {
          constructor(t) {
            (this.isForward = 'forward' === t.direction), (this.offset = t.offset), (this.unit = t.unit);
          }
          checkEnabled(t) {
            const e = parseFloat(t || 0);
            return this.isForward || e > 0;
          }
          getNextIndent(t) {
            const e = parseFloat(t || 0);
            if (!(!t || t.endsWith(this.unit))) return this.isForward ? this.offset + this.unit : void 0;
            const n = e + (this.isForward ? this.offset : -this.offset);
            return n > 0 ? n + this.unit : void 0;
          }
        }
        class Zk {
          constructor(t) {
            (this.isForward = 'forward' === t.direction), (this.classes = t.classes);
          }
          checkEnabled(t) {
            const e = this.classes.indexOf(t);
            return this.isForward ? e < this.classes.length - 1 : e >= 0;
          }
          getNextIndent(t) {
            const e = this.classes.indexOf(t),
              n = this.isForward ? 1 : -1;
            return this.classes[e + n];
          }
        }
        const tb = ['paragraph', 'heading1', 'heading2', 'heading3', 'heading4', 'heading5', 'heading6'];
        const eb = 'italic';
        class nb extends Qt {
          static get pluginName() {
            return 'ItalicEditing';
          }
          init() {
            const t = this.editor;
            t.model.schema.extend('$text', { allowAttributes: eb }),
              t.model.schema.setAttributeProperties(eb, { isFormatting: !0, copyOnEnter: !0 }),
              t.conversion.attributeToElement({
                model: eb,
                view: 'i',
                upcastAlso: ['em', { styles: { 'font-style': 'italic' } }],
              }),
              t.commands.add(eb, new Bm(t, eb)),
              t.keystrokes.set('CTRL+I', eb);
          }
        }
        const ob = 'italic';
        class ib extends Qt {
          static get pluginName() {
            return 'ItalicUI';
          }
          init() {
            const t = this.editor,
              e = t.t;
            t.ui.componentFactory.add(ob, n => {
              const o = t.commands.get(ob),
                i = new jd(n);
              return (
                i.set({
                  label: e('Italic'),
                  icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>',
                  keystroke: 'CTRL+I',
                  tooltip: !0,
                  isToggleable: !0,
                }),
                i.bind('isOn', 'isEnabled').to(o, 'value', 'isEnabled'),
                this.listenTo(i, 'execute', () => {
                  t.execute(ob), t.editing.view.focus();
                }),
                i
              );
            });
          }
        }
        class rb {
          constructor() {
            this._definitions = new Set();
          }
          get length() {
            return this._definitions.size;
          }
          add(t) {
            Array.isArray(t) ? t.forEach(t => this._definitions.add(t)) : this._definitions.add(t);
          }
          getDispatcher() {
            return t => {
              t.on(
                'attribute:linkHref',
                (t, e, n) => {
                  if (!n.consumable.test(e.item, 'attribute:linkHref')) return;
                  const o = n.writer,
                    i = o.document.selection;
                  for (const t of this._definitions) {
                    const r = o.createAttributeElement('a', t.attributes, { priority: 5 });
                    o.setCustomProperty('link', !0, r),
                      t.callback(e.attributeNewValue)
                        ? e.item.is('selection')
                          ? o.wrap(i.getFirstRange(), r)
                          : o.wrap(n.mapper.toViewRange(e.range), r)
                        : o.unwrap(n.mapper.toViewRange(e.range), r);
                  }
                },
                { priority: 'high' },
              );
            };
          }
          getDispatcherForLinkedImage() {
            return t => {
              t.on('attribute:linkHref:image', (t, e, n) => {
                const o = n.mapper.toViewElement(e.item),
                  i = Array.from(o.getChildren()).find(t => 'a' === t.name);
                for (const t of this._definitions) {
                  const o = vo(t.attributes);
                  if (t.callback(e.attributeNewValue))
                    for (const [t, e] of o) 'class' === t ? n.writer.addClass(e, i) : n.writer.setAttribute(t, e, i);
                  else
                    for (const [t, e] of o) 'class' === t ? n.writer.removeClass(e, i) : n.writer.removeAttribute(t, i);
                }
              });
            };
          }
        }
        var sb = function (t, e, n) {
            var o = t.length;
            return (n = void 0 === n ? o : n), !e && n >= o ? t : jo(t, e, n);
          },
          ab = RegExp('[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]');
        var cb = function (t) {
          return ab.test(t);
        };
        var lb = function (t) {
            return t.split('');
          },
          db = '[\\ud800-\\udfff]',
          hb = '[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]',
          ub = '\\ud83c[\\udffb-\\udfff]',
          pb = '[^\\ud800-\\udfff]',
          mb = '(?:\\ud83c[\\udde6-\\uddff]){2}',
          gb = '[\\ud800-\\udbff][\\udc00-\\udfff]',
          fb = '(?:' + hb + '|' + ub + ')' + '?',
          kb = '[\\ufe0e\\ufe0f]?',
          bb = kb + fb + ('(?:\\u200d(?:' + [pb, mb, gb].join('|') + ')' + kb + fb + ')*'),
          wb = '(?:' + [pb + hb + '?', hb, mb, gb, db].join('|') + ')',
          Ab = RegExp(ub + '(?=' + ub + ')|' + wb + bb, 'g');
        var _b = function (t) {
          return t.match(Ab) || [];
        };
        var Cb = function (t) {
          return cb(t) ? _b(t) : lb(t);
        };
        var vb = (function (t) {
          return function (e) {
            e = Vo(e);
            var n = cb(e) ? Cb(e) : void 0,
              o = n ? n[0] : e.charAt(0),
              i = n ? sb(n, 1).join('') : e.slice(1);
            return o[t]() + i;
          };
        })('toUpperCase');
        const yb = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
          xb = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i,
          Eb = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i,
          Db = /^((\w+:(\/{2,})?)|(\W))/i,
          Sb = 'Ctrl+K';
        function Bb(t, { writer: e }) {
          const n = e.createAttributeElement('a', { href: t }, { priority: 5 });
          return e.setCustomProperty('link', !0, n), n;
        }
        function Tb(t) {
          return (function (t) {
            return t.replace(yb, '').match(xb);
          })((t = String(t)))
            ? t
            : '#';
        }
        function Pb(t, e) {
          return !!t && t.is('element', 'image') && e.checkAttribute('image', 'linkHref');
        }
        function Ib(t, e) {
          const n = ((o = t), Eb.test(o) ? 'mailto:' : e);
          var o;
          const i = !!n && !Db.test(t);
          return t && i ? n + t : t;
        }
        class zb extends Zt {
          constructor(t) {
            super(t), (this.manualDecorators = new co()), (this.automaticDecorators = new rb());
          }
          restoreManualDecoratorStates() {
            for (const t of this.manualDecorators) t.value = this._getDecoratorStateFromModel(t.id);
          }
          refresh() {
            const t = this.editor.model,
              e = t.document,
              n = Gs(e.selection.getSelectedBlocks());
            Pb(n, t.schema)
              ? ((this.value = n.getAttribute('linkHref')), (this.isEnabled = t.schema.checkAttribute(n, 'linkHref')))
              : ((this.value = e.selection.getAttribute('linkHref')),
                (this.isEnabled = t.schema.checkAttributeInSelection(e.selection, 'linkHref')));
            for (const t of this.manualDecorators) t.value = this._getDecoratorStateFromModel(t.id);
          }
          execute(t, e = {}) {
            const n = this.editor.model,
              o = n.document.selection,
              i = [],
              r = [];
            for (const t in e) e[t] ? i.push(t) : r.push(t);
            n.change(e => {
              if (o.isCollapsed) {
                const s = o.getFirstPosition();
                if (o.hasAttribute('linkHref')) {
                  const a = wm(s, 'linkHref', o.getAttribute('linkHref'), n);
                  e.setAttribute('linkHref', t, a),
                    i.forEach(t => {
                      e.setAttribute(t, !0, a);
                    }),
                    r.forEach(t => {
                      e.removeAttribute(t, a);
                    }),
                    e.setSelection(e.createPositionAfter(a.end.nodeBefore));
                } else if ('' !== t) {
                  const r = vo(o.getAttributes());
                  r.set('linkHref', t),
                    i.forEach(t => {
                      r.set(t, !0);
                    });
                  const { end: a } = n.insertContent(e.createText(t, r), s);
                  e.setSelection(a);
                }
                ['linkHref', ...i, ...r].forEach(t => {
                  e.removeSelectionAttribute(t);
                });
              } else {
                const s = n.schema.getValidRanges(o.getRanges(), 'linkHref'),
                  a = [];
                for (const t of o.getSelectedBlocks())
                  n.schema.checkAttribute(t, 'linkHref') && a.push(e.createRangeOn(t));
                const c = a.slice();
                for (const t of s) this._isRangeToUpdate(t, a) && c.push(t);
                for (const n of c)
                  e.setAttribute('linkHref', t, n),
                    i.forEach(t => {
                      e.setAttribute(t, !0, n);
                    }),
                    r.forEach(t => {
                      e.removeAttribute(t, n);
                    });
              }
            });
          }
          _getDecoratorStateFromModel(t) {
            const e = this.editor.model,
              n = e.document,
              o = Gs(n.selection.getSelectedBlocks());
            return Pb(o, e.schema) ? o.getAttribute(t) : n.selection.getAttribute(t);
          }
          _isRangeToUpdate(t, e) {
            for (const n of e) if (n.containsRange(t)) return !1;
            return !0;
          }
        }
        class Fb extends Zt {
          refresh() {
            const t = this.editor.model,
              e = t.document,
              n = Gs(e.selection.getSelectedBlocks());
            Pb(n, t.schema)
              ? (this.isEnabled = t.schema.checkAttribute(n, 'linkHref'))
              : (this.isEnabled = t.schema.checkAttributeInSelection(e.selection, 'linkHref'));
          }
          execute() {
            const t = this.editor,
              e = this.editor.model,
              n = e.document.selection,
              o = t.commands.get('link');
            e.change(t => {
              const i = n.isCollapsed
                ? [wm(n.getFirstPosition(), 'linkHref', n.getAttribute('linkHref'), e)]
                : e.schema.getValidRanges(n.getRanges(), 'linkHref');
              for (const e of i)
                if ((t.removeAttribute('linkHref', e), o))
                  for (const n of o.manualDecorators) t.removeAttribute(n.id, e);
            });
          }
        }
        class Rb {
          constructor({ id: t, label: e, attributes: n, defaultValue: o }) {
            (this.id = t), this.set('value'), (this.defaultValue = o), (this.label = e), (this.attributes = n);
          }
        }
        Yt(Rb, jt);
        var Ob = n(52),
          Mb = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Ob.a, Mb), Ob.a.locals;
        const Nb = 'automatic',
          Vb = /^(https?:)?\/\//;
        class Lb extends Qt {
          static get pluginName() {
            return 'LinkEditing';
          }
          static get requires() {
            return [im, Qp, Nm];
          }
          constructor(t) {
            super(t), t.config.define('link', { addTargetToExternalLinks: !1 });
          }
          init() {
            const t = this.editor;
            t.model.schema.extend('$text', { allowAttributes: 'linkHref' }),
              t.conversion.for('dataDowncast').attributeToElement({ model: 'linkHref', view: Bb }),
              t.conversion
                .for('editingDowncast')
                .attributeToElement({ model: 'linkHref', view: (t, e) => Bb(Tb(t), e) }),
              t.conversion.for('upcast').elementToAttribute({
                view: { name: 'a', attributes: { href: !0 } },
                model: { key: 'linkHref', value: t => t.getAttribute('href') },
              }),
              t.commands.add('link', new zb(t)),
              t.commands.add('unlink', new Fb(t));
            const e = (function (t, e) {
              const n = { 'Open in a new tab': t('Open in a new tab'), Downloadable: t('Downloadable') };
              return e.forEach(t => (t.label && n[t.label] && (t.label = n[t.label]), t)), e;
            })(
              t.t,
              (function (t) {
                const e = [];
                if (t)
                  for (const [n, o] of Object.entries(t)) {
                    const t = Object.assign({}, o, { id: `link${vb(n)}` });
                    e.push(t);
                  }
                return e;
              })(t.config.get('link.decorators')),
            );
            this._enableAutomaticDecorators(e.filter(t => t.mode === Nb)),
              this._enableManualDecorators(e.filter(t => 'manual' === t.mode));
            t.plugins.get(im).registerAttribute('linkHref'),
              (function (t, e, n, o) {
                const i = t.editing.view,
                  r = new Set();
                i.document.registerPostFixer(i => {
                  const s = t.model.document.selection;
                  let a = !1;
                  if (s.hasAttribute(e)) {
                    const c = wm(s.getFirstPosition(), e, s.getAttribute(e), t.model),
                      l = t.editing.mapper.toViewRange(c);
                    for (const t of l.getItems())
                      t.is('element', n) && !t.hasClass(o) && (i.addClass(o, t), r.add(t), (a = !0));
                  }
                  return a;
                }),
                  t.conversion.for('editingDowncast').add(t => {
                    function e() {
                      i.change(t => {
                        for (const e of r.values()) t.removeClass(o, e), r.delete(e);
                      });
                    }
                    t.on('insert', e, { priority: 'highest' }),
                      t.on('remove', e, { priority: 'highest' }),
                      t.on('attribute', e, { priority: 'highest' }),
                      t.on('selection', e, { priority: 'highest' });
                  });
              })(t, 'linkHref', 'a', 'ck-link_selected'),
              this._enableInsertContentSelectionAttributesFixer(),
              this._enableClickingAfterLink(),
              this._enableTypingOverLink(),
              this._handleDeleteContentAfterLink();
          }
          _enableAutomaticDecorators(t) {
            const e = this.editor,
              n = e.commands.get('link').automaticDecorators;
            e.config.get('link.addTargetToExternalLinks') &&
              n.add({
                id: 'linkIsExternal',
                mode: Nb,
                callback: t => Vb.test(t),
                attributes: { target: '_blank', rel: 'noopener noreferrer' },
              }),
              n.add(t),
              n.length && e.conversion.for('downcast').add(n.getDispatcher());
          }
          _enableManualDecorators(t) {
            if (!t.length) return;
            const e = this.editor,
              n = e.commands.get('link').manualDecorators;
            t.forEach(t => {
              e.model.schema.extend('$text', { allowAttributes: t.id }),
                n.add(new Rb(t)),
                e.conversion.for('downcast').attributeToElement({
                  model: t.id,
                  view: (e, { writer: o }) => {
                    if (e) {
                      const e = n.get(t.id).attributes,
                        i = o.createAttributeElement('a', e, { priority: 5 });
                      return o.setCustomProperty('link', !0, i), i;
                    }
                  },
                }),
                e.conversion.for('upcast').elementToAttribute({
                  view: { name: 'a', attributes: n.get(t.id).attributes },
                  model: { key: t.id },
                });
            });
          }
          _enableInsertContentSelectionAttributesFixer() {
            const t = this.editor.model,
              e = t.document.selection;
            this.listenTo(
              t,
              'insertContent',
              () => {
                const n = e.anchor.nodeBefore,
                  o = e.anchor.nodeAfter;
                e.hasAttribute('linkHref') &&
                  n &&
                  n.hasAttribute('linkHref') &&
                  ((o && o.hasAttribute('linkHref')) ||
                    t.change(e => {
                      Kb(e, Hb(t.schema));
                    }));
              },
              { priority: 'low' },
            );
          }
          _enableClickingAfterLink() {
            const t = this.editor,
              e = t.model;
            t.editing.view.addObserver(Lu);
            let n = !1;
            this.listenTo(t.editing.view.document, 'mousedown', () => {
              n = !0;
            }),
              this.listenTo(t.editing.view.document, 'selectionChange', () => {
                if (!n) return;
                n = !1;
                const t = e.document.selection;
                if (!t.isCollapsed) return;
                if (!t.hasAttribute('linkHref')) return;
                const o = t.getFirstPosition(),
                  i = wm(o, 'linkHref', t.getAttribute('linkHref'), e);
                (o.isTouching(i.start) || o.isTouching(i.end)) &&
                  e.change(t => {
                    Kb(t, Hb(e.schema));
                  });
              });
          }
          _enableTypingOverLink() {
            const t = this.editor,
              e = t.editing.view;
            let n, o;
            this.listenTo(
              e.document,
              'delete',
              () => {
                o = !0;
              },
              { priority: 'high' },
            ),
              this.listenTo(
                t.model,
                'deleteContent',
                () => {
                  const e = t.model.document.selection;
                  e.isCollapsed ||
                    (o
                      ? (o = !1)
                      : qb(t) &&
                        (function (t) {
                          const e = t.document.selection,
                            n = e.getFirstPosition(),
                            o = e.getLastPosition(),
                            i = n.nodeAfter;
                          if (!i) return !1;
                          if (!i.is('$text')) return !1;
                          if (!i.hasAttribute('linkHref')) return !1;
                          const r = o.textNode || o.nodeBefore;
                          if (i === r) return !0;
                          return wm(n, 'linkHref', i.getAttribute('linkHref'), t).containsRange(
                            t.createRange(n, o),
                            !0,
                          );
                        })(t.model) &&
                        (n = e.getAttributes()));
                },
                { priority: 'high' },
              ),
              this.listenTo(
                t.model,
                'insertContent',
                (e, [i]) => {
                  (o = !1),
                    qb(t) &&
                      n &&
                      (t.model.change(t => {
                        for (const [e, o] of n) t.setAttribute(e, o, i);
                      }),
                      (n = null));
                },
                { priority: 'high' },
              );
          }
          _handleDeleteContentAfterLink() {
            const t = this.editor,
              e = t.model,
              n = e.document.selection,
              o = t.editing.view;
            let i = !1,
              r = !1;
            this.listenTo(
              o.document,
              'delete',
              (t, e) => {
                r = e.domEvent.keyCode === Li.backspace;
              },
              { priority: 'high' },
            ),
              this.listenTo(
                e,
                'deleteContent',
                () => {
                  i = !1;
                  const t = n.getFirstPosition(),
                    o = n.getAttribute('linkHref');
                  if (!o) return;
                  const r = wm(t, 'linkHref', o, e);
                  i = r.containsPosition(t) || r.end.isEqual(t);
                },
                { priority: 'high' },
              ),
              this.listenTo(
                e,
                'deleteContent',
                () => {
                  r &&
                    ((r = !1),
                    i ||
                      t.model.enqueueChange(t => {
                        Kb(t, Hb(e.schema));
                      }));
                },
                { priority: 'low' },
              );
          }
        }
        function Kb(t, e) {
          t.removeSelectionAttribute('linkHref');
          for (const n of e) t.removeSelectionAttribute(n);
        }
        function qb(t) {
          return t.plugins.get('Input').isInput(t.model.change(t => t.batch));
        }
        function Hb(t) {
          return t.getDefinition('$text').allowAttributes.filter(t => t.startsWith('link'));
        }
        var jb = n(53),
          $b = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(jb.a, $b), jb.a.locals;
        class Gb extends md {
          constructor(t, e) {
            super(t);
            const n = t.t;
            (this.focusTracker = new Ws()),
              (this.keystrokes = new Us()),
              (this.urlInputView = this._createUrlInput()),
              (this.saveButtonView = this._createButton(n('Save'), $l, 'ck-button-save')),
              (this.saveButtonView.type = 'submit'),
              (this.cancelButtonView = this._createButton(n('Cancel'), jl, 'ck-button-cancel', 'cancel')),
              (this._manualDecoratorSwitches = this._createManualDecoratorSwitches(e)),
              (this.children = this._createFormChildren(e.manualDecorators)),
              (this._focusables = new ld()),
              (this._focusCycler = new Yd({
                focusables: this._focusables,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
              }));
            const o = ['ck', 'ck-link-form', 'ck-responsive-form'];
            e.manualDecorators.length && o.push('ck-link-form_layout-vertical', 'ck-vertical-form'),
              this.setTemplate({ tag: 'form', attributes: { class: o, tabindex: '-1' }, children: this.children }),
              ad(this);
          }
          getDecoratorSwitchesState() {
            return Array.from(this._manualDecoratorSwitches).reduce((t, e) => ((t[e.name] = e.isOn), t), {});
          }
          render() {
            super.render(), cd({ view: this });
            [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView].forEach(
              t => {
                this._focusables.add(t), this.focusTracker.add(t.element);
              },
            ),
              this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          _createUrlInput() {
            const t = this.locale.t,
              e = new Yh(this.locale, Qh);
            return (e.label = t('Link URL')), e;
          }
          _createButton(t, e, n, o) {
            const i = new jd(this.locale);
            return (
              i.set({ label: t, icon: e, tooltip: !0 }),
              i.extendTemplate({ attributes: { class: n } }),
              o && i.delegate('execute').to(this, o),
              i
            );
          }
          _createManualDecoratorSwitches(t) {
            const e = this.createCollection();
            for (const n of t.manualDecorators) {
              const o = new Wd(this.locale);
              o.set({ name: n.id, label: n.label, withText: !0 }),
                o.bind('isOn').toMany([n, t], 'value', (t, e) => (void 0 === e && void 0 === t ? n.defaultValue : t)),
                o.on('execute', () => {
                  n.set('value', !o.isOn);
                }),
                e.add(o);
            }
            return e;
          }
          _createFormChildren(t) {
            const e = this.createCollection();
            if ((e.add(this.urlInputView), t.length)) {
              const t = new md();
              t.setTemplate({
                tag: 'ul',
                children: this._manualDecoratorSwitches.map(t => ({
                  tag: 'li',
                  children: [t],
                  attributes: { class: ['ck', 'ck-list__item'] },
                })),
                attributes: { class: ['ck', 'ck-reset', 'ck-list'] },
              }),
                e.add(t);
            }
            return e.add(this.saveButtonView), e.add(this.cancelButtonView), e;
          }
        }
        var Wb = n(54),
          Ub = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Wb.a, Ub), Wb.a.locals;
        class Jb extends md {
          constructor(t) {
            super(t);
            const e = t.t;
            (this.focusTracker = new Ws()),
              (this.keystrokes = new Us()),
              (this.previewButtonView = this._createPreviewButton()),
              (this.unlinkButtonView = this._createButton(
                e('Unlink'),
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>',
                'unlink',
              )),
              (this.editButtonView = this._createButton(e('Edit link'), od, 'edit')),
              this.set('href'),
              (this._focusables = new ld()),
              (this._focusCycler = new Yd({
                focusables: this._focusables,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
              })),
              this.setTemplate({
                tag: 'div',
                attributes: { class: ['ck', 'ck-link-actions', 'ck-responsive-form'], tabindex: '-1' },
                children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView],
              });
          }
          render() {
            super.render();
            [this.previewButtonView, this.editButtonView, this.unlinkButtonView].forEach(t => {
              this._focusables.add(t), this.focusTracker.add(t.element);
            }),
              this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          _createButton(t, e, n) {
            const o = new jd(this.locale);
            return o.set({ label: t, icon: e, tooltip: !0 }), o.delegate('execute').to(this, n), o;
          }
          _createPreviewButton() {
            const t = new jd(this.locale),
              e = this.bindTemplate,
              n = this.t;
            return (
              t.set({ withText: !0, tooltip: n('Open link in new tab') }),
              t.extendTemplate({
                attributes: {
                  class: ['ck', 'ck-link-actions__preview'],
                  href: e.to('href', t => t && Tb(t)),
                  target: '_blank',
                  rel: 'noopener noreferrer',
                },
              }),
              t.bind('label').to(this, 'href', t => t || n('This link has no URL')),
              t.bind('isEnabled').to(this, 'href', t => !!t),
              (t.template.tag = 'a'),
              (t.template.eventListeners = {}),
              t
            );
          }
        }
        const Yb = 'link-ui';
        class Qb extends Qt {
          static get requires() {
            return [pu];
          }
          static get pluginName() {
            return 'LinkUI';
          }
          init() {
            const t = this.editor;
            t.editing.view.addObserver(Vu),
              (this.actionsView = this._createActionsView()),
              (this.formView = this._createFormView()),
              (this._balloon = t.plugins.get(pu)),
              this._createToolbarLinkButton(),
              this._enableUserBalloonInteractions(),
              t.conversion
                .for('editingDowncast')
                .markerToHighlight({ model: Yb, view: { classes: ['ck-fake-link-selection'] } }),
              t.conversion.for('editingDowncast').markerToElement({
                model: Yb,
                view: { name: 'span', classes: ['ck-fake-link-selection', 'ck-fake-link-selection_collapsed'] },
              });
          }
          destroy() {
            super.destroy(), this.formView.destroy();
          }
          _createActionsView() {
            const t = this.editor,
              e = new Jb(t.locale),
              n = t.commands.get('link'),
              o = t.commands.get('unlink');
            return (
              e.bind('href').to(n, 'value'),
              e.editButtonView.bind('isEnabled').to(n),
              e.unlinkButtonView.bind('isEnabled').to(o),
              this.listenTo(e, 'edit', () => {
                this._addFormView();
              }),
              this.listenTo(e, 'unlink', () => {
                t.execute('unlink'), this._hideUI();
              }),
              e.keystrokes.set('Esc', (t, e) => {
                this._hideUI(), e();
              }),
              e.keystrokes.set(Sb, (t, e) => {
                this._addFormView(), e();
              }),
              e
            );
          }
          _createFormView() {
            const t = this.editor,
              e = t.commands.get('link'),
              n = t.config.get('link.defaultProtocol'),
              o = new Gb(t.locale, e);
            return (
              o.urlInputView.fieldView.bind('value').to(e, 'value'),
              o.urlInputView.bind('isReadOnly').to(e, 'isEnabled', t => !t),
              o.saveButtonView.bind('isEnabled').to(e),
              this.listenTo(o, 'submit', () => {
                const { value: e } = o.urlInputView.fieldView.element,
                  i = Ib(e, n);
                t.execute('link', i, o.getDecoratorSwitchesState()), this._closeFormView();
              }),
              this.listenTo(o, 'cancel', () => {
                this._closeFormView();
              }),
              o.keystrokes.set('Esc', (t, e) => {
                this._closeFormView(), e();
              }),
              o
            );
          }
          _createToolbarLinkButton() {
            const t = this.editor,
              e = t.commands.get('link'),
              n = t.t;
            t.keystrokes.set(Sb, (t, n) => {
              n(), e.isEnabled && this._showUI(!0);
            }),
              t.ui.componentFactory.add('link', t => {
                const o = new jd(t);
                return (
                  (o.isEnabled = !0),
                  (o.label = n('Link')),
                  (o.icon =
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>'),
                  (o.keystroke = Sb),
                  (o.tooltip = !0),
                  (o.isToggleable = !0),
                  o.bind('isEnabled').to(e, 'isEnabled'),
                  o.bind('isOn').to(e, 'value', t => !!t),
                  this.listenTo(o, 'execute', () => this._showUI(!0)),
                  o
                );
              });
          }
          _enableUserBalloonInteractions() {
            const t = this.editor.editing.view.document;
            this.listenTo(t, 'click', () => {
              this._getSelectedLinkElement() && this._showUI();
            }),
              this.editor.keystrokes.set(
                'Tab',
                (t, e) => {
                  this._areActionsVisible &&
                    !this.actionsView.focusTracker.isFocused &&
                    (this.actionsView.focus(), e());
                },
                { priority: 'high' },
              ),
              this.editor.keystrokes.set('Esc', (t, e) => {
                this._isUIVisible && (this._hideUI(), e());
              }),
              sd({
                emitter: this.formView,
                activator: () => this._isUIInPanel,
                contextElements: [this._balloon.view.element],
                callback: () => this._hideUI(),
              });
          }
          _addActionsView() {
            this._areActionsInPanel ||
              this._balloon.add({ view: this.actionsView, position: this._getBalloonPositionData() });
          }
          _addFormView() {
            if (this._isFormInPanel) return;
            const t = this.editor.commands.get('link');
            this.formView.disableCssTransitions(),
              this._balloon.add({ view: this.formView, position: this._getBalloonPositionData() }),
              this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(),
              this.formView.enableCssTransitions(),
              (this.formView.urlInputView.fieldView.element.value = t.value || '');
          }
          _closeFormView() {
            const t = this.editor.commands.get('link');
            t.restoreManualDecoratorStates(), void 0 !== t.value ? this._removeFormView() : this._hideUI();
          }
          _removeFormView() {
            this._isFormInPanel &&
              (this.formView.saveButtonView.focus(),
              this._balloon.remove(this.formView),
              this.editor.editing.view.focus(),
              this._hideFakeVisualSelection());
          }
          _showUI(t = !1) {
            this._getSelectedLinkElement()
              ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(),
                t && this._balloon.showStack('main'))
              : (this._showFakeVisualSelection(),
                this._addActionsView(),
                t && this._balloon.showStack('main'),
                this._addFormView()),
              this._startUpdatingUI();
          }
          _hideUI() {
            if (!this._isUIInPanel) return;
            const t = this.editor;
            this.stopListening(t.ui, 'update'),
              this.stopListening(this._balloon, 'change:visibleView'),
              t.editing.view.focus(),
              this._removeFormView(),
              this._balloon.remove(this.actionsView),
              this._hideFakeVisualSelection();
          }
          _startUpdatingUI() {
            const t = this.editor,
              e = t.editing.view.document;
            let n = this._getSelectedLinkElement(),
              o = r();
            const i = () => {
              const t = this._getSelectedLinkElement(),
                e = r();
              (n && !t) || (!n && e !== o)
                ? this._hideUI()
                : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()),
                (n = t),
                (o = e);
            };
            function r() {
              return e.selection.focus
                .getAncestors()
                .reverse()
                .find(t => t.is('element'));
            }
            this.listenTo(t.ui, 'update', i), this.listenTo(this._balloon, 'change:visibleView', i);
          }
          get _isFormInPanel() {
            return this._balloon.hasView(this.formView);
          }
          get _areActionsInPanel() {
            return this._balloon.hasView(this.actionsView);
          }
          get _areActionsVisible() {
            return this._balloon.visibleView === this.actionsView;
          }
          get _isUIInPanel() {
            return this._isFormInPanel || this._areActionsInPanel;
          }
          get _isUIVisible() {
            return this._balloon.visibleView == this.formView || this._areActionsVisible;
          }
          _getBalloonPositionData() {
            const t = this.editor.editing.view,
              e = this.editor.model,
              n = t.document;
            let o = null;
            if (e.markers.has(Yb)) {
              const e = Array.from(this.editor.editing.mapper.markerNameToElements(Yb)),
                n = t.createRange(t.createPositionBefore(e[0]), t.createPositionAfter(e[e.length - 1]));
              o = t.domConverter.viewRangeToDom(n);
            } else {
              const e = this._getSelectedLinkElement(),
                i = n.selection.getFirstRange();
              o = e ? t.domConverter.mapViewToDom(e) : t.domConverter.viewRangeToDom(i);
            }
            return { target: o };
          }
          _getSelectedLinkElement() {
            const t = this.editor.editing.view,
              e = t.document.selection;
            if (e.isCollapsed) return Xb(e.getFirstPosition());
            {
              const n = e.getFirstRange().getTrimmed(),
                o = Xb(n.start),
                i = Xb(n.end);
              return o && o == i && t.createRangeIn(o).getTrimmed().isEqual(n) ? o : null;
            }
          }
          _showFakeVisualSelection() {
            const t = this.editor.model;
            t.change(e => {
              const n = t.document.selection.getFirstRange();
              if (t.markers.has(Yb)) e.updateMarker(Yb, { range: n });
              else if (n.start.isAtEnd) {
                const o = n.start.getLastMatchingPosition(({ item: e }) => !t.schema.isContent(e), { boundaries: n });
                e.addMarker(Yb, { usingOperation: !1, affectsData: !1, range: e.createRange(o, n.end) });
              } else e.addMarker(Yb, { usingOperation: !1, affectsData: !1, range: n });
            });
          }
          _hideFakeVisualSelection() {
            const t = this.editor.model;
            t.markers.has(Yb) &&
              t.change(t => {
                t.removeMarker(Yb);
              });
          }
        }
        function Xb(t) {
          return t.getAncestors().find(t => {
            return (e = t).is('attributeElement') && !!e.getCustomProperty('link');
            var e;
          });
        }
        const Zb = new RegExp(
          '(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$',
          'i',
        );
        class tw extends Qt {
          static get pluginName() {
            return 'AutoLink';
          }
          init() {
            const t = this.editor.model.document.selection;
            t.on('change:range', () => {
              this.isEnabled = !t.anchor.parent.is('element', 'codeBlock');
            }),
              this._enableTypingHandling();
          }
          afterInit() {
            this._enableEnterHandling(), this._enableShiftEnterHandling();
          }
          _enableTypingHandling() {
            const t = this.editor,
              e = new om(t.model, t => {
                if (
                  !(function (t) {
                    return t.length > 4 && ' ' === t[t.length - 1] && ' ' !== t[t.length - 2];
                  })(t)
                )
                  return;
                const e = ew(t.substr(0, t.length - 1));
                return e ? { url: e } : void 0;
              }),
              n = t.plugins.get('Input');
            e.on('matched:data', (e, o) => {
              const { batch: i, range: r, url: s } = o;
              if (!n.isInput(i)) return;
              const a = r.end.getShiftedBy(-1),
                c = a.getShiftedBy(-s.length),
                l = t.model.createRange(c, a);
              this._applyAutoLink(s, l);
            }),
              e.bind('isEnabled').to(this);
          }
          _enableEnterHandling() {
            const t = this.editor,
              e = t.model,
              n = t.commands.get('enter');
            n &&
              n.on('execute', () => {
                const t = e.document.selection.getFirstPosition();
                if (!t.parent.previousSibling) return;
                const n = e.createRangeIn(t.parent.previousSibling);
                this._checkAndApplyAutoLinkOnRange(n);
              });
          }
          _enableShiftEnterHandling() {
            const t = this.editor,
              e = t.model,
              n = t.commands.get('shiftEnter');
            n &&
              n.on('execute', () => {
                const t = e.document.selection.getFirstPosition(),
                  n = e.createRange(e.createPositionAt(t.parent, 0), t.getShiftedBy(-1));
                this._checkAndApplyAutoLinkOnRange(n);
              });
          }
          _checkAndApplyAutoLinkOnRange(t) {
            const e = this.editor.model,
              { text: n, range: o } = nm(t, e),
              i = ew(n);
            if (i) {
              const t = e.createRange(o.end.getShiftedBy(-i.length), o.end);
              this._applyAutoLink(i, t);
            }
          }
          _applyAutoLink(t, e) {
            const n = this.editor.model;
            this.isEnabled &&
              (function (t, e) {
                return e.schema.checkAttributeInSelection(e.createSelection(t), 'linkHref');
              })(e, n) &&
              n.enqueueChange(n => {
                const o = this.editor.config.get('link.defaultProtocol'),
                  i = Ib(t, o);
                n.setAttribute('linkHref', i, e);
              });
          }
        }
        function ew(t) {
          const e = Zb.exec(t);
          return e ? e[2] : null;
        }
        class nw extends Zt {
          constructor(t, e) {
            super(t), (this.type = e);
          }
          refresh() {
            (this.value = this._getValue()), (this.isEnabled = this._checkEnabled());
          }
          execute(t = {}) {
            const e = this.editor.model,
              n = e.document,
              o = Array.from(n.selection.getSelectedBlocks()).filter(t => iw(t, e.schema)),
              i = void 0 !== t.forceValue ? !t.forceValue : this.value;
            e.change(t => {
              if (i) {
                let e = o[o.length - 1].nextSibling,
                  n = Number.POSITIVE_INFINITY,
                  i = [];
                for (; e && 'listItem' == e.name && 0 !== e.getAttribute('listIndent'); ) {
                  const t = e.getAttribute('listIndent');
                  t < n && (n = t);
                  const o = t - n;
                  i.push({ element: e, listIndent: o }), (e = e.nextSibling);
                }
                i = i.reverse();
                for (const e of i) t.setAttribute('listIndent', e.listIndent, e.element);
              }
              if (!i) {
                let t = Number.POSITIVE_INFINITY;
                for (const e of o)
                  e.is('element', 'listItem') && e.getAttribute('listIndent') < t && (t = e.getAttribute('listIndent'));
                (t = 0 === t ? 1 : t), ow(o, !0, t), ow(o, !1, t);
              }
              for (const e of o.reverse())
                i && 'listItem' == e.name
                  ? t.rename(e, 'paragraph')
                  : i || 'listItem' == e.name
                  ? i ||
                    'listItem' != e.name ||
                    e.getAttribute('listType') == this.type ||
                    t.setAttribute('listType', this.type, e)
                  : (t.setAttributes({ listType: this.type, listIndent: 0 }, e), t.rename(e, 'listItem'));
              this.fire('_executeCleanup', o);
            });
          }
          _getValue() {
            const t = Gs(this.editor.model.document.selection.getSelectedBlocks());
            return !!t && t.is('element', 'listItem') && t.getAttribute('listType') == this.type;
          }
          _checkEnabled() {
            if (this.value) return !0;
            const t = this.editor.model.document.selection,
              e = this.editor.model.schema,
              n = Gs(t.getSelectedBlocks());
            return !!n && iw(n, e);
          }
        }
        function ow(t, e, n) {
          const o = e ? t[0] : t[t.length - 1];
          if (o.is('element', 'listItem')) {
            let i = o[e ? 'previousSibling' : 'nextSibling'],
              r = o.getAttribute('listIndent');
            for (; i && i.is('element', 'listItem') && i.getAttribute('listIndent') >= n; )
              r > i.getAttribute('listIndent') && (r = i.getAttribute('listIndent')),
                i.getAttribute('listIndent') == r && t[e ? 'unshift' : 'push'](i),
                (i = i[e ? 'previousSibling' : 'nextSibling']);
          }
        }
        function iw(t, e) {
          return e.checkChild(t.parent, 'listItem') && !e.isObject(t);
        }
        class rw extends Zt {
          constructor(t, e) {
            super(t), (this._indentBy = 'forward' == e ? 1 : -1);
          }
          refresh() {
            this.isEnabled = this._checkEnabled();
          }
          execute() {
            const t = this.editor.model,
              e = t.document;
            let n = Array.from(e.selection.getSelectedBlocks());
            t.change(t => {
              const e = n[n.length - 1];
              let o = e.nextSibling;
              for (; o && 'listItem' == o.name && o.getAttribute('listIndent') > e.getAttribute('listIndent'); )
                n.push(o), (o = o.nextSibling);
              this._indentBy < 0 && (n = n.reverse());
              for (const e of n) {
                const n = e.getAttribute('listIndent') + this._indentBy;
                n < 0 ? t.rename(e, 'paragraph') : t.setAttribute('listIndent', n, e);
              }
              this.fire('_executeCleanup', n);
            });
          }
          _checkEnabled() {
            const t = Gs(this.editor.model.document.selection.getSelectedBlocks());
            if (!t || !t.is('element', 'listItem')) return !1;
            if (this._indentBy > 0) {
              const e = t.getAttribute('listIndent'),
                n = t.getAttribute('listType');
              let o = t.previousSibling;
              for (; o && o.is('element', 'listItem') && o.getAttribute('listIndent') >= e; ) {
                if (o.getAttribute('listIndent') == e) return o.getAttribute('listType') == n;
                o = o.previousSibling;
              }
              return !1;
            }
            return !0;
          }
        }
        function sw(t, e) {
          const n = e.mapper,
            o = e.writer,
            i = 'numbered' == t.getAttribute('listType') ? 'ol' : 'ul',
            r = (function (t) {
              const e = t.createContainerElement('li');
              return (e.getFillerOffset = mw), e;
            })(o),
            s = o.createContainerElement(i, null);
          return o.insert(o.createPositionAt(s, 0), r), n.bindElements(t, r), r;
        }
        function aw(t, e, n, o) {
          const i = e.parent,
            r = n.mapper,
            s = n.writer;
          let a = r.toViewPosition(o.createPositionBefore(t));
          const c = dw(t.previousSibling, {
              sameIndent: !0,
              smallerIndent: !0,
              listIndent: t.getAttribute('listIndent'),
            }),
            l = t.previousSibling;
          if (c && c.getAttribute('listIndent') == t.getAttribute('listIndent')) {
            const t = r.toViewElement(c);
            a = s.breakContainer(s.createPositionAfter(t));
          } else if (l && 'listItem' == l.name) {
            a = r.toViewPosition(o.createPositionAt(l, 'end'));
            const t = r.findMappedViewAncestor(a),
              e = uw(t);
            a = e ? s.createPositionBefore(e) : s.createPositionAt(t, 'end');
          } else a = r.toViewPosition(o.createPositionBefore(t));
          if (((a = lw(a)), s.insert(a, i), l && 'listItem' == l.name)) {
            const t = r.toViewElement(l),
              n = s.createRange(s.createPositionAt(t, 0), a).getWalker({ ignoreElementEnd: !0 });
            for (const t of n)
              if (t.item.is('element', 'li')) {
                const o = s.breakContainer(s.createPositionBefore(t.item)),
                  i = t.item.parent,
                  r = s.createPositionAt(e, 'end');
                cw(s, r.nodeBefore, r.nodeAfter), s.move(s.createRangeOn(i), r), (n.position = o);
              }
          } else {
            const n = i.nextSibling;
            if (n && (n.is('element', 'ul') || n.is('element', 'ol'))) {
              let o = null;
              for (const e of n.getChildren()) {
                const n = r.toModelElement(e);
                if (!(n && n.getAttribute('listIndent') > t.getAttribute('listIndent'))) break;
                o = e;
              }
              o &&
                (s.breakContainer(s.createPositionAfter(o)),
                s.move(s.createRangeOn(o.parent), s.createPositionAt(e, 'end')));
            }
          }
          cw(s, i, i.nextSibling), cw(s, i.previousSibling, i);
        }
        function cw(t, e, n) {
          return !e ||
            !n ||
            ('ul' != e.name && 'ol' != e.name) ||
            e.name != n.name ||
            e.getAttribute('class') !== n.getAttribute('class')
            ? null
            : t.mergeContainers(t.createPositionAfter(e));
        }
        function lw(t) {
          return t.getLastMatchingPosition(t => t.item.is('uiElement'));
        }
        function dw(t, e) {
          const n = !!e.sameIndent,
            o = !!e.smallerIndent,
            i = e.listIndent;
          let r = t;
          for (; r && 'listItem' == r.name; ) {
            const t = r.getAttribute('listIndent');
            if ((n && i == t) || (o && i > t)) return r;
            r = 'forward' === e.direction ? r.nextSibling : r.previousSibling;
          }
          return null;
        }
        function hw(t, e, n, o) {
          t.ui.componentFactory.add(e, i => {
            const r = t.commands.get(e),
              s = new jd(i);
            return (
              s.set({ label: n, icon: o, tooltip: !0, isToggleable: !0 }),
              s.bind('isOn', 'isEnabled').to(r, 'value', 'isEnabled'),
              s.on('execute', () => {
                t.execute(e), t.editing.view.focus();
              }),
              s
            );
          });
        }
        function uw(t) {
          for (const e of t.getChildren()) if ('ul' == e.name || 'ol' == e.name) return e;
          return null;
        }
        function pw(t, e) {
          const n = [],
            o = t.parent,
            i = { ignoreElementEnd: !0, startPosition: t, shallow: !0, direction: e },
            r = o.getAttribute('listIndent'),
            s = [...new ua(i)].filter(t => t.item.is('element')).map(t => t.item);
          for (const t of s) {
            if (!t.is('element', 'listItem')) break;
            if (t.getAttribute('listIndent') < r) break;
            if (!(t.getAttribute('listIndent') > r)) {
              if (t.getAttribute('listType') !== o.getAttribute('listType')) break;
              if (t.getAttribute('listStyle') !== o.getAttribute('listStyle')) break;
              'backward' === e ? n.unshift(t) : n.push(t);
            }
          }
          return n;
        }
        function mw() {
          const t = !this.isEmpty && ('ul' == this.getChild(0).name || 'ol' == this.getChild(0).name);
          return this.isEmpty || t ? 0 : ui.call(this);
        }
        function gw(t) {
          return (e, n, o) => {
            const i = o.consumable;
            if (
              !i.test(n.item, 'insert') ||
              !i.test(n.item, 'attribute:listType') ||
              !i.test(n.item, 'attribute:listIndent')
            )
              return;
            i.consume(n.item, 'insert'),
              i.consume(n.item, 'attribute:listType'),
              i.consume(n.item, 'attribute:listIndent');
            const r = n.item;
            aw(r, sw(r, o), o, t);
          };
        }
        function fw(t, e, n) {
          if (!n.consumable.consume(e.item, 'attribute:listType')) return;
          const o = n.mapper.toViewElement(e.item),
            i = n.writer;
          i.breakContainer(i.createPositionBefore(o)), i.breakContainer(i.createPositionAfter(o));
          const r = o.parent,
            s = 'numbered' == e.attributeNewValue ? 'ol' : 'ul';
          i.rename(s, r);
        }
        function kw(t, e, n) {
          const o = n.mapper.toViewElement(e.item).parent,
            i = n.writer;
          cw(i, o, o.nextSibling), cw(i, o.previousSibling, o);
          for (const t of e.item.getChildren()) n.consumable.consume(t, 'insert');
        }
        function bw(t, e, n) {
          if ('listItem' != e.item.name) {
            let t = n.mapper.toViewPosition(e.range.start);
            const o = n.writer,
              i = [];
            for (
              ;
              ('ul' == t.parent.name || 'ol' == t.parent.name) && ((t = o.breakContainer(t)), 'li' == t.parent.name);

            ) {
              const e = t,
                n = o.createPositionAt(t.parent, 'end');
              if (!e.isEqual(n)) {
                const t = o.remove(o.createRange(e, n));
                i.push(t);
              }
              t = o.createPositionAfter(t.parent);
            }
            if (i.length > 0) {
              for (let e = 0; e < i.length; e++) {
                const n = t.nodeBefore;
                if (((t = o.insert(t, i[e]).end), e > 0)) {
                  const e = cw(o, n, n.nextSibling);
                  e && e.parent == n && t.offset--;
                }
              }
              cw(o, t.nodeBefore, t.nodeAfter);
            }
          }
        }
        function ww(t, e, n) {
          const o = n.mapper.toViewPosition(e.position),
            i = o.nodeBefore,
            r = o.nodeAfter;
          cw(n.writer, i, r);
        }
        function Aw(t, e, n) {
          if (n.consumable.consume(e.viewItem, { name: !0 })) {
            const t = n.writer,
              o = t.createElement('listItem'),
              i = (function (t) {
                let e = 0,
                  n = t.parent;
                for (; n; ) {
                  if (n.is('element', 'li')) e++;
                  else {
                    const t = n.previousSibling;
                    t && t.is('element', 'li') && e++;
                  }
                  n = n.parent;
                }
                return e;
              })(e.viewItem);
            t.setAttribute('listIndent', i, o);
            const r = e.viewItem.parent && 'ol' == e.viewItem.parent.name ? 'numbered' : 'bulleted';
            if ((t.setAttribute('listType', r, o), !n.safeInsert(o, e.modelCursor))) return;
            const s = (function (t, e, n) {
              const { writer: o, schema: i } = n;
              let r = o.createPositionAfter(t);
              for (const s of e)
                if ('ul' == s.name || 'ol' == s.name) r = n.convertItem(s, r).modelCursor;
                else {
                  const e = n.convertItem(s, o.createPositionAt(t, 'end')),
                    a = e.modelRange.start.nodeAfter;
                  a &&
                    a.is('element') &&
                    !i.checkChild(t, a.name) &&
                    ((t = e.modelCursor.parent.is('element', 'listItem') ? e.modelCursor.parent : xw(e.modelCursor)),
                    (r = o.createPositionAfter(t)));
                }
              return r;
            })(o, e.viewItem.getChildren(), n);
            (e.modelRange = t.createRange(e.modelCursor, s)), n.updateConversionResult(o, e);
          }
        }
        function _w(t, e, n) {
          if (n.consumable.test(e.viewItem, { name: !0 })) {
            const t = Array.from(e.viewItem.getChildren());
            for (const e of t) {
              !(e.is('element', 'li') || Dw(e)) && e._remove();
            }
          }
        }
        function Cw(t, e, n) {
          if (n.consumable.test(e.viewItem, { name: !0 })) {
            if (0 === e.viewItem.childCount) return;
            const t = [...e.viewItem.getChildren()];
            let n = !1,
              o = !0;
            for (const e of t)
              n && !Dw(e) && e._remove(),
                e.is('$text')
                  ? (o && (e._data = e.data.trimStart()),
                    (e.nextSibling && !Dw(e.nextSibling)) || (e._data = e.data.trimEnd()))
                  : Dw(e) && (n = !0),
                (o = !1);
          }
        }
        function vw(t) {
          return (e, n) => {
            if (n.isPhantom) return;
            const o = n.modelPosition.nodeBefore;
            if (o && o.is('element', 'listItem')) {
              const e = n.mapper.toViewElement(o),
                i = e.getAncestors().find(Dw),
                r = t.createPositionAt(e, 0).getWalker();
              for (const t of r) {
                if ('elementStart' == t.type && t.item.is('element', 'li')) {
                  n.viewPosition = t.previousPosition;
                  break;
                }
                if ('elementEnd' == t.type && t.item == i) {
                  n.viewPosition = t.nextPosition;
                  break;
                }
              }
            }
          };
        }
        function yw(t, [e, n]) {
          let o,
            i = e.is('documentFragment') ? e.getChild(0) : e;
          if (((o = n ? this.createSelection(n) : this.document.selection), i && i.is('element', 'listItem'))) {
            const t = o.getFirstPosition();
            let e = null;
            if (
              (t.parent.is('element', 'listItem')
                ? (e = t.parent)
                : t.nodeBefore && t.nodeBefore.is('element', 'listItem') && (e = t.nodeBefore),
              e)
            ) {
              const t = e.getAttribute('listIndent');
              if (t > 0)
                for (; i && i.is('element', 'listItem'); )
                  i._setAttribute('listIndent', i.getAttribute('listIndent') + t), (i = i.nextSibling);
            }
          }
        }
        function xw(t) {
          const e = new ua({ startPosition: t });
          let n;
          do {
            n = e.next();
          } while (!n.value.item.is('element', 'listItem'));
          return n.value.item;
        }
        function Ew(t, e, n, o, i, r) {
          const s = dw(e.nodeBefore, { sameIndent: !0, smallerIndent: !0, listIndent: t, foo: 'b' }),
            a = i.mapper,
            c = i.writer,
            l = s ? s.getAttribute('listIndent') : null;
          let d;
          if (s)
            if (l == t) {
              const t = a.toViewElement(s).parent;
              d = c.createPositionAfter(t);
            } else {
              const t = r.createPositionAt(s, 'end');
              d = a.toViewPosition(t);
            }
          else d = n;
          d = lw(d);
          for (const t of [...o.getChildren()])
            Dw(t) && ((d = c.move(c.createRangeOn(t), d).end), cw(c, t, t.nextSibling), cw(c, t.previousSibling, t));
        }
        function Dw(t) {
          return t.is('element', 'ol') || t.is('element', 'ul');
        }
        class Sw extends Qt {
          static get pluginName() {
            return 'ListEditing';
          }
          static get requires() {
            return [Mp, tm];
          }
          init() {
            const t = this.editor;
            t.model.schema.register('listItem', {
              inheritAllFrom: '$block',
              allowAttributes: ['listType', 'listIndent'],
            });
            const e = t.data,
              n = t.editing;
            var o;
            t.model.document.registerPostFixer(e =>
              (function (t, e) {
                const n = t.document.differ.getChanges(),
                  o = new Map();
                let i = !1;
                for (const o of n)
                  if ('insert' == o.type && 'listItem' == o.name) r(o.position);
                  else if ('insert' == o.type && 'listItem' != o.name) {
                    if ('$text' != o.name) {
                      const n = o.position.nodeAfter;
                      n.hasAttribute('listIndent') && (e.removeAttribute('listIndent', n), (i = !0)),
                        n.hasAttribute('listType') && (e.removeAttribute('listType', n), (i = !0)),
                        n.hasAttribute('listStyle') && (e.removeAttribute('listStyle', n), (i = !0));
                      for (const e of Array.from(t.createRangeIn(n)).filter(t => t.item.is('element', 'listItem')))
                        r(e.previousPosition);
                    }
                    r(o.position.getShiftedBy(o.length));
                  } else
                    'remove' == o.type && 'listItem' == o.name
                      ? r(o.position)
                      : (('attribute' == o.type && 'listIndent' == o.attributeKey) ||
                          ('attribute' == o.type && 'listType' == o.attributeKey)) &&
                        r(o.range.start);
                for (const t of o.values()) s(t), a(t);
                return i;
                function r(t) {
                  const e = t.nodeBefore;
                  if (e && e.is('element', 'listItem')) {
                    let t = e;
                    if (o.has(t)) return;
                    for (let e = t.previousSibling; e && e.is('element', 'listItem'); e = t.previousSibling)
                      if (((t = e), o.has(t))) return;
                    o.set(e, t);
                  } else {
                    const e = t.nodeAfter;
                    e && e.is('element', 'listItem') && o.set(e, e);
                  }
                }
                function s(t) {
                  let n = 0,
                    o = null;
                  for (; t && t.is('element', 'listItem'); ) {
                    const r = t.getAttribute('listIndent');
                    if (r > n) {
                      let s;
                      null === o ? ((o = r - n), (s = n)) : (o > r && (o = r), (s = r - o)),
                        e.setAttribute('listIndent', s, t),
                        (i = !0);
                    } else (o = null), (n = t.getAttribute('listIndent') + 1);
                    t = t.nextSibling;
                  }
                }
                function a(t) {
                  let n = [],
                    o = null;
                  for (; t && t.is('element', 'listItem'); ) {
                    const r = t.getAttribute('listIndent');
                    if ((o && o.getAttribute('listIndent') > r && (n = n.slice(0, r + 1)), 0 != r))
                      if (n[r]) {
                        const o = n[r];
                        t.getAttribute('listType') != o && (e.setAttribute('listType', o, t), (i = !0));
                      } else n[r] = t.getAttribute('listType');
                    (o = t), (t = t.nextSibling);
                  }
                }
              })(t.model, e),
            ),
              n.mapper.registerViewToModelLength('li', Bw),
              e.mapper.registerViewToModelLength('li', Bw),
              n.mapper.on('modelToViewPosition', vw(n.view)),
              n.mapper.on(
                'viewToModelPosition',
                ((o = t.model),
                (t, e) => {
                  const n = e.viewPosition,
                    i = n.parent,
                    r = e.mapper;
                  if ('ul' == i.name || 'ol' == i.name) {
                    if (n.isAtEnd) {
                      const t = r.toModelElement(n.nodeBefore),
                        i = r.getModelLength(n.nodeBefore);
                      e.modelPosition = o.createPositionBefore(t).getShiftedBy(i);
                    } else {
                      const t = r.toModelElement(n.nodeAfter);
                      e.modelPosition = o.createPositionBefore(t);
                    }
                    t.stop();
                  } else if (
                    'li' == i.name &&
                    n.nodeBefore &&
                    ('ul' == n.nodeBefore.name || 'ol' == n.nodeBefore.name)
                  ) {
                    const s = r.toModelElement(i);
                    let a = 1,
                      c = n.nodeBefore;
                    for (; c && Dw(c); ) (a += r.getModelLength(c)), (c = c.previousSibling);
                    (e.modelPosition = o.createPositionBefore(s).getShiftedBy(a)), t.stop();
                  }
                }),
              ),
              e.mapper.on('modelToViewPosition', vw(n.view)),
              t.conversion.for('editingDowncast').add(e => {
                e.on('insert', bw, { priority: 'high' }),
                  e.on('insert:listItem', gw(t.model)),
                  e.on('attribute:listType:listItem', fw, { priority: 'high' }),
                  e.on('attribute:listType:listItem', kw, { priority: 'low' }),
                  e.on(
                    'attribute:listIndent:listItem',
                    (function (t) {
                      return (e, n, o) => {
                        if (!o.consumable.consume(n.item, 'attribute:listIndent')) return;
                        const i = o.mapper.toViewElement(n.item),
                          r = o.writer;
                        r.breakContainer(r.createPositionBefore(i)), r.breakContainer(r.createPositionAfter(i));
                        const s = i.parent,
                          a = s.previousSibling,
                          c = r.createRangeOn(s);
                        r.remove(c),
                          a && a.nextSibling && cw(r, a, a.nextSibling),
                          Ew(n.attributeOldValue + 1, n.range.start, c.start, i, o, t),
                          aw(n.item, i, o, t);
                        for (const t of n.item.getChildren()) o.consumable.consume(t, 'insert');
                      };
                    })(t.model),
                  ),
                  e.on(
                    'remove:listItem',
                    (function (t) {
                      return (e, n, o) => {
                        const i = o.mapper
                            .toViewPosition(n.position)
                            .getLastMatchingPosition(t => !t.item.is('element', 'li')).nodeAfter,
                          r = o.writer;
                        r.breakContainer(r.createPositionBefore(i)), r.breakContainer(r.createPositionAfter(i));
                        const s = i.parent,
                          a = s.previousSibling,
                          c = r.createRangeOn(s),
                          l = r.remove(c);
                        a && a.nextSibling && cw(r, a, a.nextSibling),
                          Ew(o.mapper.toModelElement(i).getAttribute('listIndent') + 1, n.position, c.start, i, o, t);
                        for (const t of r.createRangeIn(l).getItems()) o.mapper.unbindViewElement(t);
                        e.stop();
                      };
                    })(t.model),
                  ),
                  e.on('remove', ww, { priority: 'low' });
              }),
              t.conversion.for('dataDowncast').add(e => {
                e.on('insert', bw, { priority: 'high' }), e.on('insert:listItem', gw(t.model));
              }),
              t.conversion.for('upcast').add(t => {
                t.on('element:ul', _w, { priority: 'high' }),
                  t.on('element:ol', _w, { priority: 'high' }),
                  t.on('element:li', Cw, { priority: 'high' }),
                  t.on('element:li', Aw);
              }),
              t.model.on('insertContent', yw, { priority: 'high' }),
              t.commands.add('numberedList', new nw(t, 'numbered')),
              t.commands.add('bulletedList', new nw(t, 'bulleted')),
              t.commands.add('indentList', new rw(t, 'forward')),
              t.commands.add('outdentList', new rw(t, 'backward'));
            const i = n.view.document;
            this.listenTo(
              i,
              'enter',
              (t, e) => {
                const n = this.editor.model.document,
                  o = n.selection.getLastPosition().parent;
                n.selection.isCollapsed &&
                  'listItem' == o.name &&
                  o.isEmpty &&
                  (this.editor.execute('outdentList'), e.preventDefault(), t.stop());
              },
              { context: 'li' },
            ),
              this.listenTo(
                i,
                'delete',
                (t, e) => {
                  if ('backward' !== e.direction) return;
                  const n = this.editor.model.document.selection;
                  if (!n.isCollapsed) return;
                  const o = n.getFirstPosition();
                  if (!o.isAtStart) return;
                  const i = o.parent;
                  if ('listItem' !== i.name) return;
                  (i.previousSibling && 'listItem' === i.previousSibling.name) ||
                    (this.editor.execute('outdentList'), e.preventDefault(), t.stop());
                },
                { context: 'li' },
              );
            const r = t => (e, n) => {
              this.editor.commands.get(t).isEnabled && (this.editor.execute(t), n());
            };
            t.keystrokes.set('Tab', r('indentList')), t.keystrokes.set('Shift+Tab', r('outdentList'));
          }
          afterInit() {
            const t = this.editor.commands,
              e = t.get('indent'),
              n = t.get('outdent');
            e && e.registerChildCommand(t.get('indentList')), n && n.registerChildCommand(t.get('outdentList'));
          }
        }
        function Bw(t) {
          let e = 1;
          for (const n of t.getChildren())
            if ('ul' == n.name || 'ol' == n.name) for (const t of n.getChildren()) e += Bw(t);
          return e;
        }
        var Tw =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>',
          Pw =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>';
        class Iw extends Qt {
          static get pluginName() {
            return 'ListUI';
          }
          init() {
            const t = this.editor.t;
            hw(this.editor, 'numberedList', t('Numbered List'), Tw),
              hw(this.editor, 'bulletedList', t('Bulleted List'), Pw);
          }
        }
        class zw extends Zt {
          constructor(t, e) {
            super(t), (this._defaultType = e);
          }
          refresh() {
            (this.value = this._getValue()), (this.isEnabled = this._checkEnabled());
          }
          execute(t = {}) {
            const e = this.editor.model;
            let n = [...e.document.selection.getSelectedBlocks()]
              .filter(t => t.is('element', 'listItem'))
              .map(t => {
                const n = e.change(e => e.createPositionAt(t, 0));
                return [...pw(n, 'backward'), ...pw(n, 'forward')];
              })
              .flat();
            (n = [...new Set(n)]),
              n.length &&
                e.change(e => {
                  for (const o of n) e.setAttribute('listStyle', t.type || this._defaultType, o);
                });
          }
          _getValue() {
            const t = this.editor.model.document.selection.getFirstPosition().parent;
            return t && t.is('element', 'listItem') ? t.getAttribute('listStyle') : null;
          }
          _checkEnabled() {
            const t = this.editor,
              e = t.commands.get('numberedList'),
              n = t.commands.get('bulletedList');
            return e.isEnabled || n.isEnabled;
          }
        }
        const Fw = 'default';
        class Rw extends Qt {
          static get requires() {
            return [Sw];
          }
          static get pluginName() {
            return 'ListStyleEditing';
          }
          init() {
            const t = this.editor,
              e = t.model;
            e.schema.extend('listItem', { allowAttributes: ['listStyle'] }),
              t.commands.add('listStyle', new zw(t, Fw)),
              this.listenTo(
                t.commands.get('indentList'),
                '_executeCleanup',
                (function (t) {
                  return (e, n) => {
                    let o;
                    const i = n[0],
                      r = i.getAttribute('listIndent'),
                      s = n.filter(t => t.getAttribute('listIndent') === r);
                    if (i.previousSibling.getAttribute('listIndent') + 1 === r) o = Fw;
                    else {
                      const t = dw(i.previousSibling, { sameIndent: !0, direction: 'backward', listIndent: r });
                      o = t.getAttribute('listStyle');
                    }
                    t.model.change(t => {
                      for (const e of s) t.setAttribute('listStyle', o, e);
                    });
                  };
                })(t),
              ),
              this.listenTo(
                t.commands.get('outdentList'),
                '_executeCleanup',
                (function (t) {
                  return (e, n) => {
                    if (!(n = n.reverse().filter(t => t.is('element', 'listItem'))).length) return;
                    const o = n[0].getAttribute('listIndent'),
                      i = n[0].getAttribute('listType');
                    let r = n[0].previousSibling;
                    if (r.is('element', 'listItem')) for (; r.getAttribute('listIndent') !== o; ) r = r.previousSibling;
                    else r = null;
                    r || (r = n[n.length - 1].nextSibling),
                      r &&
                        r.is('element', 'listItem') &&
                        r.getAttribute('listType') === i &&
                        t.model.change(t => {
                          const e = n.filter(t => t.getAttribute('listIndent') === o);
                          for (const n of e) t.setAttribute('listStyle', r.getAttribute('listStyle'), n);
                        });
                  };
                })(t),
              ),
              this.listenTo(t.commands.get('bulletedList'), '_executeCleanup', Nw(t)),
              this.listenTo(t.commands.get('numberedList'), '_executeCleanup', Nw(t)),
              e.document.registerPostFixer(
                (function (t) {
                  return e => {
                    let n = !1;
                    const o = Vw(t.model.document.differ.getChanges()).filter(
                      t => 'todo' !== t.getAttribute('listType'),
                    );
                    if (!o.length) return n;
                    let i = o[o.length - 1].nextSibling;
                    if ((!i || !i.is('element', 'listItem')) && ((i = o[o.length - 1].previousSibling), i)) {
                      const t = o[0].getAttribute('listIndent');
                      for (
                        ;
                        i.is('element', 'listItem') &&
                        i.getAttribute('listIndent') !== t &&
                        ((i = i.previousSibling), i);

                      );
                    }
                    for (const t of o)
                      if (t.hasAttribute('listStyle')) {
                        const o = t.previousSibling;
                        Mw(o, t) && (e.setAttribute('listStyle', o.getAttribute('listStyle'), t), (n = !0));
                      } else
                        Ow(i, t)
                          ? e.setAttribute('listStyle', i.getAttribute('listStyle'), t)
                          : e.setAttribute('listStyle', Fw, t),
                          (n = !0);
                    return n;
                  };
                })(t),
              ),
              t.conversion.for('upcast').add(t => {
                t.on(
                  'element:li',
                  (t, e, n) => {
                    const o = e.viewItem.parent;
                    if (!o) return;
                    const i = o.getStyle('list-style-type') || Fw,
                      r = e.modelRange.start.nodeAfter || e.modelRange.end.nodeBefore;
                    n.writer.setAttribute('listStyle', i, r);
                  },
                  { priority: 'low' },
                );
              }),
              t.conversion.for('downcast').add(
                (function () {
                  return n => {
                    n.on(
                      'attribute:listStyle:listItem',
                      (n, o, i) => {
                        const r = i.writer,
                          s = o.item,
                          a = dw(s.previousSibling, {
                            sameIndent: !0,
                            listIndent: s.getAttribute('listIndent'),
                            direction: 'backward',
                          }),
                          c = i.mapper.toViewElement(s);
                        t(s, a) || r.breakContainer(r.createPositionBefore(c)), e(r, o.attributeNewValue, c.parent);
                      },
                      { priority: 'low' },
                    );
                  };
                  function t(t, e) {
                    return (
                      e &&
                      t.getAttribute('listType') === e.getAttribute('listType') &&
                      t.getAttribute('listIndent') === e.getAttribute('listIndent') &&
                      t.getAttribute('listStyle') === e.getAttribute('listStyle')
                    );
                  }
                  function e(t, e, n) {
                    e && e !== Fw ? t.setStyle('list-style-type', e, n) : t.removeStyle('list-style-type', n);
                  }
                })(),
              ),
              this._mergeListStyleAttributeWhileMergingLists();
          }
          afterInit() {
            const t = this.editor;
            t.commands.get('todoList') &&
              t.model.document.registerPostFixer(
                (function (t) {
                  return e => {
                    const n = Vw(t.model.document.differ.getChanges()).filter(
                      t => 'todo' === t.getAttribute('listType') && t.hasAttribute('listStyle'),
                    );
                    if (!n.length) return !1;
                    for (const t of n) e.removeAttribute('listStyle', t);
                    return !0;
                  };
                })(t),
              );
          }
          _mergeListStyleAttributeWhileMergingLists() {
            const t = this.editor.model;
            let e;
            this.listenTo(
              t,
              'deleteContent',
              (t, [n]) => {
                const o = n.getFirstPosition(),
                  i = n.getLastPosition();
                if (o.parent === i.parent) return;
                if (!o.parent.is('element', 'listItem')) return;
                const r = i.parent.nextSibling;
                if (!r || !r.is('element', 'listItem')) return;
                const s = dw(o.parent, { sameIndent: !0, listIndent: r.getAttribute('listIndent') });
                s && s.getAttribute('listType') === r.getAttribute('listType') && (e = s);
              },
              { priority: 'high' },
            ),
              this.listenTo(
                t,
                'deleteContent',
                () => {
                  e &&
                    (t.change(t => {
                      const n = dw(e.nextSibling, {
                          sameIndent: !0,
                          listIndent: e.getAttribute('listIndent'),
                          direction: 'forward',
                        }),
                        o = [n, ...pw(t.createPositionAt(n, 0), 'forward')];
                      for (const n of o) t.setAttribute('listStyle', e.getAttribute('listStyle'), n);
                    }),
                    (e = null));
                },
                { priority: 'low' },
              );
          }
        }
        function Ow(t, e) {
          if (!t) return !1;
          const n = t.getAttribute('listStyle');
          return !!n && n !== Fw && t.getAttribute('listType') === e.getAttribute('listType');
        }
        function Mw(t, e) {
          if (!t || !t.is('element', 'listItem')) return !1;
          if (e.getAttribute('listType') !== t.getAttribute('listType')) return !1;
          const n = t.getAttribute('listIndent');
          if (n < 1 || n !== e.getAttribute('listIndent')) return !1;
          const o = t.getAttribute('listStyle');
          return !(!o || o === e.getAttribute('listStyle'));
        }
        function Nw(t) {
          return (e, n) => {
            (n = n.filter(t => t.is('element', 'listItem'))),
              t.model.change(t => {
                for (const e of n) t.removeAttribute('listStyle', e);
              });
          };
        }
        function Vw(t) {
          const e = [];
          for (const n of t) {
            const t = Lw(n);
            t && t.is('element', 'listItem') && e.push(t);
          }
          return e;
        }
        function Lw(t) {
          return 'attribute' === t.type ? t.range.start.nodeAfter : 'insert' === t.type ? t.position.nodeAfter : null;
        }
        var Kw = n(55),
          qw = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Kw.a, qw), Kw.a.locals;
        class Hw extends Qt {
          static get pluginName() {
            return 'ListStyleUI';
          }
          init() {
            const t = this.editor,
              e = t.locale.t;
            t.ui.componentFactory.add(
              'bulletedList',
              jw({
                editor: t,
                parentCommandName: 'bulletedList',
                buttonLabel: e('Bulleted List'),
                buttonIcon: Pw,
                toolbarAriaLabel: e('Bulleted list styles toolbar'),
                styleDefinitions: [
                  {
                    label: e('Toggle the disc list style'),
                    tooltip: e('Disc'),
                    type: 'disc',
                    icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6z"/></svg>',
                  },
                  {
                    label: e('Toggle the circle list style'),
                    tooltip: e('Circle'),
                    type: 'circle',
                    icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4z"/></svg>',
                  },
                  {
                    label: e('Toggle the square list style'),
                    tooltip: e('Square'),
                    type: 'square',
                    icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M14 27v6H8v-6h6zm0-9v6H8v-6h6zm0-9v6H8V9h6z"/></svg>',
                  },
                ],
              }),
            ),
              t.ui.componentFactory.add(
                'numberedList',
                jw({
                  editor: t,
                  parentCommandName: 'numberedList',
                  buttonLabel: e('Numbered List'),
                  buttonIcon: Tw,
                  toolbarAriaLabel: e('Numbered list styles toolbar'),
                  styleDefinitions: [
                    {
                      label: e('Toggle the decimal list style'),
                      tooltip: e('Decimal'),
                      type: 'decimal',
                      icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M10.29 15V8.531H9.286c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.343 0v-1.235h-1.235V15h1.235zM11.3 24v-1.147H8.848c.064-.111.148-.226.252-.343.104-.117.351-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.494-.824.104-.263.156-.539.156-.829 0-.51-.182-.936-.545-1.279-.363-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.153-.155.358-.233.616-.233.26 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.468.536-1.024 1.055-.692.641-1.155 1.156-1.389 1.544-.234.389-.375.8-.422 1.233H11.3zm2.333 0v-1.235h-1.235V24h1.235zM9.204 34.11c.615 0 1.129-.2 1.542-.598.413-.398.62-.88.62-1.446 0-.39-.11-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.619-.337.928-.788.928-1.353 0-.399-.151-.756-.453-1.073-.366-.386-.852-.58-1.459-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.668.55c-.16.232-.28.544-.358.933l1.138.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.215 0 .386.065.515.194s.193.302.193.518c0 .255-.087.46-.263.613-.176.154-.43.227-.765.218l-.136 1.006c.22-.061.409-.092.567-.092.24 0 .444.09.61.272.168.182.251.428.251.739 0 .328-.087.589-.261.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.307-.698l-1.196.145c.062.542.285.98.668 1.316.384.335.868.503 1.45.503zm4.43-.11v-1.235h-1.236V34h1.235z"/></svg>',
                    },
                    {
                      label: e('Toggle the decimal with leading zero list style'),
                      tooltip: e('Decimal with leading zero'),
                      type: 'decimal-leading-zero',
                      icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M5.714 15.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm6.078.914V8.531H10.79c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.344 0v-1.235h-1.235V15h1.235zm-9.422 9.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm7.088.914v-1.147H10.35c.065-.111.149-.226.253-.343.104-.117.35-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.493-.824.104-.263.156-.539.156-.829 0-.51-.181-.936-.544-1.279-.364-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.152-.155.357-.233.615-.233.261 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.467.536-1.024 1.055-.691.641-1.154 1.156-1.388 1.544-.235.389-.375.8-.422 1.233h4.328zm2.334 0v-1.235h-1.235V24h1.235zM5.714 34.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm4.992 1.024c.616 0 1.13-.2 1.543-.598.413-.398.62-.88.62-1.446 0-.39-.111-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.618-.337.927-.788.927-1.353 0-.399-.15-.756-.452-1.073-.366-.386-.853-.58-1.46-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.667.55c-.16.232-.28.544-.359.933l1.139.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.214 0 .386.065.515.194s.193.302.193.518c0 .255-.088.46-.264.613-.175.154-.43.227-.764.218l-.136 1.006c.22-.061.408-.092.566-.092.24 0 .444.09.611.272.167.182.25.428.25.739 0 .328-.086.589-.26.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.308-.698l-1.195.145c.062.542.284.98.668 1.316.384.335.867.503 1.45.503zm4.43-.11v-1.235h-1.235V34h1.235z"/></svg>',
                    },
                    {
                      label: e('Toggle the lower–roman list style'),
                      tooltip: e('Lower–roman'),
                      type: 'lower-roman',
                      icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.88 8.7V7.558h-1.234V8.7h1.234zm0 5.3V9.333h-1.234V14h1.234zm2.5 0v-1.235h-1.234V14h1.235zm-4.75 4.7v-1.142H8.395V18.7H9.63zm0 5.3v-4.667H8.395V24H9.63zm2.5-5.3v-1.142h-1.234V18.7h1.235zm0 5.3v-4.667h-1.234V24h1.235zm2.501 0v-1.235h-1.235V24h1.235zM7.38 28.7v-1.142H6.145V28.7H7.38zm0 5.3v-4.667H6.145V34H7.38zm2.5-5.3v-1.142H8.646V28.7H9.88zm0 5.3v-4.667H8.646V34H9.88zm2.5-5.3v-1.142h-1.234V28.7h1.235zm0 5.3v-4.667h-1.234V34h1.235zm2.501 0v-1.235h-1.235V34h1.235z"/></svg>',
                    },
                    {
                      label: e('Toggle the upper–roman list style'),
                      tooltip: e('Upper-roman'),
                      type: 'upper-roman',
                      icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.916 15V8.558h-1.301V15h1.3zm2.465 0v-1.235h-1.235V15h1.235zM9.665 25v-6.442h-1.3V25h1.3zm2.5 0v-6.442h-1.3V25h1.3zm2.466 0v-1.235h-1.235V25h1.235zm-7.216 9v-6.442h-1.3V34h1.3zm2.5 0v-6.442h-1.3V34h1.3zm2.501 0v-6.442h-1.3V34h1.3zm2.465 0v-1.235h-1.235V34h1.235z"/></svg>',
                    },
                    {
                      label: e('Toggle the lower–latin list style'),
                      tooltip: e('Lower-latin'),
                      type: 'lower-latin',
                      icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M9.62 14.105c.272 0 .528-.05.768-.153s.466-.257.677-.462c.009.024.023.072.044.145.047.161.086.283.119.365h1.221a2.649 2.649 0 0 1-.222-.626c-.04-.195-.059-.498-.059-.908l.013-1.441c0-.536-.055-.905-.165-1.105-.11-.201-.3-.367-.569-.497-.27-.13-.68-.195-1.23-.195-.607 0-1.064.108-1.371.325-.308.217-.525.55-.65 1.002l1.12.202c.076-.217.176-.369.299-.455.123-.086.294-.13.514-.13.325 0 .546.05.663.152.118.101.176.27.176.508v.123c-.222.093-.622.194-1.2.303-.427.082-.755.178-.982.288-.227.11-.403.268-.53.474a1.327 1.327 0 0 0-.188.706c0 .398.138.728.415.988.277.261.656.391 1.136.391zm.368-.87a.675.675 0 0 1-.492-.189.606.606 0 0 1-.193-.448c0-.176.08-.32.241-.435.106-.07.33-.142.673-.215a7.19 7.19 0 0 0 .751-.19v.247c0 .296-.016.496-.048.602a.773.773 0 0 1-.295.409 1.07 1.07 0 0 1-.637.22zm4.645.765v-1.235h-1.235V14h1.235zM10.2 25.105c.542 0 1.003-.215 1.382-.646.38-.43.57-1.044.57-1.84 0-.771-.187-1.362-.559-1.774a1.82 1.82 0 0 0-1.41-.617c-.522 0-.973.216-1.354.65v-2.32H7.594V25h1.147v-.686a1.9 1.9 0 0 0 .67.592c.26.133.523.2.79.2zm-.299-.975c-.354 0-.638-.164-.852-.492-.153-.232-.229-.59-.229-1.073 0-.468.098-.818.295-1.048a.93.93 0 0 1 .738-.345c.302 0 .55.118.743.354.193.236.29.62.29 1.154 0 .5-.096.868-.288 1.1-.192.233-.424.35-.697.35zm4.478.87v-1.235h-1.234V25h1.234zm-4.017 9.105c.6 0 1.08-.142 1.437-.426.357-.284.599-.704.725-1.261l-1.213-.207c-.061.326-.167.555-.316.688a.832.832 0 0 1-.576.2.916.916 0 0 1-.75-.343c-.185-.228-.278-.62-.278-1.173 0-.498.091-.853.274-1.066.183-.212.429-.318.736-.318.232 0 .42.061.565.184.145.123.238.306.28.55l1.216-.22c-.146-.501-.387-.874-.722-1.119-.336-.244-.788-.366-1.356-.366-.695 0-1.245.214-1.653.643-.407.43-.61 1.03-.61 1.8 0 .762.202 1.358.608 1.788.406.431.95.646 1.633.646zM14.633 34v-1.235h-1.235V34h1.235z"/></svg>',
                    },
                    {
                      label: e('Toggle the upper–latin list style'),
                      tooltip: e('Upper-latin'),
                      type: 'upper-latin',
                      icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="m7.88 15 .532-1.463h2.575L11.549 15h1.415l-2.58-6.442H9.01L6.5 15h1.38zm2.69-2.549H8.811l.87-2.39.887 2.39zM14.88 15v-1.235h-1.234V15h1.234zM9.352 25c.83-.006 1.352-.02 1.569-.044.346-.038.636-.14.872-.305.236-.166.422-.387.558-.664.137-.277.205-.562.205-.855 0-.372-.106-.695-.317-.97-.21-.276-.512-.471-.905-.585a1.51 1.51 0 0 0 .661-.567 1.5 1.5 0 0 0 .244-.83c0-.28-.066-.53-.197-.754a1.654 1.654 0 0 0-.495-.539 1.676 1.676 0 0 0-.672-.266c-.25-.042-.63-.063-1.14-.063H7.158V25h2.193zm.142-3.88H8.46v-1.49h.747c.612 0 .983.007 1.112.022.217.026.38.102.49.226.11.125.165.287.165.486a.68.68 0 0 1-.192.503.86.86 0 0 1-.525.23 11.47 11.47 0 0 1-.944.023h.18zm.17 2.795H8.46v-1.723h1.05c.592 0 .977.03 1.154.092.177.062.313.16.406.295a.84.84 0 0 1 .14.492c0 .228-.06.41-.181.547a.806.806 0 0 1-.473.257c-.126.026-.423.04-.892.04zM14.88 25v-1.235h-1.234V25h1.234zm-5.018 9.11c.691 0 1.262-.17 1.711-.512.45-.341.772-.864.965-1.567l-1.261-.4c-.109.472-.287.818-.536 1.037-.25.22-.547.33-.892.33-.47 0-.85-.173-1.143-.519-.293-.345-.44-.925-.44-1.74 0-.767.15-1.322.447-1.665.297-.343.684-.514 1.162-.514.346 0 .64.096.881.29.242.193.4.457.477.79l1.288-.307c-.147-.516-.367-.911-.66-1.187-.492-.465-1.132-.698-1.92-.698-.902 0-1.63.296-2.184.89-.554.593-.83 1.426-.83 2.498 0 1.014.275 1.813.825 2.397.551.585 1.254.877 2.11.877zM14.88 34v-1.235h-1.234V34h1.234z"/></svg>',
                    },
                  ],
                }),
              );
          }
        }
        function jw({
          editor: t,
          parentCommandName: e,
          buttonLabel: n,
          buttonIcon: o,
          toolbarAriaLabel: i,
          styleDefinitions: r,
        }) {
          const s = t.commands.get(e),
            a = t.commands.get('listStyle');
          return c => {
            const l = Ih(c, rh),
              d = l.buttonView,
              h = (function ({ editor: t, listStyleCommand: e, parentCommandName: n }) {
                const o = t.locale,
                  i = t.commands.get(n);
                return ({ label: r, type: s, icon: a, tooltip: c }) => {
                  const l = new jd(o);
                  return (
                    l.set({ label: r, icon: a, tooltip: c }),
                    e.on('change:value', () => {
                      l.isOn = e.value === s;
                    }),
                    l.on('execute', () => {
                      i.value
                        ? e.value !== s
                          ? t.execute('listStyle', { type: s })
                          : t.execute('listStyle', { type: e._defaultType })
                        : t.model.change(() => {
                            t.execute(n), t.execute('listStyle', { type: s });
                          }),
                        t.editing.view.focus();
                    }),
                    l
                  );
                };
              })({ editor: t, parentCommandName: e, listStyleCommand: a });
            return (
              zh(l, r.map(h)),
              l.bind('isEnabled').to(s),
              (l.toolbarView.ariaLabel = i),
              (l.class = 'ck-list-styles-dropdown'),
              d.on('execute', () => {
                t.execute(e), t.editing.view.focus();
              }),
              d.set({ label: n, icon: o, tooltip: !0, isToggleable: !0 }),
              d.bind('isOn').to(s, 'value', t => !!t),
              l
            );
          };
        }
        const $w = 'removeFormat';
        class Gw extends Qt {
          static get pluginName() {
            return 'RemoveFormatUI';
          }
          init() {
            const t = this.editor,
              e = t.t;
            t.ui.componentFactory.add($w, n => {
              const o = t.commands.get($w),
                i = new jd(n);
              return (
                i.set({
                  label: e('Remove Format'),
                  icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>',
                  tooltip: !0,
                }),
                i.bind('isOn', 'isEnabled').to(o, 'value', 'isEnabled'),
                this.listenTo(i, 'execute', () => {
                  t.execute($w), t.editing.view.focus();
                }),
                i
              );
            });
          }
        }
        class Ww extends Zt {
          refresh() {
            const t = this.editor.model;
            this.isEnabled = !!Gs(this._getFormattingItems(t.document.selection, t.schema));
          }
          execute() {
            const t = this.editor.model,
              e = t.schema;
            t.change(n => {
              for (const o of this._getFormattingItems(t.document.selection, e))
                if (o.is('selection'))
                  for (const t of this._getFormattingAttributes(o, e)) n.removeSelectionAttribute(t);
                else {
                  const t = n.createRangeOn(o);
                  for (const i of this._getFormattingAttributes(o, e)) n.removeAttribute(i, t);
                }
            });
          }
          *_getFormattingItems(t, e) {
            const n = t => !!Gs(this._getFormattingAttributes(t, e));
            for (const o of t.getRanges()) for (const t of o.getItems()) !e.isBlock(t) && n(t) && (yield t);
            for (const e of t.getSelectedBlocks()) n(e) && (yield e);
            n(t) && (yield t);
          }
          *_getFormattingAttributes(t, e) {
            for (const [n] of t.getAttributes()) {
              const t = e.getAttributeProperties(n);
              t && t.isFormatting && (yield n);
            }
          }
        }
        class Uw extends Qt {
          static get pluginName() {
            return 'RemoveFormatEditing';
          }
          init() {
            const t = this.editor;
            t.commands.add('removeFormat', new Ww(t));
          }
        }
        Symbol.iterator;
        var Jw = n(56),
          Yw = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Jw.a, Yw), Jw.a.locals;
        var Qw = n(57),
          Xw = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Qw.a, Xw), Qw.a.locals;
        var Zw = n(58),
          tA = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(Zw.a, tA), Zw.a.locals;
        var eA = n(59),
          nA = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(eA.a, nA), eA.a.locals;
        const oA = 'todoListChecked';
        class iA extends Zt {
          constructor(t) {
            super(t),
              (this._selectedElements = []),
              this.on(
                'execute',
                () => {
                  this.refresh();
                },
                { priority: 'highest' },
              );
          }
          refresh() {
            (this._selectedElements = this._getSelectedItems()),
              (this.value = this._selectedElements.every(t => !!t.getAttribute('todoListChecked'))),
              (this.isEnabled = !!this._selectedElements.length);
          }
          _getSelectedItems() {
            const t = this.editor.model,
              e = t.schema,
              n = t.document.selection.getFirstRange(),
              o = n.start.parent,
              i = [];
            e.checkAttribute(o, oA) && i.push(o);
            for (const t of n.getItems()) e.checkAttribute(t, oA) && !i.includes(t) && i.push(t);
            return i;
          }
          execute(t = {}) {
            this.editor.model.change(e => {
              for (const n of this._selectedElements) {
                (void 0 === t.forceValue ? !this.value : t.forceValue)
                  ? e.setAttribute(oA, !0, n)
                  : e.removeAttribute(oA, n);
              }
            });
          }
        }
        function rA(t, e, n) {
          const o = e.modelCursor,
            i = o.parent,
            r = e.viewItem;
          if ('checkbox' != r.getAttribute('type') || 'listItem' != i.name || !o.isAtStart) return;
          if (!n.consumable.consume(r, { name: !0 })) return;
          const s = n.writer;
          s.setAttribute('listType', 'todo', i),
            e.viewItem.hasAttribute('checked') && s.setAttribute('todoListChecked', !0, i),
            (e.modelRange = s.createRange(o));
        }
        function sA(t) {
          return (e, n) => {
            const o = n.modelPosition,
              i = o.parent;
            if (!i.is('element', 'listItem') || 'todo' != i.getAttribute('listType')) return;
            const r = cA(n.mapper.toViewElement(i), t);
            r && (n.viewPosition = n.mapper.findPositionIn(r, o.offset));
          };
        }
        function aA(t, e, n, o) {
          return e.createUIElement('label', { class: 'todo-list__label', contenteditable: !1 }, function (e) {
            const i = Rs(document, 'input', { type: 'checkbox' });
            n && i.setAttribute('checked', 'checked'), i.addEventListener('change', () => o(t));
            const r = this.toDomElement(e);
            return r.appendChild(i), r;
          });
        }
        function cA(t, e) {
          const n = e.createRangeIn(t);
          for (const t of n)
            if (t.item.is('containerElement', 'span') && t.item.hasClass('todo-list__label__description'))
              return t.item;
        }
        const lA = Hi('Ctrl+Enter');
        class dA extends Qt {
          static get pluginName() {
            return 'TodoListEditing';
          }
          static get requires() {
            return [Sw];
          }
          init() {
            const t = this.editor,
              { editing: e, data: n, model: o } = t;
            o.schema.extend('listItem', { allowAttributes: ['todoListChecked'] }),
              o.schema.addAttributeCheck((t, e) => {
                const n = t.last;
                if ('todoListChecked' == e && 'listItem' == n.name && 'todo' != n.getAttribute('listType')) return !1;
              }),
              t.commands.add('todoList', new nw(t, 'todo'));
            const i = new iA(t);
            var r, s;
            t.commands.add('checkTodoList', i),
              t.commands.add('todoListCheck', i),
              n.downcastDispatcher.on(
                'insert:listItem',
                (function (t) {
                  return (e, n, o) => {
                    const i = o.consumable;
                    if (
                      !i.test(n.item, 'insert') ||
                      !i.test(n.item, 'attribute:listType') ||
                      !i.test(n.item, 'attribute:listIndent')
                    )
                      return;
                    if ('todo' != n.item.getAttribute('listType')) return;
                    const r = n.item;
                    i.consume(r, 'insert'),
                      i.consume(r, 'attribute:listType'),
                      i.consume(r, 'attribute:listIndent'),
                      i.consume(r, 'attribute:todoListChecked');
                    const s = o.writer,
                      a = sw(r, o);
                    s.addClass('todo-list', a.parent);
                    const c = s.createContainerElement('label', { class: 'todo-list__label' }),
                      l = s.createEmptyElement('input', { type: 'checkbox', disabled: 'disabled' }),
                      d = s.createContainerElement('span', { class: 'todo-list__label__description' });
                    r.getAttribute('todoListChecked') && s.setAttribute('checked', 'checked', l),
                      s.insert(s.createPositionAt(a, 0), c),
                      s.insert(s.createPositionAt(c, 0), l),
                      s.insert(s.createPositionAfter(l), d),
                      aw(r, a, o, t);
                  };
                })(o),
                { priority: 'high' },
              ),
              n.upcastDispatcher.on('element:input', rA, { priority: 'high' }),
              e.downcastDispatcher.on(
                'insert:listItem',
                (function (t, e) {
                  return (n, o, i) => {
                    const r = i.consumable;
                    if (
                      !r.test(o.item, 'insert') ||
                      !r.test(o.item, 'attribute:listType') ||
                      !r.test(o.item, 'attribute:listIndent')
                    )
                      return;
                    if ('todo' != o.item.getAttribute('listType')) return;
                    const s = o.item;
                    r.consume(s, 'insert'),
                      r.consume(s, 'attribute:listType'),
                      r.consume(s, 'attribute:listIndent'),
                      r.consume(s, 'attribute:todoListChecked');
                    const a = i.writer,
                      c = sw(s, i),
                      l = !!s.getAttribute('todoListChecked'),
                      d = aA(s, a, l, e),
                      h = a.createContainerElement('span', { class: 'todo-list__label__description' });
                    a.addClass('todo-list', c.parent),
                      a.insert(a.createPositionAt(c, 0), d),
                      a.insert(a.createPositionAfter(d), h),
                      aw(s, c, i, t);
                  };
                })(o, t => this._handleCheckmarkChange(t)),
                { priority: 'high' },
              ),
              e.downcastDispatcher.on(
                'attribute:listType:listItem',
                ((r = t => this._handleCheckmarkChange(t)),
                (s = e.view),
                (t, e, n) => {
                  const o = n.mapper.toViewElement(e.item),
                    i = n.writer,
                    a = (function (t, e) {
                      const n = e.createRangeIn(t);
                      for (const t of n) if (t.item.is('uiElement', 'label')) return t.item;
                    })(o, s);
                  if ('todo' == e.attributeNewValue) {
                    const t = !!e.item.getAttribute('todoListChecked'),
                      n = aA(e.item, i, t, r),
                      s = i.createContainerElement('span', { class: 'todo-list__label__description' }),
                      a = i.createRangeIn(o),
                      c = uw(o),
                      l = lw(a.start),
                      d = c ? i.createPositionBefore(c) : a.end,
                      h = i.createRange(l, d);
                    i.addClass('todo-list', o.parent),
                      i.move(h, i.createPositionAt(s, 0)),
                      i.insert(i.createPositionAt(o, 0), n),
                      i.insert(i.createPositionAfter(n), s);
                  } else if ('todo' == e.attributeOldValue) {
                    const t = cA(o, s);
                    i.removeClass('todo-list', o.parent),
                      i.remove(a),
                      i.move(i.createRangeIn(t), i.createPositionBefore(t)),
                      i.remove(t);
                  }
                }),
              ),
              e.downcastDispatcher.on(
                'attribute:todoListChecked:listItem',
                (function (t) {
                  return (e, n, o) => {
                    if ('todo' != n.item.getAttribute('listType')) return;
                    if (!o.consumable.consume(n.item, 'attribute:todoListChecked')) return;
                    const { mapper: i, writer: r } = o,
                      s = !!n.item.getAttribute('todoListChecked'),
                      a = i.toViewElement(n.item).getChild(0),
                      c = aA(n.item, r, s, t);
                    r.insert(r.createPositionAfter(a), c), r.remove(a);
                  };
                })(t => this._handleCheckmarkChange(t)),
              ),
              e.mapper.on('modelToViewPosition', sA(e.view)),
              n.mapper.on('modelToViewPosition', sA(e.view)),
              this.listenTo(
                e.view.document,
                'arrowKey',
                (function (t, e) {
                  return (n, o) => {
                    if ('left' != $i(o.keyCode, e.contentLanguageDirection)) return;
                    const i = t.schema,
                      r = t.document.selection;
                    if (!r.isCollapsed) return;
                    const s = r.getFirstPosition(),
                      a = s.parent;
                    if ('listItem' === a.name && 'todo' == a.getAttribute('listType') && s.isAtStart) {
                      const e = i.getNearestSelectionRange(t.createPositionBefore(a), 'backward');
                      e && t.change(t => t.setSelection(e)), o.preventDefault(), o.stopPropagation(), n.stop();
                    }
                  };
                })(o, t.locale),
                { context: 'li' },
              ),
              this.listenTo(
                e.view.document,
                'keydown',
                (e, n) => {
                  qi(n) === lA && (t.execute('checkTodoList'), e.stop());
                },
                { priority: 'high' },
              );
            const a = new Set();
            this.listenTo(o, 'applyOperation', (t, e) => {
              const n = e[0];
              if ('rename' == n.type && 'listItem' == n.oldName) {
                const t = n.position.nodeAfter;
                t.hasAttribute('todoListChecked') && a.add(t);
              } else if ('changeAttribute' == n.type && 'listType' == n.key && 'todo' === n.oldValue)
                for (const t of n.range.getItems())
                  t.hasAttribute('todoListChecked') && 'todo' !== t.getAttribute('listType') && a.add(t);
            }),
              o.document.registerPostFixer(t => {
                let e = !1;
                for (const n of a) t.removeAttribute('todoListChecked', n), (e = !0);
                return a.clear(), e;
              });
          }
          _handleCheckmarkChange(t) {
            const e = this.editor,
              n = e.model,
              o = Array.from(n.document.selection.getRanges());
            n.change(n => {
              n.setSelection(t, 'end'), e.execute('checkTodoList'), n.setSelection(o);
            });
          }
        }
        class hA extends Qt {
          static get pluginName() {
            return 'TodoListUI';
          }
          init() {
            const t = this.editor.t;
            hw(
              this.editor,
              'todoList',
              t('To-do List'),
              '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m2.315 14.705 2.224-2.24a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .949L2.865 16.07a.682.682 0 0 1-.112.089.647.647 0 0 1-.852-.051L.688 14.886a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.717.722zm5.185.045a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75zM2.329 5.745l2.21-2.226a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .95L2.865 7.125a.685.685 0 0 1-.496.196.644.644 0 0 1-.468-.187L.688 5.912a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.73.736zM7.5 5.75A.75.75 0 0 1 8.25 5h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>',
            );
          }
        }
        var uA = n(60),
          pA = { injectType: 'singletonStyleTag', attributes: { 'data-cke': !0 }, insert: 'head', singleton: !0 };
        hd()(uA.a, pA), uA.a.locals;
        const mA = 'underline';
        class gA extends Qt {
          static get pluginName() {
            return 'UnderlineEditing';
          }
          init() {
            const t = this.editor;
            t.model.schema.extend('$text', { allowAttributes: mA }),
              t.model.schema.setAttributeProperties(mA, { isFormatting: !0, copyOnEnter: !0 }),
              t.conversion.attributeToElement({
                model: mA,
                view: 'u',
                upcastAlso: { styles: { 'text-decoration': 'underline' } },
              }),
              t.commands.add(mA, new Bm(t, mA)),
              t.keystrokes.set('CTRL+U', 'underline');
          }
        }
        const fA = 'underline';
        class kA extends Qt {
          static get pluginName() {
            return 'UnderlineUI';
          }
          init() {
            const t = this.editor,
              e = t.t;
            t.ui.componentFactory.add(fA, n => {
              const o = t.commands.get(fA),
                i = new jd(n);
              return (
                i.set({
                  label: e('Underline'),
                  icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>',
                  keystroke: 'CTRL+U',
                  tooltip: !0,
                  isToggleable: !0,
                }),
                i.bind('isOn', 'isEnabled').to(o, 'value', 'isEnabled'),
                this.listenTo(i, 'execute', () => {
                  t.execute(fA), t.editing.view.focus();
                }),
                i
              );
            });
          }
        }
        class bA extends gp {}
        bA.builtinPlugins = [
          class extends Qt {
            static get requires() {
              return [Cp, yp];
            }
            static get pluginName() {
              return 'Alignment';
            }
          },
          class extends Qt {
            static get pluginName() {
              return 'Autoformat';
            }
            afterInit() {
              this._addListAutoformats(),
                this._addBasicStylesAutoformats(),
                this._addHeadingAutoformats(),
                this._addBlockQuoteAutoformats(),
                this._addCodeBlockAutoformats(),
                this._addHorizontalLineAutoformats();
            }
            _addListAutoformats() {
              const t = this.editor.commands;
              t.get('bulletedList') && xp(this.editor, this, /^[*-]\s$/, 'bulletedList'),
                t.get('numberedList') && xp(this.editor, this, /^1[.|)]\s$/, 'numberedList'),
                t.get('todoList') && xp(this.editor, this, /^\[\s?\]\s$/, 'todoList'),
                t.get('checkTodoList') &&
                  xp(this.editor, this, /^\[\s?x\s?\]\s$/, () => {
                    this.editor.execute('todoList'), this.editor.execute('checkTodoList');
                  });
            }
            _addBasicStylesAutoformats() {
              const t = this.editor.commands;
              if (t.get('bold')) {
                const t = Sp(this.editor, 'bold');
                Ep(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, t),
                  Ep(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, t);
              }
              if (t.get('italic')) {
                const t = Sp(this.editor, 'italic');
                Ep(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, t),
                  Ep(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, t);
              }
              if (t.get('code')) {
                const t = Sp(this.editor, 'code');
                Ep(this.editor, this, /(`)([^`]+)(`)$/g, t);
              }
              if (t.get('strikethrough')) {
                const t = Sp(this.editor, 'strikethrough');
                Ep(this.editor, this, /(~~)([^~]+)(~~)$/g, t);
              }
            }
            _addHeadingAutoformats() {
              const t = this.editor.commands.get('heading');
              t &&
                t.modelElements
                  .filter(t => t.match(/^heading[1-6]$/))
                  .forEach(e => {
                    const n = e[7],
                      o = new RegExp(`^(#{${n}})\\s$`);
                    xp(this.editor, this, o, () => {
                      if (!t.isEnabled || t.value === e) return !1;
                      this.editor.execute('heading', { value: e });
                    });
                  });
            }
            _addBlockQuoteAutoformats() {
              this.editor.commands.get('blockQuote') && xp(this.editor, this, /^>\s$/, 'blockQuote');
            }
            _addCodeBlockAutoformats() {
              this.editor.commands.get('codeBlock') && xp(this.editor, this, /^```$/, 'codeBlock');
            }
            _addHorizontalLineAutoformats() {
              this.editor.commands.get('horizontalLine') && xp(this.editor, this, /^---$/, 'horizontalLine');
            }
          },
          class extends Qt {
            static get requires() {
              return [xm, Sm];
            }
            static get pluginName() {
              return 'BlockQuote';
            }
          },
          class extends Qt {
            static get requires() {
              return [Pm, zm];
            }
            static get pluginName() {
              return 'Bold';
            }
          },
          class extends Qt {
            static get requires() {
              return [Eg, Mp, Ig, Kp, em, qg];
            }
            static get pluginName() {
              return 'Essentials';
            }
          },
          class extends Qt {
            static get requires() {
              return [nf, rf];
            }
            static get pluginName() {
              return 'FontBackgroundColor';
            }
          },
          class extends Qt {
            static get requires() {
              return [af, cf];
            }
            static get pluginName() {
              return 'FontColor';
            }
          },
          class extends Qt {
            static get requires() {
              return [pf, mf];
            }
            static get pluginName() {
              return 'FontFamily';
            }
          },
          class extends Qt {
            static get requires() {
              return [Af, vf];
            }
            static get pluginName() {
              return 'FontSize';
            }
          },
          class extends Qt {
            static get requires() {
              return [Tp];
            }
            static get pluginName() {
              return 'Base64UploadAdapter';
            }
            init() {
              this.editor.plugins.get(Tp).createUploadAdapter = t => new Ip(t);
            }
          },
          class extends Qt {
            static get requires() {
              return [Gf, gg, ok];
            }
            static get pluginName() {
              return 'Image';
            }
            isImageWidget(t) {
              return Nf(t);
            }
          },
          class extends Qt {
            static get pluginName() {
              return 'ImageUpload';
            }
            static get requires() {
              return [$k, Tk, Mk];
            }
          },
          class extends Qt {
            static get requires() {
              return [ck];
            }
            static get pluginName() {
              return 'ImageCaption';
            }
          },
          class extends Qt {
            static get requires() {
              return [fk, Ak, bk];
            }
            static get pluginName() {
              return 'ImageResize';
            }
          },
          class extends Qt {
            static get pluginName() {
              return 'Indent';
            }
            static get requires() {
              return [Wk, Yk];
            }
          },
          class extends Qt {
            constructor(t) {
              super(t), t.config.define('indentBlock', { offset: 40, unit: 'px' });
            }
            static get pluginName() {
              return 'IndentBlock';
            }
            init() {
              const t = this.editor,
                e = t.config.get('indentBlock'),
                n = !e.classes || !e.classes.length,
                o = Object.assign({ direction: 'forward' }, e),
                i = Object.assign({ direction: 'backward' }, e);
              n
                ? (t.data.addStyleProcessorRules(up),
                  this._setupConversionUsingOffset(t.conversion),
                  t.commands.add('indentBlock', new Qk(t, new Xk(o))),
                  t.commands.add('outdentBlock', new Qk(t, new Xk(i))))
                : (this._setupConversionUsingClasses(e.classes),
                  t.commands.add('indentBlock', new Qk(t, new Zk(o))),
                  t.commands.add('outdentBlock', new Qk(t, new Zk(i))));
            }
            afterInit() {
              const t = this.editor,
                e = t.model.schema,
                n = t.commands.get('indent'),
                o = t.commands.get('outdent'),
                i = t.config.get('heading.options');
              ((i && i.map(t => t.model)) || tb).forEach(t => {
                e.isRegistered(t) && e.extend(t, { allowAttributes: 'blockIndent' });
              }),
                e.setAttributeProperties('blockIndent', { isFormatting: !0 }),
                n.registerChildCommand(t.commands.get('indentBlock')),
                o.registerChildCommand(t.commands.get('outdentBlock'));
            }
            _setupConversionUsingOffset() {
              const t = this.editor.conversion,
                e = 'rtl' === this.editor.locale.contentLanguageDirection ? 'margin-right' : 'margin-left';
              t.for('upcast').attributeToAttribute({
                view: { styles: { [e]: /[\s\S]+/ } },
                model: { key: 'blockIndent', value: t => t.getStyle(e) },
              }),
                t
                  .for('downcast')
                  .attributeToAttribute({ model: 'blockIndent', view: t => ({ key: 'style', value: { [e]: t } }) });
            }
            _setupConversionUsingClasses(t) {
              const e = { model: { key: 'blockIndent', values: [] }, view: {} };
              for (const n of t) e.model.values.push(n), (e.view[n] = { key: 'class', value: [n] });
              this.editor.conversion.attributeToAttribute(e);
            }
          },
          class extends Qt {
            static get requires() {
              return [nb, ib];
            }
            static get pluginName() {
              return 'Italic';
            }
          },
          class extends Qt {
            static get requires() {
              return [Lb, Qb, tw];
            }
            static get pluginName() {
              return 'Link';
            }
          },
          class extends Qt {
            static get requires() {
              return [Sw, Iw];
            }
            static get pluginName() {
              return 'List';
            }
          },
          class extends Qt {
            static get requires() {
              return [Rw, Hw];
            }
            static get pluginName() {
              return 'ListStyle';
            }
          },
          Df,
          class extends Qt {
            static get requires() {
              return [Uw, Gw];
            }
            static get pluginName() {
              return 'RemoveFormat';
            }
          },
          class extends Qt {
            static get pluginName() {
              return 'TextTransformation';
            }
            constructor(t) {
              super(t), t.config.define('typing', { transformations: { include: mm } });
            }
            init() {
              const t = this.editor.model.document.selection;
              t.on('change:range', () => {
                this.isEnabled = !t.anchor.parent.is('element', 'codeBlock');
              }),
                this._enableTransformationWatchers();
            }
            _enableTransformationWatchers() {
              const t = this.editor,
                e = t.model,
                n = t.plugins.get('Input'),
                o = (function (t) {
                  const e = t.extra || [],
                    n = t.remove || [],
                    o = t => !n.includes(t);
                  return (function (t) {
                    const e = new Set();
                    for (const n of t)
                      if (pm[n]) for (const t of pm[n]) e.add(t);
                      else e.add(n);
                    return Array.from(e);
                  })(t.include.concat(e).filter(o))
                    .filter(o)
                    .map(t => um[t] || t)
                    .map(t => ({ from: gm(t.from), to: fm(t.to) }));
                })(t.config.get('typing.transformations')),
                i = new om(t.model, t => {
                  for (const e of o) {
                    if (e.from.test(t)) return { normalizedTransformation: e };
                  }
                });
              i.on('matched:data', (t, o) => {
                if (!n.isInput(o.batch)) return;
                const { from: i, to: r } = o.normalizedTransformation,
                  s = i.exec(o.text),
                  a = r(s.slice(1)),
                  c = o.range;
                let l = s.index;
                e.enqueueChange(t => {
                  for (let n = 1; n < s.length; n++) {
                    const o = s[n],
                      i = a[n - 1];
                    if (null == i) {
                      l += o.length;
                      continue;
                    }
                    const r = c.start.getShiftedBy(l),
                      d = e.createRange(r, r.getShiftedBy(o.length)),
                      h = km(r);
                    e.insertContent(t.createText(i, h), d), (l += i.length);
                  }
                });
              }),
                i.bind('isEnabled').to(this);
            }
          },
          class extends Qt {
            static get requires() {
              return [dA, hA];
            }
            static get pluginName() {
              return 'TodoList';
            }
          },
          class extends Qt {
            static get requires() {
              return [gA, kA];
            }
            static get pluginName() {
              return 'Underline';
            }
          },
          function (t) {
            t.model.schema.addAttributeCheck(t => {
              if (t.endsWith('blockQuote')) return !0;
            }),
              t.conversion.for('upcast').elementToElement({
                view: 'blockquote',
                model: (t, { writer: e }) => e.createElement('blockQuote', t.getAttributes()),
              }),
              t.conversion.for('downcast').elementToElement({ model: 'blockQuote', view: 'blockquote' }),
              t.conversion.for('downcast').add(t => {
                t.on('attribute', (t, e, n) => {
                  if ('blockQuote' !== e.item.name) return;
                  const o = n.writer,
                    i = n.mapper.toViewElement(e.item);
                  e.attributeNewValue && 'style' !== e.attributeKey
                    ? o.setAttribute(e.attributeKey, e.attributeNewValue, i)
                    : o.removeAttribute(e.attributeKey, i);
                });
              });
          },
          function (t) {
            t.model.schema.register('div', { allowWhere: '$block', allowContentOf: '$root' }),
              t.conversion.for('upcast').elementToElement({ view: 'div', model: 'div' }),
              t.conversion.for('downcast').elementToElement({ model: 'div', view: 'div' }),
              t.model.schema.extend('div', { allowAttributes: '__style' }),
              t.conversion
                .for('upcast')
                .attributeToAttribute({ model: { key: '__style', name: 'div' }, view: 'style' }),
              t.conversion.for('downcast').add(t => {
                t.on('attribute:__style:div', (t, e, n) => {
                  const o = n.mapper.toViewElement(e.item);
                  n.writer.setAttribute('style', e.attributeNewValue, o);
                });
              });
          },
          function (t) {
            t.model.schema.register('table', { allowWhere: '$block', allowContentOf: '$root' }),
              t.conversion.for('upcast').elementToElement({ view: 'table', model: 'table' }),
              t.conversion.for('downcast').elementToElement({ model: 'table', view: 'table' }),
              t.model.schema.extend('table', { allowAttributes: '__style' }),
              t.conversion
                .for('upcast')
                .attributeToAttribute({ model: { key: '__style', name: 'table' }, view: 'style' }),
              t.conversion.for('downcast').add(t => {
                t.on('attribute:__style:table', (t, e, n) => {
                  const o = n.mapper.toViewElement(e.item);
                  n.writer.setAttribute('style', e.attributeNewValue, o);
                });
              });
          },
          function (t) {
            t.model.schema.register('tr', { allowWhere: '$block', allowContentOf: '$root' }),
              t.conversion.for('upcast').elementToElement({ view: 'tr', model: 'tr' }),
              t.conversion.for('downcast').elementToElement({ model: 'tr', view: 'tr' }),
              t.model.schema.extend('tr', { allowAttributes: '__style' }),
              t.conversion.for('upcast').attributeToAttribute({ model: { key: '__style', name: 'tr' }, view: 'style' }),
              t.conversion.for('downcast').add(t => {
                t.on('attribute:__style:tr', (t, e, n) => {
                  const o = n.mapper.toViewElement(e.item);
                  n.writer.setAttribute('style', e.attributeNewValue, o);
                });
              });
          },
          function (t) {
            t.model.schema.register('td', { allowWhere: '$block', allowContentOf: '$root' }),
              t.conversion.for('upcast').elementToElement({ view: 'td', model: 'td' }),
              t.conversion.for('downcast').elementToElement({ model: 'td', view: 'td' }),
              t.model.schema.extend('td', { allowAttributes: '__style' }),
              t.conversion.for('upcast').attributeToAttribute({ model: { key: '__style', name: 'td' }, view: 'style' }),
              t.conversion.for('downcast').add(t => {
                t.on('attribute:__style:td', (t, e, n) => {
                  const o = n.mapper.toViewElement(e.item);
                  n.writer.setAttribute('style', e.attributeNewValue, o);
                });
              });
          },
          function (t) {
            t.model.schema.register('tbody', { allowWhere: '$block', allowContentOf: '$root' }),
              t.conversion.for('upcast').elementToElement({ view: 'tbody', model: 'tbody' }),
              t.conversion.for('downcast').elementToElement({ model: 'tbody', view: 'tbody' }),
              t.model.schema.extend('tbody', { allowAttributes: '__style' }),
              t.conversion
                .for('upcast')
                .attributeToAttribute({ model: { key: '__style', name: 'tbody' }, view: 'style' }),
              t.conversion.for('downcast').add(t => {
                t.on('attribute:__style:tbody', (t, e, n) => {
                  const o = n.mapper.toViewElement(e.item);
                  n.writer.setAttribute('style', e.attributeNewValue, o);
                });
              });
          },
        ];
        const wA = {
          fontSize: {
            options: [
              { title: 'Tiny', model: '10px' },
              { title: 'Small', model: '12px' },
              'default',
              { title: 'Big', model: '24px' },
              { title: 'Huge', model: '40px' },
            ],
            supportAllValues: !0,
          },
          toolbar: {
            items: [
              'fontfamily',
              'fontsize',
              '|',
              'bold',
              'italic',
              'underline',
              '|',
              'alignment',
              '|',
              'fontcolor',
              'fontbackgroundcolor',
              '|',
              'bulletedlist',
              'numberedlist',
              '|',
              'indent',
              'outdent',
              '|',
              'undo',
              'redo',
              '|',
              'removeformat',
            ],
            shouldNotGroupWhenFull: !0,
          },
        };
        bA.defaultConfig = wA;
        e.default = bA;
      },
    ]).default;
  });
//# sourceMappingURL=ckeditor.js.map
